Makefile:INSTALL = /usr/bin/install -c
Makefile:install_sh_DATA = $(install_sh) -c -m 644
Makefile:install_sh_PROGRAM = $(install_sh) -c
Makefile:install_sh_SCRIPT = $(install_sh) -c
Makefile:host_triplet = i686-pc-linux-gnu
Makefile:DEFAULT_INCLUDES = -I. -I$(srcdir) -I.
Makefile:	-o $@
Makefile:ACLOCAL = ${SHELL} /home/shini/sandbox/jikes/jikes-1.22/missing --run aclocal-1.8
Makefile:AMTAR = ${SHELL} /home/shini/sandbox/jikes/jikes-1.22/missing --run tar
Makefile:AUTOCONF = ${SHELL} /home/shini/sandbox/jikes/jikes-1.22/missing --run autoconf
Makefile:AUTOHEADER = ${SHELL} /home/shini/sandbox/jikes/jikes-1.22/missing --run autoheader
Makefile:AUTOMAKE = ${SHELL} /home/shini/sandbox/jikes/jikes-1.22/missing --run automake-1.8
Makefile:CXXCPP = g++ -E
Makefile:CXXFLAGS = -g -O2
Makefile:DEFS = -DHAVE_CONFIG_H
Makefile:ECHO_N = -n
Makefile:EGREP = grep -E
Makefile:INSTALL_DATA = ${INSTALL} -m 644
Makefile:INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
Makefile:MAKEINFO = ${SHELL} /home/shini/sandbox/jikes/jikes-1.22/missing --run makeinfo
Makefile:build = i686-pc-linux-gnu
Makefile:build_os = linux-gnu
Makefile:host = i686-pc-linux-gnu
Makefile:host_os = linux-gnu
Makefile:install_sh = /home/shini/sandbox/jikes/jikes-1.22/install-sh
Makefile:mkdir_p = mkdir -p -- .
Makefile:#JAVAC = jikes -nowarn -source 1.4
Makefile:	$(MAKE) $(AM_MAKEFLAGS) all-am
Makefile:	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
Makefile:	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/Makefile'; \
Makefile:	  $(AUTOMAKE) --foreign  src/Makefile
Makefile:	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
Makefile:	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
Makefile:	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
Makefile:	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
Makefile:config.h: stamp-h1
Makefile:	@if test ! -f $@; then \
Makefile:	  rm -f stamp-h1; \
Makefile:	  $(MAKE) stamp-h1; \
Makefile:stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
Makefile:	@rm -f stamp-h1
Makefile:	rm -f stamp-h1
Makefile:distclean-hdr:
Makefile:	-rm -f config.h stamp-h1
Makefile:install-binPROGRAMS: $(bin_PROGRAMS)
Makefile:	test -z "$(bindir)" || $(mkdir_p) "$(DESTDIR)$(bindir)"
Makefile:	  if test -f $$p \
Makefile:uninstall-binPROGRAMS:
Makefile:	  echo " rm -f '$(DESTDIR)$(bindir)/$$f'"; \
Makefile:	  rm -f "$(DESTDIR)$(bindir)/$$f"; \
Makefile:clean-binPROGRAMS:
Makefile:	-test -z "$(bin_PROGRAMS)" || rm -f $(bin_PROGRAMS)
Makefile:	@rm -f jikes$(EXEEXT)
Makefile:mostlyclean-compile:
Makefile:	-rm -f *.$(OBJEXT)
Makefile:distclean-compile:
Makefile:	-rm -f *.tab.c
Makefile:	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
Makefile:	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
Makefile:#	$(CXXCOMPILE) -c -o $@ $<
Makefile:	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
Makefile:	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
Makefile:#	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
Makefile:uninstall-info-am:
Makefile:install-includeHEADERS: $(include_HEADERS)
Makefile:	test -z "$(includedir)" || $(mkdir_p) "$(DESTDIR)$(includedir)"
Makefile:	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
Makefile:	  f="`echo $$p | sed -e 's|^.*/||'`"; \
Makefile:uninstall-includeHEADERS:
Makefile:	  f="`echo $$p | sed -e 's|^.*/||'`"; \
Makefile:	  echo " rm -f '$(DESTDIR)$(includedir)/$$f'"; \
Makefile:	  rm -f "$(DESTDIR)$(includedir)/$$f"; \
Makefile:	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
Makefile:	mkid -fID $$unique
Makefile:	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
Makefile:	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
Makefile:	  test -z "$$unique" && unique=$$empty_fix; \
Makefile:	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
Makefile:	test -z "$(CTAGS_ARGS)$$tags$$unique" \
Makefile:	  && gtags -i $(GTAGS_ARGS) $$here
Makefile:distclean-tags:
Makefile:	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
Makefile:	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
Makefile:	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
Makefile:	  if test -d $$d/$$file; then \
Makefile:	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
Makefile:	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
Makefile:	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
Makefile:	    test -f $(distdir)/$$file \
Makefile:	    || cp -p $$d/$$file $(distdir)/$$file \
Makefile:check-am: all-am
Makefile:	$(MAKE) $(AM_MAKEFLAGS) check-am
Makefile:all-am: Makefile $(PROGRAMS) $(HEADERS) config.h
Makefile:	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
Makefile:	$(MAKE) $(AM_MAKEFLAGS) install-am
Makefile:install-exec: install-exec-am
Makefile:install-data: install-data-am
Makefile:uninstall: uninstall-am
Makefile:install-am: all-am
Makefile:	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
Makefile:installcheck: installcheck-am
Makefile:install-strip:
Makefile:	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
Makefile:	  `test -z '$(STRIP)' || \
Makefile:mostlyclean-generic:
Makefile:clean-generic:
Makefile:distclean-generic:
Makefile:	-rm -f $(CONFIG_CLEAN_FILES)
Makefile:maintainer-clean-generic:
Makefile:	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
Makefile:clean: clean-am
Makefile:clean-am: clean-binPROGRAMS clean-generic mostlyclean-am
Makefile:distclean: distclean-am
Makefile:	-rm -rf ./$(DEPDIR)
Makefile:	-rm -f Makefile
Makefile:distclean-am: clean-am distclean-compile distclean-generic \
Makefile:	distclean-hdr distclean-tags
Makefile:dvi: dvi-am
Makefile:dvi-am:
Makefile:html: html-am
Makefile:info: info-am
Makefile:info-am:
Makefile:install-data-am: install-includeHEADERS
Makefile:install-exec-am: install-binPROGRAMS
Makefile:install-info: install-info-am
Makefile:install-man:
Makefile:installcheck-am:
Makefile:maintainer-clean: maintainer-clean-am
Makefile:	-rm -rf ./$(DEPDIR)
Makefile:	-rm -f Makefile
Makefile:maintainer-clean-am: distclean-am maintainer-clean-generic
Makefile:mostlyclean: mostlyclean-am
Makefile:mostlyclean-am: mostlyclean-compile mostlyclean-generic
Makefile:pdf: pdf-am
Makefile:pdf-am:
Makefile:ps: ps-am
Makefile:ps-am:
Makefile:uninstall-am: uninstall-binPROGRAMS uninstall-includeHEADERS \
Makefile:	uninstall-info-am
Makefile:.PHONY: CTAGS GTAGS all all-am check check-am clean clean-binPROGRAMS \
Makefile:	clean-generic ctags distclean distclean-compile \
Makefile:	distclean-generic distclean-hdr distclean-tags distdir dvi \
Makefile:	dvi-am html html-am info info-am install install-am \
Makefile:	install-binPROGRAMS install-data install-data-am install-exec \
Makefile:	install-exec-am install-includeHEADERS install-info \
Makefile:	install-info-am install-man install-strip installcheck \
Makefile:	installcheck-am installdirs maintainer-clean \
Makefile:	maintainer-clean-generic mostlyclean mostlyclean-compile \
Makefile:	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
Makefile:	uninstall-am uninstall-binPROGRAMS uninstall-includeHEADERS \
Makefile:	uninstall-info-am
Makefile:#	@rm -f javaact.tmp
Makefile:#	rm -f $(srcdir)/java.l
Makefile:#	@mv -f javaact.tmp $@
Makefile:#	@if test -f $@; then :; else \
Makefile:#	  rm -f javaact.stamp; \
Makefile:#	@rm -f code.tmp
Makefile:#	$(JAVAC) -d $(srcdir) $<
Makefile:#	(cd $(srcdir); $(JAVA) -classpath . gencode)
Makefile:#	@mv -f code.tmp $@
Makefile:#	@if test -f $@; then :; else \
Makefile:#	  rm -f code.stamp; \
Makefile:	@rm -f jikes$(EXEEXT)
Makefile:	$(CXXLINK) -o jikes$(EXEEXT) $(jikes_OBJECTS) -lstdc++ -lefence
Makefile.am:	@rm -f javaact.tmp
Makefile.am:	rm -f $(srcdir)/java.l
Makefile.am:	@mv -f javaact.tmp $@
Makefile.am:	@if test -f $@; then :; else \
Makefile.am:	  rm -f javaact.stamp; \
Makefile.am:JAVAC = jikes -nowarn -source 1.4
Makefile.am:	@rm -f code.tmp
Makefile.am:	$(JAVAC) -d $(srcdir) $<
Makefile.am:	(cd $(srcdir); $(JAVA) -classpath . gencode)
Makefile.am:	@mv -f code.tmp $@
Makefile.am:	@if test -f $@; then :; else \
Makefile.am:	  rm -f code.stamp; \
Makefile.am:	@rm -f jikes$(EXEEXT)
Makefile.am:	$(CXXLINK) -o jikes$(EXEEXT) $(jikes_OBJECTS) -lstdc++ -lefence
Makefile.in:install_sh_DATA = $(install_sh) -c -m 644
Makefile.in:install_sh_PROGRAM = $(install_sh) -c
Makefile.in:install_sh_SCRIPT = $(install_sh) -c
Makefile.in:DEFAULT_INCLUDES = -I. -I$(srcdir) -I.
Makefile.in:	-o $@
Makefile.in:@MAINTAINER_MODE_TRUE@JAVAC = jikes -nowarn -source 1.4
Makefile.in:	$(MAKE) $(AM_MAKEFLAGS) all-am
Makefile.in:	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
Makefile.in:	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/Makefile'; \
Makefile.in:	  $(AUTOMAKE) --foreign  src/Makefile
Makefile.in:	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
Makefile.in:	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
Makefile.in:	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
Makefile.in:	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
Makefile.in:config.h: stamp-h1
Makefile.in:	@if test ! -f $@; then \
Makefile.in:	  rm -f stamp-h1; \
Makefile.in:	  $(MAKE) stamp-h1; \
Makefile.in:stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
Makefile.in:	@rm -f stamp-h1
Makefile.in:	rm -f stamp-h1
Makefile.in:distclean-hdr:
Makefile.in:	-rm -f config.h stamp-h1
Makefile.in:install-binPROGRAMS: $(bin_PROGRAMS)
Makefile.in:	test -z "$(bindir)" || $(mkdir_p) "$(DESTDIR)$(bindir)"
Makefile.in:	  if test -f $$p \
Makefile.in:uninstall-binPROGRAMS:
Makefile.in:	  echo " rm -f '$(DESTDIR)$(bindir)/$$f'"; \
Makefile.in:	  rm -f "$(DESTDIR)$(bindir)/$$f"; \
Makefile.in:clean-binPROGRAMS:
Makefile.in:	-test -z "$(bin_PROGRAMS)" || rm -f $(bin_PROGRAMS)
Makefile.in:	@rm -f jikes$(EXEEXT)
Makefile.in:mostlyclean-compile:
Makefile.in:	-rm -f *.$(OBJEXT)
Makefile.in:distclean-compile:
Makefile.in:	-rm -f *.tab.c
Makefile.in:@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
Makefile.in:@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
Makefile.in:@am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
Makefile.in:@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
Makefile.in:@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
Makefile.in:@am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
Makefile.in:uninstall-info-am:
Makefile.in:install-includeHEADERS: $(include_HEADERS)
Makefile.in:	test -z "$(includedir)" || $(mkdir_p) "$(DESTDIR)$(includedir)"
Makefile.in:	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
Makefile.in:	  f="`echo $$p | sed -e 's|^.*/||'`"; \
Makefile.in:uninstall-includeHEADERS:
Makefile.in:	  f="`echo $$p | sed -e 's|^.*/||'`"; \
Makefile.in:	  echo " rm -f '$(DESTDIR)$(includedir)/$$f'"; \
Makefile.in:	  rm -f "$(DESTDIR)$(includedir)/$$f"; \
Makefile.in:	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
Makefile.in:	mkid -fID $$unique
Makefile.in:	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
Makefile.in:	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
Makefile.in:	  test -z "$$unique" && unique=$$empty_fix; \
Makefile.in:	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
Makefile.in:	test -z "$(CTAGS_ARGS)$$tags$$unique" \
Makefile.in:	  && gtags -i $(GTAGS_ARGS) $$here
Makefile.in:distclean-tags:
Makefile.in:	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
Makefile.in:	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
Makefile.in:	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
Makefile.in:	  if test -d $$d/$$file; then \
Makefile.in:	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
Makefile.in:	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
Makefile.in:	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
Makefile.in:	    test -f $(distdir)/$$file \
Makefile.in:	    || cp -p $$d/$$file $(distdir)/$$file \
Makefile.in:check-am: all-am
Makefile.in:	$(MAKE) $(AM_MAKEFLAGS) check-am
Makefile.in:all-am: Makefile $(PROGRAMS) $(HEADERS) config.h
Makefile.in:	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
Makefile.in:	$(MAKE) $(AM_MAKEFLAGS) install-am
Makefile.in:install-exec: install-exec-am
Makefile.in:install-data: install-data-am
Makefile.in:uninstall: uninstall-am
Makefile.in:install-am: all-am
Makefile.in:	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
Makefile.in:installcheck: installcheck-am
Makefile.in:install-strip:
Makefile.in:	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
Makefile.in:	  `test -z '$(STRIP)' || \
Makefile.in:mostlyclean-generic:
Makefile.in:clean-generic:
Makefile.in:distclean-generic:
Makefile.in:	-rm -f $(CONFIG_CLEAN_FILES)
Makefile.in:maintainer-clean-generic:
Makefile.in:	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
Makefile.in:clean: clean-am
Makefile.in:clean-am: clean-binPROGRAMS clean-generic mostlyclean-am
Makefile.in:distclean: distclean-am
Makefile.in:	-rm -rf ./$(DEPDIR)
Makefile.in:	-rm -f Makefile
Makefile.in:distclean-am: clean-am distclean-compile distclean-generic \
Makefile.in:	distclean-hdr distclean-tags
Makefile.in:dvi: dvi-am
Makefile.in:dvi-am:
Makefile.in:html: html-am
Makefile.in:info: info-am
Makefile.in:info-am:
Makefile.in:install-data-am: install-includeHEADERS
Makefile.in:install-exec-am: install-binPROGRAMS
Makefile.in:install-info: install-info-am
Makefile.in:install-man:
Makefile.in:installcheck-am:
Makefile.in:maintainer-clean: maintainer-clean-am
Makefile.in:	-rm -rf ./$(DEPDIR)
Makefile.in:	-rm -f Makefile
Makefile.in:maintainer-clean-am: distclean-am maintainer-clean-generic
Makefile.in:mostlyclean: mostlyclean-am
Makefile.in:mostlyclean-am: mostlyclean-compile mostlyclean-generic
Makefile.in:pdf: pdf-am
Makefile.in:pdf-am:
Makefile.in:ps: ps-am
Makefile.in:ps-am:
Makefile.in:uninstall-am: uninstall-binPROGRAMS uninstall-includeHEADERS \
Makefile.in:	uninstall-info-am
Makefile.in:.PHONY: CTAGS GTAGS all all-am check check-am clean clean-binPROGRAMS \
Makefile.in:	clean-generic ctags distclean distclean-compile \
Makefile.in:	distclean-generic distclean-hdr distclean-tags distdir dvi \
Makefile.in:	dvi-am html html-am info info-am install install-am \
Makefile.in:	install-binPROGRAMS install-data install-data-am install-exec \
Makefile.in:	install-exec-am install-includeHEADERS install-info \
Makefile.in:	install-info-am install-man install-strip installcheck \
Makefile.in:	installcheck-am installdirs maintainer-clean \
Makefile.in:	maintainer-clean-generic mostlyclean mostlyclean-compile \
Makefile.in:	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
Makefile.in:	uninstall-am uninstall-binPROGRAMS uninstall-includeHEADERS \
Makefile.in:	uninstall-info-am
Makefile.in:@MAINTAINER_MODE_TRUE@	@rm -f javaact.tmp
Makefile.in:@MAINTAINER_MODE_TRUE@	rm -f $(srcdir)/java.l
Makefile.in:@MAINTAINER_MODE_TRUE@	@mv -f javaact.tmp $@
Makefile.in:@MAINTAINER_MODE_TRUE@	@if test -f $@; then :; else \
Makefile.in:@MAINTAINER_MODE_TRUE@	  rm -f javaact.stamp; \
Makefile.in:@MAINTAINER_MODE_TRUE@	@rm -f code.tmp
Makefile.in:@MAINTAINER_MODE_TRUE@	$(JAVAC) -d $(srcdir) $<
Makefile.in:@MAINTAINER_MODE_TRUE@	(cd $(srcdir); $(JAVA) -classpath . gencode)
Makefile.in:@MAINTAINER_MODE_TRUE@	@mv -f code.tmp $@
Makefile.in:@MAINTAINER_MODE_TRUE@	@if test -f $@; then :; else \
Makefile.in:@MAINTAINER_MODE_TRUE@	  rm -f code.stamp; \
Makefile.in:	@rm -f jikes$(EXEEXT)
Makefile.in:	$(CXXLINK) -o jikes$(EXEEXT) $(jikes_OBJECTS) -lstdc++ -lefence
access.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
access.h:        return (acc & - acc) == acc;
ast.cpp:        assert(base_size <= pool -> Blksize());
ast.cpp:        base = (T**) pool -> Alloc(sizeof(T*) * base_size);
ast.cpp:               (base_size - old_base_size) * sizeof(T*));
ast.cpp:    assert(Blksize() <= pool -> Blksize());
ast.cpp:    base[k] = (T*) pool -> Alloc(sizeof(T) * Blksize());
ast.cpp:    base[k] -= size;
ast.cpp:    assert(pool -> Blksize() >= 256);
ast.cpp:    base_increment = (Blksize() > pool -> Blksize()
ast.cpp:                      ? Blksize() / pool -> Blksize() : 1) * 2;
ast.cpp:    while (Blksize() >= pool -> Blksize())
ast.cpp:        log_blksize--;
ast.cpp:        top--;
ast.cpp:            // The array is most-likely almost sorted. Therefore,
ast.cpp:            if ((i - lower) < (upper - i))
ast.cpp:                upper = i - 1;
ast.cpp:                histack[top] = i - 1;
ast.cpp:// is a no-op for this constant.
ast.cpp:        if (elt -> value == value)
ast.cpp:        if (elt -> value > value)
ast.cpp:            upper = mid - 1;
ast.cpp:        : symbol -> Kind() == Symbol::TYPE
ast.cpp:        : symbol -> Kind() == Symbol::VARIABLE
ast.cpp:        ? ((VariableSymbol*) symbol) -> Type()
ast.cpp:        : symbol -> Kind() == Symbol::METHOD
ast.cpp:        ? ((MethodSymbol*) symbol) -> Type()
ast.cpp:    AstBlock* clone = ast_pool -> GenBlock();
ast.cpp:    clone -> CloneBlock(ast_pool, this);
ast.cpp:    other_tag = orig -> other_tag;
ast.cpp:    label_opt = orig -> label_opt;
ast.cpp:    nesting_level = orig -> nesting_level;
ast.cpp:    left_brace_token = orig -> left_brace_token;
ast.cpp:    unsigned count = orig -> NumStatements();
ast.cpp:        AddStatement((AstStatement*) orig -> Statement(i) -> Clone(ast_pool));
ast.cpp:    right_brace_token = orig -> right_brace_token;
ast.cpp:    no_braces = orig -> no_braces;
ast.cpp:    AstName* clone = ast_pool -> GenName(identifier_token);
ast.cpp:        clone -> base_opt = (AstName*) base_opt -> Clone(ast_pool);
ast.cpp:        clone -> resolution_opt =
ast.cpp:            (AstExpression*) resolution_opt -> Clone(ast_pool);
ast.cpp:    return ast_pool -> GenPrimitiveType(kind, primitive_kind_token);
ast.cpp:        ast_pool -> GenBrackets(left_bracket_token, right_bracket_token);
ast.cpp:    clone -> dims = dims;
ast.cpp:    return ast_pool -> GenArrayType((AstType*) type -> Clone(ast_pool),
ast.cpp:                                    ((AstBrackets*) brackets ->
ast.cpp:    AstWildcard* clone = ast_pool -> GenWildcard(question_token);
ast.cpp:    clone -> extends_token_opt = extends_token_opt;
ast.cpp:    clone -> super_token_opt = super_token_opt;
ast.cpp:        clone -> bounds_opt = (AstType*) bounds_opt -> Clone(ast_pool);
ast.cpp:    AstTypeArguments* clone = ast_pool -> GenTypeArguments(left_angle_token,
ast.cpp:    clone -> AllocateTypeArguments(NumTypeArguments());
ast.cpp:        clone -> AddTypeArgument((AstType*) TypeArgument(i) ->
ast.cpp:        ast_pool -> GenTypeName((AstName*) name -> Clone(ast_pool));
ast.cpp:        clone -> base_opt = (AstTypeName*) base_opt -> Clone(ast_pool);
ast.cpp:        clone -> type_arguments_opt =
ast.cpp:            (AstTypeArguments*) type_arguments_opt -> Clone(ast_pool);
ast.cpp:    AstMemberValuePair* clone = ast_pool -> GenMemberValuePair();
ast.cpp:    clone -> identifier_token_opt = identifier_token_opt;
ast.cpp:    clone -> member_value = (AstMemberValue*) member_value -> Clone(ast_pool);
ast.cpp:    AstAnnotation* clone = ast_pool -> GenAnnotation();
ast.cpp:    clone -> at_token = at_token;
ast.cpp:    clone -> name = (AstName*) name -> Clone(ast_pool);
ast.cpp:    clone -> AllocateMemberValuePairs(NumMemberValuePairs());
ast.cpp:        clone -> AddMemberValuePair((AstMemberValuePair*)
ast.cpp:                                    MemberValuePair(i) -> Clone(ast_pool));
ast.cpp:    clone -> right_paren_token_opt = right_paren_token_opt;
ast.cpp:    return ast_pool -> GenModifierKeyword(modifier_token);
ast.cpp:    AstModifiers* clone = ast_pool -> GenModifiers();
ast.cpp:    clone -> AllocateModifiers(NumModifiers());
ast.cpp:        if (Modifier(i) -> ModifierKeywordCast())
ast.cpp:            clone -> AddModifier((AstModifierKeyword*)
ast.cpp:                                 Modifier(i) -> Clone(ast_pool));
ast.cpp:        else clone -> AddModifier((AstAnnotation*)
ast.cpp:                                  Modifier(i) -> Clone(ast_pool));
ast.cpp:    clone -> static_token_opt = static_token_opt;
ast.cpp:    AstPackageDeclaration* clone = ast_pool -> GenPackageDeclaration();
ast.cpp:        clone -> modifiers_opt =
ast.cpp:            (AstModifiers*) modifiers_opt -> Clone(ast_pool);
ast.cpp:    clone -> package_token = package_token;
ast.cpp:    clone -> name = (AstName*) name -> Clone(ast_pool);
ast.cpp:    clone -> semicolon_token = semicolon_token;
ast.cpp:    AstImportDeclaration* clone = ast_pool -> GenImportDeclaration();
ast.cpp:    clone -> import_token = import_token;
ast.cpp:    clone -> static_token_opt = static_token_opt;
ast.cpp:    clone -> name = (AstName*) name -> Clone(ast_pool);
ast.cpp:    clone -> star_token_opt = star_token_opt;
ast.cpp:    clone -> semicolon_token = semicolon_token;
ast.cpp:    AstCompilationUnit* clone = ast_pool -> GenCompilationUnit();
ast.cpp:    clone -> other_tag = other_tag;
ast.cpp:        clone -> package_declaration_opt = (AstPackageDeclaration*)
ast.cpp:            package_declaration_opt -> Clone(ast_pool);
ast.cpp:    clone -> AllocateImportDeclarations(NumImportDeclarations());
ast.cpp:        clone -> AddImportDeclaration((AstImportDeclaration*)
ast.cpp:                                      ImportDeclaration(i) -> Clone(ast_pool));
ast.cpp:    clone -> AllocateTypeDeclarations(NumTypeDeclarations());
ast.cpp:        clone -> AddTypeDeclaration((AstDeclaredType*) TypeDeclaration(i) ->
ast.cpp:    return ast_pool -> GenEmptyDeclaration(semicolon_token);
ast.cpp:    AstClassBody* clone = ast_pool -> GenClassBody();
ast.cpp:    clone -> identifier_token = identifier_token;
ast.cpp:    clone -> left_brace_token = left_brace_token;
ast.cpp:    clone -> AllocateClassBodyDeclarations(NumClassBodyDeclarations());
ast.cpp:    clone -> AllocateInstanceVariables(NumInstanceVariables());
ast.cpp:    clone -> AllocateClassVariables(NumClassVariables());
ast.cpp:    clone -> AllocateMethods(NumMethods());
ast.cpp:    clone -> AllocateConstructors(NumConstructors());
ast.cpp:    clone -> AllocateStaticInitializers(NumStaticInitializers());
ast.cpp:    clone -> AllocateInstanceInitializers(NumInstanceInitializers());
ast.cpp:    clone -> AllocateNestedClasses(NumNestedClasses());
ast.cpp:    clone -> AllocateNestedEnums(NumNestedEnums());
ast.cpp:    clone -> AllocateNestedInterfaces(NumNestedInterfaces());
ast.cpp:    clone -> AllocateNestedAnnotations(NumNestedAnnotations());
ast.cpp:    clone -> AllocateEmptyDeclarations(NumEmptyDeclarations());
ast.cpp:        clone -> AddClassBodyDeclaration((AstDeclaredType*)
ast.cpp:                                         ClassBodyDeclaration(i) ->
ast.cpp:    clone -> right_brace_token = right_brace_token;
ast.cpp:    AstFieldDeclaration* field_declaration = member -> FieldDeclarationCast();
ast.cpp:        member -> MethodDeclarationCast();
ast.cpp:        member -> ConstructorDeclarationCast();
ast.cpp:        member -> InitializerDeclarationCast();
ast.cpp:    AstClassDeclaration* class_declaration = member -> ClassDeclarationCast();
ast.cpp:    AstEnumDeclaration* enum_declaration = member -> EnumDeclarationCast();
ast.cpp:        member -> InterfaceDeclarationCast();
ast.cpp:        member -> AnnotationDeclarationCast();
ast.cpp:    class_body_declarations -> Next() = member;
ast.cpp:        if (field_declaration -> StaticFieldCast())
ast.cpp:        if (initializer -> StaticInitializerCast())
ast.cpp:    AstTypeParameter* clone = ast_pool -> GenTypeParameter(identifier_token);
ast.cpp:    clone -> AllocateBounds(NumBounds());
ast.cpp:        clone -> AddBound((AstTypeName*) Bound(i) -> Clone(ast_pool));
ast.cpp:    AstTypeParameters* clone = ast_pool -> GenTypeParameters();
ast.cpp:    clone -> left_angle_token = left_angle_token;
ast.cpp:    clone -> AllocateTypeParameters(NumTypeParameters());
ast.cpp:        clone -> AddTypeParameter((AstTypeParameter*) TypeParameter(i) ->
ast.cpp:    clone -> right_angle_token = right_angle_token;
ast.cpp:    AstClassDeclaration* clone = ast_pool -> GenClassDeclaration();
ast.cpp:        clone -> modifiers_opt =
ast.cpp:            (AstModifiers*) modifiers_opt -> Clone(ast_pool);
ast.cpp:    clone -> class_token = class_token;
ast.cpp:        clone -> type_parameters_opt =
ast.cpp:            (AstTypeParameters*) type_parameters_opt -> Clone(ast_pool);
ast.cpp:        clone -> super_opt = (AstTypeName*) super_opt -> Clone(ast_pool);
ast.cpp:    clone -> AllocateInterfaces(NumInterfaces());
ast.cpp:        clone -> AddInterface((AstTypeName*) Interface(i) -> Clone(ast_pool));
ast.cpp:    clone -> class_body = (AstClassBody*) class_body -> Clone(ast_pool);
ast.cpp:    clone -> class_body -> owner = clone;
ast.cpp:    AstArrayInitializer* clone = ast_pool -> GenArrayInitializer();
ast.cpp:    clone -> left_brace_token = left_brace_token;
ast.cpp:    clone -> AllocateVariableInitializers(NumVariableInitializers());
ast.cpp:        clone -> AddVariableInitializer((AstMemberValue*)
ast.cpp:                                        VariableInitializer(i) ->
ast.cpp:    clone -> right_brace_token = right_brace_token;
ast.cpp:    AstVariableDeclaratorId* clone = ast_pool -> GenVariableDeclaratorId();
ast.cpp:    clone -> identifier_token = identifier_token;
ast.cpp:        clone -> brackets_opt = (AstBrackets*) brackets_opt -> Clone(ast_pool);
ast.cpp:    AstVariableDeclarator* clone = ast_pool -> GenVariableDeclarator();
ast.cpp:    clone -> variable_declarator_name = (AstVariableDeclaratorId*)
ast.cpp:        variable_declarator_name -> Clone(ast_pool);
ast.cpp:        clone -> variable_initializer_opt =
ast.cpp:            variable_initializer_opt -> Clone(ast_pool);
ast.cpp:    AstFieldDeclaration* clone = ast_pool -> GenFieldDeclaration();
ast.cpp:    clone -> other_tag = other_tag;
ast.cpp:        clone -> modifiers_opt =
ast.cpp:            (AstModifiers*) modifiers_opt -> Clone(ast_pool);
ast.cpp:    clone -> type = (AstType*) type -> Clone(ast_pool);
ast.cpp:    clone -> AllocateVariableDeclarators(NumVariableDeclarators());
ast.cpp:        clone -> AddVariableDeclarator((AstVariableDeclarator*)
ast.cpp:                                       VariableDeclarator(i) ->
ast.cpp:    clone -> semicolon_token = semicolon_token;
ast.cpp:    AstFormalParameter* clone = ast_pool -> GenFormalParameter();
ast.cpp:        clone -> modifiers_opt =
ast.cpp:            (AstModifiers*) modifiers_opt -> Clone(ast_pool);
ast.cpp:    clone -> type = (AstType*) type -> Clone(ast_pool);
ast.cpp:    clone -> ellipsis_token_opt = ellipsis_token_opt;
ast.cpp:    clone -> formal_declarator =
ast.cpp:        (AstVariableDeclarator*) formal_declarator -> Clone(ast_pool);
ast.cpp:    AstMethodDeclarator* clone = ast_pool -> GenMethodDeclarator();
ast.cpp:    clone -> identifier_token = identifier_token;
ast.cpp:    clone -> left_parenthesis_token = left_parenthesis_token;
ast.cpp:    clone -> AllocateFormalParameters(NumFormalParameters());
ast.cpp:        clone -> AddFormalParameter((AstFormalParameter*)
ast.cpp:                                    FormalParameter(i) -> Clone(ast_pool));
ast.cpp:    clone -> right_parenthesis_token = right_parenthesis_token;
ast.cpp:        clone -> brackets_opt = (AstBrackets*) brackets_opt -> Clone(ast_pool);
ast.cpp:    AstMethodBody* clone = ast_pool -> GenMethodBody();
ast.cpp:    clone -> CloneBlock(ast_pool, this);
ast.cpp:        clone -> explicit_constructor_opt =
ast.cpp:            (AstStatement*) explicit_constructor_opt -> Clone(ast_pool);
ast.cpp:    AstMethodDeclaration* clone = ast_pool -> GenMethodDeclaration();
ast.cpp:        clone -> modifiers_opt =
ast.cpp:            (AstModifiers*) modifiers_opt -> Clone(ast_pool);
ast.cpp:        clone -> type_parameters_opt =
ast.cpp:            (AstTypeParameters*) type_parameters_opt -> Clone(ast_pool);
ast.cpp:    clone -> type = (AstType*) type -> Clone(ast_pool);
ast.cpp:    clone -> method_declarator =
ast.cpp:        (AstMethodDeclarator*) method_declarator -> Clone(ast_pool);
ast.cpp:    clone -> AllocateThrows(NumThrows());
ast.cpp:        clone -> AddThrow((AstTypeName*) Throw(i) -> Clone(ast_pool));
ast.cpp:        clone -> default_value_opt =
ast.cpp:            (AstMemberValue*) default_value_opt -> Clone(ast_pool);
ast.cpp:        clone -> method_body_opt =
ast.cpp:            (AstMethodBody*) method_body_opt -> Clone(ast_pool);
ast.cpp:    clone -> semicolon_token_opt = semicolon_token_opt;
ast.cpp:    AstInitializerDeclaration* clone = ast_pool -> GenInitializerDeclaration();
ast.cpp:    clone -> other_tag = other_tag;
ast.cpp:        clone -> modifiers_opt =
ast.cpp:            (AstModifiers*) modifiers_opt -> Clone(ast_pool);
ast.cpp:    clone -> block = (AstMethodBody*) block -> Clone(ast_pool);
ast.cpp:    AstArguments* clone = ast_pool -> GenArguments(left_parenthesis_token,
ast.cpp:    clone -> AllocateArguments(NumArguments());
ast.cpp:        clone -> AddArgument((AstExpression*) Argument(i) -> Clone(ast_pool));
ast.cpp:    clone -> AllocateLocalArguments(NumLocalArguments());
ast.cpp:        clone -> AddLocalArgument((AstName*) LocalArgument(i) ->
ast.cpp:    clone -> other_tag = other_tag;
ast.cpp:    AstThisCall* clone = ast_pool -> GenThisCall();
ast.cpp:        clone -> type_arguments_opt =
ast.cpp:            (AstTypeArguments*) type_arguments_opt -> Clone(ast_pool);
ast.cpp:    clone -> this_token = this_token;
ast.cpp:    clone -> arguments = (AstArguments*) arguments -> Clone(ast_pool);
ast.cpp:    clone -> semicolon_token = semicolon_token;
ast.cpp:    AstSuperCall* clone = ast_pool -> GenSuperCall();
ast.cpp:        clone -> base_opt = (AstExpression*) base_opt -> Clone(ast_pool);
ast.cpp:        clone -> type_arguments_opt =
ast.cpp:            (AstTypeArguments*) type_arguments_opt -> Clone(ast_pool);
ast.cpp:    clone -> super_token = super_token;
ast.cpp:    clone -> arguments = (AstArguments*) arguments -> Clone(ast_pool);
ast.cpp:    clone -> semicolon_token = semicolon_token;
ast.cpp:    AstConstructorDeclaration* clone = ast_pool -> GenConstructorDeclaration();
ast.cpp:        clone -> modifiers_opt =
ast.cpp:            (AstModifiers*) modifiers_opt -> Clone(ast_pool);
ast.cpp:        clone -> type_parameters_opt =
ast.cpp:            (AstTypeParameters*) type_parameters_opt -> Clone(ast_pool);
ast.cpp:    clone -> constructor_declarator =
ast.cpp:        (AstMethodDeclarator*) constructor_declarator -> Clone(ast_pool);
ast.cpp:    clone -> AllocateThrows(NumThrows());
ast.cpp:        clone -> AddThrow((AstTypeName*) Throw(i) -> Clone(ast_pool));
ast.cpp:    clone -> constructor_body =
ast.cpp:        (AstMethodBody*) constructor_body -> Clone(ast_pool);
ast.cpp:    AstEnumDeclaration* clone = ast_pool -> GenEnumDeclaration();
ast.cpp:        clone -> modifiers_opt =
ast.cpp:            (AstModifiers*) modifiers_opt -> Clone(ast_pool);
ast.cpp:    clone -> AllocateInterfaces(NumInterfaces());
ast.cpp:        clone -> AddInterface((AstTypeName*) Interface(i) -> Clone(ast_pool));
ast.cpp:    clone -> AllocateEnumConstants(NumEnumConstants());
ast.cpp:        clone -> AddEnumConstant((AstEnumConstant*) EnumConstant(i) ->
ast.cpp:    clone -> class_body = (AstClassBody*) class_body -> Clone(ast_pool);
ast.cpp:    clone -> class_body -> owner = clone;
ast.cpp:    AstEnumConstant* clone = ast_pool -> GenEnumConstant(identifier_token);
ast.cpp:        clone -> modifiers_opt =
ast.cpp:            (AstModifiers*) modifiers_opt -> Clone(ast_pool);
ast.cpp:        clone -> arguments_opt =
ast.cpp:            (AstArguments*) arguments_opt -> Clone(ast_pool);
ast.cpp:        clone -> class_body_opt =
ast.cpp:            (AstClassBody*) class_body_opt -> Clone(ast_pool);
ast.cpp:    AstInterfaceDeclaration* clone = ast_pool -> GenInterfaceDeclaration();
ast.cpp:        clone -> modifiers_opt =
ast.cpp:            (AstModifiers*) modifiers_opt -> Clone(ast_pool);
ast.cpp:    clone -> interface_token = interface_token;
ast.cpp:        clone -> type_parameters_opt =
ast.cpp:            (AstTypeParameters*) type_parameters_opt -> Clone(ast_pool);
ast.cpp:    clone -> AllocateInterfaces(NumInterfaces());
ast.cpp:        clone -> AddInterface((AstTypeName*) Interface(i) -> Clone(ast_pool));
ast.cpp:    clone -> class_body = (AstClassBody*) class_body -> Clone(ast_pool);
ast.cpp:    clone -> class_body -> owner = clone;
ast.cpp:        ast_pool -> GenAnnotationDeclaration(interface_token);
ast.cpp:        clone -> modifiers_opt =
ast.cpp:            (AstModifiers*) modifiers_opt -> Clone(ast_pool);
ast.cpp:    clone -> class_body = (AstClassBody*) class_body -> Clone(ast_pool);
ast.cpp:    clone -> class_body -> owner = clone;
ast.cpp:    AstLocalVariableStatement* clone = ast_pool -> GenLocalVariableStatement();
ast.cpp:        clone -> modifiers_opt =
ast.cpp:            (AstModifiers*) modifiers_opt -> Clone(ast_pool);
ast.cpp:    clone -> type = (AstType*) type -> Clone(ast_pool);
ast.cpp:    clone -> AllocateVariableDeclarators(NumVariableDeclarators());
ast.cpp:        clone -> AddVariableDeclarator((AstVariableDeclarator*)
ast.cpp:                                       VariableDeclarator(i) ->
ast.cpp:    clone -> semicolon_token_opt = semicolon_token_opt;
ast.cpp:    Ast* p = declaration -> Clone(ast_pool);
ast.cpp:    if (p -> ClassDeclarationCast())
ast.cpp:        return ast_pool -> GenLocalClassStatement((AstClassDeclaration*) p);
ast.cpp:    else return ast_pool -> GenLocalClassStatement((AstEnumDeclaration*) p);
ast.cpp:    AstIfStatement* clone = ast_pool -> GenIfStatement();
ast.cpp:    clone -> if_token = if_token;
ast.cpp:    clone -> expression = (AstExpression*) expression -> Clone(ast_pool);
ast.cpp:    clone -> true_statement = (AstBlock*) true_statement -> Clone(ast_pool);
ast.cpp:        clone -> false_statement_opt =
ast.cpp:            (AstBlock*) false_statement_opt -> Clone(ast_pool);
ast.cpp:    return ast_pool -> GenEmptyStatement(semicolon_token);
ast.cpp:    AstExpressionStatement* clone = ast_pool -> GenExpressionStatement();
ast.cpp:    clone -> expression = (AstExpression*) expression -> Clone(ast_pool);
ast.cpp:    clone -> semicolon_token_opt = semicolon_token_opt;
ast.cpp:    AstSwitchLabel* clone = ast_pool -> GenSwitchLabel();
ast.cpp:    clone -> case_token = case_token;
ast.cpp:        clone -> expression_opt =
ast.cpp:            (AstExpression*) expression_opt -> Clone(ast_pool);
ast.cpp:    clone -> colon_token = colon_token;
ast.cpp:    clone -> map_index = map_index;
ast.cpp:    AstSwitchBlockStatement* clone = ast_pool -> GenSwitchBlockStatement();
ast.cpp:    clone -> CloneBlock(ast_pool, this);
ast.cpp:    clone -> AllocateSwitchLabels(NumSwitchLabels());
ast.cpp:        clone -> AddSwitchLabel((AstSwitchLabel*) SwitchLabel(i) ->
ast.cpp:    AstSwitchStatement* clone = ast_pool -> GenSwitchStatement();
ast.cpp:    clone -> switch_token = switch_token;
ast.cpp:    clone -> expression = (AstExpression*) expression -> Clone(ast_pool);
ast.cpp:    clone -> switch_block = (AstBlock*) switch_block -> Clone(ast_pool);
ast.cpp:    clone -> AllocateCases(NumCases());
ast.cpp:        clone -> DefaultCase() = ast_pool -> GenCaseElement(0, 0);
ast.cpp:        *clone -> DefaultCase() = *DefaultCase();
ast.cpp:        CaseElement* elt = ast_pool -> GenCaseElement(0, 0);
ast.cpp:        clone -> AddCase(elt);
ast.cpp:    AstWhileStatement* clone = ast_pool -> GenWhileStatement();
ast.cpp:    clone -> while_token = while_token;
ast.cpp:    clone -> expression = (AstExpression*) expression -> Clone(ast_pool);
ast.cpp:    clone -> statement = (AstBlock*) statement -> Clone(ast_pool);
ast.cpp:    AstDoStatement* clone = ast_pool -> GenDoStatement();
ast.cpp:    clone -> do_token = do_token;
ast.cpp:    clone -> statement = (AstBlock*) statement -> Clone(ast_pool);
ast.cpp:    clone -> while_token = while_token;
ast.cpp:    clone -> expression = (AstExpression*) expression -> Clone(ast_pool);
ast.cpp:    clone -> semicolon_token = semicolon_token;
ast.cpp:    AstForStatement* clone = ast_pool -> GenForStatement();
ast.cpp:    clone -> for_token = for_token;
ast.cpp:    clone -> AllocateForInitStatements(NumForInitStatements());
ast.cpp:        clone -> AddForInitStatement((AstStatement*)
ast.cpp:                                     ForInitStatement(i) -> Clone(ast_pool));
ast.cpp:        clone -> end_expression_opt =
ast.cpp:            (AstExpression*) end_expression_opt -> Clone(ast_pool);
ast.cpp:    clone -> AllocateForUpdateStatements(NumForUpdateStatements());
ast.cpp:        clone -> AddForUpdateStatement((AstExpressionStatement*)
ast.cpp:                                       ForUpdateStatement(i) ->
ast.cpp:    clone -> statement = (AstBlock*) statement -> Clone(ast_pool);
ast.cpp:    AstForeachStatement* clone = ast_pool -> GenForeachStatement();
ast.cpp:    clone -> for_token = for_token;
ast.cpp:    clone -> formal_parameter =
ast.cpp:        (AstFormalParameter*) formal_parameter -> Clone(ast_pool);
ast.cpp:    clone -> expression = (AstExpression*) expression -> Clone(ast_pool);
ast.cpp:    clone -> statement = (AstBlock*) statement -> Clone(ast_pool);
ast.cpp:    AstBreakStatement* clone = ast_pool -> GenBreakStatement();
ast.cpp:    clone -> break_token = break_token;
ast.cpp:    clone -> identifier_token_opt = identifier_token_opt;
ast.cpp:    clone -> semicolon_token = semicolon_token;
ast.cpp:    clone -> nesting_level = nesting_level;
ast.cpp:    AstContinueStatement* clone = ast_pool -> GenContinueStatement();
ast.cpp:    clone -> continue_token = continue_token;
ast.cpp:    clone -> identifier_token_opt = identifier_token_opt;
ast.cpp:    clone -> semicolon_token = semicolon_token;
ast.cpp:    clone -> nesting_level = nesting_level;
ast.cpp:    AstReturnStatement* clone = ast_pool -> GenReturnStatement();
ast.cpp:    clone -> return_token = return_token;
ast.cpp:        clone -> expression_opt =
ast.cpp:            (AstExpression*) expression_opt -> Clone(ast_pool);
ast.cpp:    clone -> semicolon_token = semicolon_token;
ast.cpp:    AstThrowStatement* clone = ast_pool -> GenThrowStatement();
ast.cpp:    clone -> throw_token = throw_token;
ast.cpp:    clone -> expression = (AstExpression*) expression -> Clone(ast_pool);
ast.cpp:    clone -> semicolon_token = semicolon_token;
ast.cpp:    AstSynchronizedStatement* clone = ast_pool -> GenSynchronizedStatement();
ast.cpp:    clone -> synchronized_token = synchronized_token;
ast.cpp:    clone -> expression = (AstExpression*) expression -> Clone(ast_pool);
ast.cpp:    clone -> block = (AstBlock*) block -> Clone(ast_pool);
ast.cpp:    AstAssertStatement* clone = ast_pool -> GenAssertStatement();
ast.cpp:    clone -> assert_token = assert_token;
ast.cpp:    clone -> condition = (AstExpression*) condition -> Clone(ast_pool);
ast.cpp:        clone -> message_opt = (AstExpression*) message_opt -> Clone(ast_pool);
ast.cpp:    clone -> semicolon_token = semicolon_token;
ast.cpp:    AstCatchClause* clone = ast_pool -> GenCatchClause();
ast.cpp:    clone -> catch_token = catch_token;
ast.cpp:    clone -> formal_parameter =
ast.cpp:        (AstFormalParameter*) formal_parameter -> Clone(ast_pool);
ast.cpp:    clone -> block = (AstBlock*) block -> Clone(ast_pool);
ast.cpp:    AstFinallyClause* clone = ast_pool -> GenFinallyClause();
ast.cpp:    clone -> finally_token = finally_token;
ast.cpp:    clone -> block = (AstBlock*) block -> Clone(ast_pool);
ast.cpp:    AstTryStatement* clone = ast_pool -> GenTryStatement();
ast.cpp:    clone -> try_token = try_token;
ast.cpp:    clone -> block = (AstBlock*) block -> Clone(ast_pool);
ast.cpp:    clone -> AllocateCatchClauses(NumCatchClauses());
ast.cpp:        clone -> AddCatchClause((AstCatchClause*) CatchClause(i) ->
ast.cpp:        clone -> finally_clause_opt =
ast.cpp:            (AstFinallyClause*) finally_clause_opt -> Clone(ast_pool);
ast.cpp:    return ast_pool -> GenIntegerLiteral(integer_literal_token);
ast.cpp:    return ast_pool -> GenLongLiteral(long_literal_token);
ast.cpp:    return ast_pool -> GenFloatLiteral(float_literal_token);
ast.cpp:    return ast_pool -> GenDoubleLiteral(double_literal_token);
ast.cpp:    return ast_pool -> GenTrueLiteral(true_literal_token);
ast.cpp:    return ast_pool -> GenFalseLiteral(false_literal_token);
ast.cpp:    return ast_pool -> GenStringLiteral(string_literal_token);
ast.cpp:    return ast_pool -> GenCharacterLiteral(character_literal_token);
ast.cpp:    return ast_pool -> GenNullLiteral(null_token);
ast.cpp:    AstClassLiteral* clone = ast_pool -> GenClassLiteral(class_token);
ast.cpp:    clone -> type = (AstTypeName*) type -> Clone(ast_pool);
ast.cpp:        clone -> resolution_opt =
ast.cpp:            (AstExpression*) resolution_opt -> Clone(ast_pool);
ast.cpp:    AstThisExpression* clone = ast_pool -> GenThisExpression(this_token);
ast.cpp:        clone -> base_opt = (AstTypeName*) base_opt -> Clone(ast_pool);
ast.cpp:        clone -> resolution_opt =
ast.cpp:            (AstExpression*) resolution_opt -> Clone(ast_pool);
ast.cpp:    AstSuperExpression* clone = ast_pool -> GenSuperExpression(super_token);
ast.cpp:        clone -> base_opt = (AstTypeName*) base_opt -> Clone(ast_pool);
ast.cpp:        clone -> resolution_opt =
ast.cpp:            (AstExpression*) resolution_opt -> Clone(ast_pool);
ast.cpp:        ast_pool -> GenParenthesizedExpression();
ast.cpp:    clone -> left_parenthesis_token = left_parenthesis_token;
ast.cpp:    clone -> expression = (AstExpression*) expression -> Clone(ast_pool);
ast.cpp:    clone -> right_parenthesis_token = right_parenthesis_token;
ast.cpp:        ast_pool -> GenClassCreationExpression();
ast.cpp:        clone -> base_opt = (AstExpression*) base_opt -> Clone(ast_pool);
ast.cpp:    clone -> new_token = new_token;
ast.cpp:        clone -> type_arguments_opt =
ast.cpp:            (AstTypeArguments*) type_arguments_opt -> Clone(ast_pool);
ast.cpp:    clone -> class_type = (AstTypeName*) class_type -> Clone(ast_pool);
ast.cpp:    clone -> arguments = (AstArguments*) arguments -> Clone(ast_pool);
ast.cpp:        clone -> class_body_opt =
ast.cpp:            (AstClassBody*) class_body_opt -> Clone(ast_pool);
ast.cpp:        clone -> resolution_opt =
ast.cpp:            (AstClassCreationExpression*) resolution_opt -> Clone(ast_pool);
ast.cpp:    AstDimExpr* clone = ast_pool -> GenDimExpr();
ast.cpp:    clone -> left_bracket_token = left_bracket_token;
ast.cpp:    clone -> expression = (AstExpression*) expression -> Clone(ast_pool);
ast.cpp:    clone -> right_bracket_token = right_bracket_token;
ast.cpp:        ast_pool -> GenArrayCreationExpression();
ast.cpp:    clone -> new_token = new_token;
ast.cpp:    clone -> array_type = (AstType*) array_type -> Clone(ast_pool);
ast.cpp:    clone -> AllocateDimExprs(NumDimExprs());
ast.cpp:        clone -> AddDimExpr((AstDimExpr*) DimExpr(i) -> Clone(ast_pool));
ast.cpp:        clone -> brackets_opt = (AstBrackets*) brackets_opt -> Clone(ast_pool);
ast.cpp:        clone -> array_initializer_opt =
ast.cpp:            (AstArrayInitializer*) array_initializer_opt -> Clone(ast_pool);
ast.cpp:    AstFieldAccess* clone = ast_pool -> GenFieldAccess();
ast.cpp:    clone -> base = (AstExpression*) base -> Clone(ast_pool);
ast.cpp:    clone -> identifier_token = identifier_token;
ast.cpp:        clone -> resolution_opt =
ast.cpp:            (AstExpression*) resolution_opt -> Clone(ast_pool);
ast.cpp:        ast_pool -> GenMethodInvocation(identifier_token);
ast.cpp:        clone -> base_opt = (AstExpression*) base_opt -> Clone(ast_pool);
ast.cpp:        clone -> type_arguments_opt =
ast.cpp:            (AstTypeArguments*) type_arguments_opt -> Clone(ast_pool);
ast.cpp:    clone -> identifier_token = identifier_token;
ast.cpp:    clone -> arguments = (AstArguments*) arguments -> Clone(ast_pool);
ast.cpp:        clone -> resolution_opt =
ast.cpp:            (AstExpression*) resolution_opt -> Clone(ast_pool);
ast.cpp:    AstArrayAccess* clone = ast_pool -> GenArrayAccess();
ast.cpp:    clone -> base = (AstExpression*) base -> Clone(ast_pool);
ast.cpp:    clone -> left_bracket_token = left_bracket_token;
ast.cpp:    clone -> expression = (AstExpression*) expression -> Clone(ast_pool);
ast.cpp:    clone -> right_bracket_token = right_bracket_token;
ast.cpp:        ast_pool -> GenPostUnaryExpression((PostUnaryExpressionTag) other_tag);
ast.cpp:    clone -> expression = (AstExpression*) expression -> Clone(ast_pool);
ast.cpp:    clone -> post_operator_token = post_operator_token;
ast.cpp:        ast_pool -> GenPreUnaryExpression((PreUnaryExpressionTag) other_tag);
ast.cpp:    clone -> pre_operator_token = pre_operator_token;
ast.cpp:    clone -> expression = (AstExpression*) expression -> Clone(ast_pool);
ast.cpp:    AstCastExpression* clone = ast_pool -> GenCastExpression();
ast.cpp:    clone -> left_parenthesis_token = left_parenthesis_token;
ast.cpp:        clone -> type = (AstType*) type -> Clone(ast_pool);
ast.cpp:    clone -> right_parenthesis_token = right_parenthesis_token;
ast.cpp:    clone -> expression = (AstExpression*) expression -> Clone(ast_pool);
ast.cpp:        ast_pool -> GenBinaryExpression((BinaryExpressionTag) other_tag);
ast.cpp:    clone -> left_expression =
ast.cpp:        (AstExpression*) left_expression -> Clone(ast_pool);
ast.cpp:    clone -> binary_operator_token = binary_operator_token;
ast.cpp:    clone -> right_expression =
ast.cpp:        (AstExpression*) right_expression -> Clone(ast_pool);
ast.cpp:    AstInstanceofExpression* clone = ast_pool -> GenInstanceofExpression();
ast.cpp:    clone -> expression = (AstExpression*) expression -> Clone(ast_pool);
ast.cpp:    clone -> instanceof_token = instanceof_token;
ast.cpp:    clone -> type = (AstType*) type -> Clone(ast_pool);
ast.cpp:    AstConditionalExpression* clone = ast_pool -> GenConditionalExpression();
ast.cpp:    clone -> test_expression =
ast.cpp:        (AstExpression*) test_expression -> Clone(ast_pool);
ast.cpp:    clone -> question_token = question_token;
ast.cpp:    clone -> true_expression =
ast.cpp:        (AstExpression*) true_expression -> Clone(ast_pool);
ast.cpp:    clone -> colon_token = colon_token;
ast.cpp:    clone -> false_expression =
ast.cpp:        (AstExpression*) false_expression -> Clone(ast_pool);
ast.cpp:    AstAssignmentExpression* clone = ast_pool ->
ast.cpp:    clone -> left_hand_side =
ast.cpp:        (AstExpression*) left_hand_side -> Clone(ast_pool);
ast.cpp:    clone -> expression = (AstExpression*) expression -> Clone(ast_pool);
ast.cpp:                << block_symbol -> max_variable_index
ast.cpp:                << block_symbol -> helper_variable_index;
ast.cpp:            Coutput << " #" << Statement(i) -> id;
ast.cpp:            Statement(i) -> Print(lex_stream);
ast.cpp:            << (base_opt ? base_opt -> id : 0) << '.'
ast.cpp:        base_opt -> Print(lex_stream);
ast.cpp:            << '#' << type -> id << ' ' << brackets -> id << endl;
ast.cpp:    type -> Print(lex_stream);
ast.cpp:    brackets -> Print(lex_stream);
ast.cpp:                << bounds_opt -> id;
ast.cpp:                << bounds_opt -> id;
ast.cpp:        bounds_opt -> Print(lex_stream);
ast.cpp:        Coutput << " #" << TypeArgument(i) -> id;
ast.cpp:        TypeArgument(i) -> Print(lex_stream);
ast.cpp:            << (base_opt ? base_opt -> id : 0) << ".#" << name -> id << "<#"
ast.cpp:            << (type_arguments_opt ? type_arguments_opt -> id : 0) << '>'
ast.cpp:        base_opt -> Print(lex_stream);
ast.cpp:    name -> Print(lex_stream);
ast.cpp:        type_arguments_opt -> Print(lex_stream);
ast.cpp:            << "=#" << member_value -> id << endl;
ast.cpp:    member_value -> Print(lex_stream);
ast.cpp:    Coutput << '#' << id << " (Annotation):  #" << name -> id << '(';
ast.cpp:        Coutput << " #" << MemberValuePair(i) -> id;
ast.cpp:    name -> Print(lex_stream);
ast.cpp:        MemberValuePair(i) -> Print(lex_stream);
ast.cpp:        Coutput << " #" << Modifier(i) -> id;
ast.cpp:        Modifier(i) -> Print(lex_stream);
ast.cpp:            << (modifiers_opt ? modifiers_opt -> id : 0) << ' '
ast.cpp:            << " #" << name -> id << endl;
ast.cpp:        modifiers_opt -> Print(lex_stream);
ast.cpp:    name -> Print(lex_stream);
ast.cpp:            << " #" << name -> id;
ast.cpp:    name -> Print(lex_stream);
ast.cpp:            << (package_declaration_opt ? package_declaration_opt -> id : 0)
ast.cpp:        Coutput << " #" << ImportDeclaration(i) -> id;
ast.cpp:        Coutput << " #" << TypeDeclaration(i) -> id;
ast.cpp:        package_declaration_opt -> Print(lex_stream);
ast.cpp:        ImportDeclaration(i) -> Print(lex_stream);
ast.cpp:        TypeDeclaration(i) -> Print(lex_stream);
ast.cpp:        Coutput << " #" << ClassBodyDeclaration(i) -> id;
ast.cpp:        ClassBodyDeclaration(i) -> Print(lex_stream);
ast.cpp:        Coutput << " #" << Bound(i) -> id;
ast.cpp:        Bound(i) -> Print(lex_stream);
ast.cpp:        Coutput << " #" << TypeParameter(i) -> id;
ast.cpp:        TypeParameter(i) -> Print(lex_stream);
ast.cpp:            << (modifiers_opt ? modifiers_opt -> id : 0) << ' '
ast.cpp:            << lex_stream.NameString(class_body -> identifier_token) << " #"
ast.cpp:            << (type_parameters_opt ? type_parameters_opt -> id : 0)
ast.cpp:            << " #" << (super_opt ? super_opt -> id : 0) << '(';
ast.cpp:        Coutput << " #" << Interface(i) -> id;
ast.cpp:    Coutput << ") #" << class_body -> id << endl;
ast.cpp:        modifiers_opt -> Print(lex_stream);
ast.cpp:        type_parameters_opt -> Print(lex_stream);
ast.cpp:        super_opt -> Print(lex_stream);
ast.cpp:        Interface(i) -> Print(lex_stream);
ast.cpp:    class_body -> Print(lex_stream);
ast.cpp:        Coutput << " #" << VariableInitializer(i) -> id;
ast.cpp:        VariableInitializer(i) -> Print(lex_stream);
ast.cpp:            << (brackets_opt ? brackets_opt -> id : 0) << endl;
ast.cpp:        brackets_opt -> Print(lex_stream);
ast.cpp:            << variable_declarator_name -> id << " #"
ast.cpp:            << (variable_initializer_opt ? variable_initializer_opt -> id : 0)
ast.cpp:    variable_declarator_name -> Print(lex_stream);
ast.cpp:        variable_initializer_opt -> Print(lex_stream);
ast.cpp:            << (modifiers_opt ? modifiers_opt -> id : 0)
ast.cpp:            << " #" << type -> id << '(';
ast.cpp:        Coutput << " #" << VariableDeclarator(i) -> id;
ast.cpp:        modifiers_opt -> Print(lex_stream);
ast.cpp:    type -> Print(lex_stream);
ast.cpp:        VariableDeclarator(i) -> Print(lex_stream);
ast.cpp:            << (modifiers_opt ? modifiers_opt -> id : 0)
ast.cpp:            << " #" << type -> id << " #" << formal_declarator -> id << endl;
ast.cpp:        modifiers_opt -> Print(lex_stream);
ast.cpp:    type -> Print(lex_stream);
ast.cpp:    formal_declarator -> Print(lex_stream);
ast.cpp:        Coutput << " #" << FormalParameter(i) -> id;
ast.cpp:    Coutput << " ) #" << (brackets_opt ? brackets_opt -> id : 0) << endl;
ast.cpp:        FormalParameter(i) -> Print(lex_stream);
ast.cpp:        brackets_opt -> Print(lex_stream);
ast.cpp:        Coutput << " #" << explicit_constructor_opt -> id << endl;
ast.cpp:        explicit_constructor_opt -> Print(lex_stream);
ast.cpp:            << (modifiers_opt ? modifiers_opt -> id : 0) << " <#"
ast.cpp:            << (type_parameters_opt ? type_parameters_opt -> id : 0)
ast.cpp:            << "> #" << type -> id << " #" << method_declarator -> id
ast.cpp:        Coutput << " #" << Throw(i) -> id;
ast.cpp:            << (default_value_opt ? default_value_opt -> id : 0) << ' '
ast.cpp:            << (method_body_opt ? method_body_opt -> id : 0) << endl;
ast.cpp:        modifiers_opt -> Print(lex_stream);
ast.cpp:        type_parameters_opt -> Print(lex_stream);
ast.cpp:    type -> Print(lex_stream);
ast.cpp:    method_declarator -> Print(lex_stream);
ast.cpp:        Throw(i) -> Print(lex_stream);
ast.cpp:        default_value_opt -> Print(lex_stream);
ast.cpp:        method_body_opt -> Print(lex_stream);
ast.cpp:            << (modifiers_opt ? modifiers_opt -> id : 0)
ast.cpp:            << " #" << block -> id << endl;
ast.cpp:        modifiers_opt -> Print(lex_stream);
ast.cpp:    block -> Print(lex_stream);
ast.cpp:        Coutput << " #" << Argument(i) -> id;
ast.cpp:        Argument(i) -> Print(lex_stream);
ast.cpp:            << (type_arguments_opt ? type_arguments_opt -> id : 0)
ast.cpp:            << lex_stream.NameString(this_token) << " #" << arguments -> id
ast.cpp:        type_arguments_opt -> Print(lex_stream);
ast.cpp:    arguments -> Print(lex_stream);
ast.cpp:            << (base_opt ? base_opt -> id : 0) << ".#"
ast.cpp:            << (type_arguments_opt ? type_arguments_opt -> id : 0)
ast.cpp:            << lex_stream.NameString(super_token) << " #" << arguments -> id
ast.cpp:        base_opt -> Print(lex_stream);
ast.cpp:        type_arguments_opt -> Print(lex_stream);
ast.cpp:    arguments -> Print(lex_stream);
ast.cpp:            << (modifiers_opt ? modifiers_opt -> id : 0) << " <#"
ast.cpp:            << (type_parameters_opt ? type_parameters_opt -> id : 0)
ast.cpp:            << " #" << constructor_declarator -> id << " throws: (";
ast.cpp:        Coutput << " #" << Throw(i) -> id;
ast.cpp:    Coutput << ") #" << constructor_body -> id << endl;
ast.cpp:        modifiers_opt -> Print(lex_stream);
ast.cpp:        type_parameters_opt -> Print(lex_stream);
ast.cpp:    constructor_declarator -> Print(lex_stream);
ast.cpp:        Throw(i) -> Print(lex_stream);
ast.cpp:    constructor_body -> Print(lex_stream);
ast.cpp:            << (modifiers_opt ? modifiers_opt -> id : 0) << ' '
ast.cpp:            << lex_stream.NameString(class_body -> identifier_token) << " (";
ast.cpp:        Coutput << " #" << Interface(i) -> id;
ast.cpp:        Coutput << " #" << EnumConstant(i) -> id;
ast.cpp:    Coutput << "} #" << class_body -> id << endl;
ast.cpp:        modifiers_opt -> Print(lex_stream);
ast.cpp:        Interface(i) -> Print(lex_stream);
ast.cpp:        EnumConstant(i) -> Print(lex_stream);
ast.cpp:    class_body -> Print(lex_stream);
ast.cpp:            << (modifiers_opt ? modifiers_opt -> id : 0) << ' '
ast.cpp:            << (arguments_opt ? arguments_opt -> id : 0) << " #"
ast.cpp:            << (class_body_opt ? class_body_opt -> id : 0) << endl;
ast.cpp:        modifiers_opt -> Print(lex_stream);
ast.cpp:        arguments_opt -> Print(lex_stream);
ast.cpp:        class_body_opt -> Print(lex_stream);
ast.cpp:            << (modifiers_opt ? modifiers_opt -> id : 0) << ' '
ast.cpp:            << lex_stream.NameString(class_body -> identifier_token) << " #"
ast.cpp:            << (type_parameters_opt ? type_parameters_opt -> id : 0) << " (";
ast.cpp:        Coutput << " #" << Interface(i) -> id;
ast.cpp:    Coutput << ") #" << class_body -> id << endl;
ast.cpp:        modifiers_opt -> Print(lex_stream);
ast.cpp:        type_parameters_opt -> Print(lex_stream);
ast.cpp:        Interface(i) -> Print(lex_stream);
ast.cpp:    class_body -> Print(lex_stream);
ast.cpp:            << (modifiers_opt ? modifiers_opt -> id : 0) << " @"
ast.cpp:            << lex_stream.NameString(class_body -> identifier_token) << " #"
ast.cpp:            << class_body -> id << endl;
ast.cpp:        modifiers_opt -> Print(lex_stream);
ast.cpp:    class_body -> Print(lex_stream);
ast.cpp:            << (modifiers_opt ? modifiers_opt -> id : 0)
ast.cpp:            << " #" << type -> id << '(';
ast.cpp:        Coutput << " #" << VariableDeclarator(i) -> id;
ast.cpp:        modifiers_opt -> Print(lex_stream);
ast.cpp:    type -> Print(lex_stream);
ast.cpp:        VariableDeclarator(i) -> Print(lex_stream);
ast.cpp:            << declaration -> id << endl;
ast.cpp:    declaration -> Print(lex_stream);
ast.cpp:            << " ( #" << expression -> id << " ) #" << true_statement -> id;
ast.cpp:        Coutput << " else #" << false_statement_opt -> id;
ast.cpp:    expression -> Print(lex_stream);
ast.cpp:    true_statement -> Print(lex_stream);
ast.cpp:        false_statement_opt -> Print(lex_stream);
ast.cpp:    Coutput << '#' << id << " (ExpressionStatement):  #" << expression -> id
ast.cpp:    expression -> Print(lex_stream);
ast.cpp:            << (expression_opt ? expression_opt -> id : 0) << ':' << endl;
ast.cpp:        expression_opt -> Print(lex_stream);
ast.cpp:        Coutput << " #" << SwitchLabel(i) -> id << ':';
ast.cpp:        SwitchLabel(i) -> Print(lex_stream);
ast.cpp:            << " ( #" << expression -> id << " ) #" << switch_block -> id
ast.cpp:            Coutput << "  block: " << cases[i] -> block_index
ast.cpp:                    << "  label: " << cases[i] -> case_index
ast.cpp:                    << "  value: " << cases[i] -> value << endl;
ast.cpp:    expression -> Print(lex_stream);
ast.cpp:    switch_block -> Print(lex_stream);
ast.cpp:            << " ( #" << expression -> id << " ) #" << statement -> id << endl;
ast.cpp:    expression -> Print(lex_stream);
ast.cpp:    statement -> Print(lex_stream);
ast.cpp:            << " { #" << statement -> id << " } "
ast.cpp:            << " ( #" << expression -> id << " ) #" << endl;
ast.cpp:    statement -> Print(lex_stream);
ast.cpp:    expression -> Print(lex_stream);
ast.cpp:        Coutput << " #" << ForInitStatement(i) -> id;
ast.cpp:    Coutput << "; #" << (end_expression_opt ? end_expression_opt -> id : 0)
ast.cpp:        Coutput << " #" << ForUpdateStatement(i) -> id;
ast.cpp:    Coutput << ") #" << statement -> id << endl;
ast.cpp:        ForInitStatement(i) -> Print(lex_stream);
ast.cpp:        end_expression_opt -> Print(lex_stream);
ast.cpp:        ForUpdateStatement(i) -> Print(lex_stream);
ast.cpp:    statement -> Print(lex_stream);
ast.cpp:            << formal_parameter -> id << ": #" << expression -> id
ast.cpp:            << ") #" << statement -> id << endl;
ast.cpp:    formal_parameter -> Print(lex_stream);
ast.cpp:    expression -> Print(lex_stream);
ast.cpp:    statement -> Print(lex_stream);
ast.cpp:            << " #" << (expression_opt ? expression_opt -> id : 0) << endl;
ast.cpp:        expression_opt -> Print(lex_stream);
ast.cpp:            << " #" << expression -> id << endl;
ast.cpp:    expression -> Print(lex_stream);
ast.cpp:            << " ( #" << expression -> id
ast.cpp:            << " ) #" << block -> id << endl;
ast.cpp:    expression -> Print(lex_stream);
ast.cpp:    block -> Print(lex_stream);
ast.cpp:            << " ( #" << condition -> id;
ast.cpp:        Coutput << " : " << message_opt -> id;
ast.cpp:    condition -> Print(lex_stream);
ast.cpp:        message_opt -> Print(lex_stream);
ast.cpp:            << " #" << formal_parameter -> id
ast.cpp:            << " #" << block -> id << endl;
ast.cpp:    formal_parameter -> Print(lex_stream);
ast.cpp:    block -> Print(lex_stream);
ast.cpp:            << " #" << block -> id << endl;
ast.cpp:    block -> Print(lex_stream);
ast.cpp:            << " #" << block -> id
ast.cpp:        Coutput << " #" << CatchClause(i) -> id;
ast.cpp:            << (finally_clause_opt ? finally_clause_opt -> id : 0) << endl;
ast.cpp:    block -> Print(lex_stream);
ast.cpp:        CatchClause(i) -> Print(lex_stream);
ast.cpp:        finally_clause_opt -> Print(lex_stream);
ast.cpp:    Coutput << '#' << id << " (ClassLiteral):  #" << type -> id << ". "
ast.cpp:    type -> Print(lex_stream);
ast.cpp:        Coutput << '#' << base_opt -> id << ". ";
ast.cpp:        base_opt -> Print(lex_stream);
ast.cpp:        Coutput << '#' << base_opt -> id << ". ";
ast.cpp:        base_opt -> Print(lex_stream);
ast.cpp:            << '#' << expression -> id
ast.cpp:    expression -> Print(lex_stream);
ast.cpp:            << (base_opt ? base_opt -> id : 0) << ' '
ast.cpp:            << (type_arguments_opt ? type_arguments_opt -> id : 0) << " #"
ast.cpp:            << class_type -> id << " #" << arguments -> id << " #"
ast.cpp:            << (class_body_opt ? class_body_opt -> id : 0) << endl;
ast.cpp:        base_opt -> Print(lex_stream);
ast.cpp:        type_arguments_opt -> Print(lex_stream);
ast.cpp:    class_type -> Print(lex_stream);
ast.cpp:    arguments -> Print(lex_stream);
ast.cpp:        class_body_opt -> Print(lex_stream);
ast.cpp:    Coutput << '#' << id << " (DimExpr):  [ #" << expression -> id << " ]"
ast.cpp:    expression -> Print(lex_stream);
ast.cpp:            << " #" << array_type -> id << "dimexpr:( ";
ast.cpp:        Coutput << " #" << DimExpr(i) -> id;
ast.cpp:    Coutput << ") brackets:#" << (brackets_opt ? brackets_opt -> id : 0)
ast.cpp:            << (array_initializer_opt ? array_initializer_opt -> id : 0)
ast.cpp:    array_type -> Print(lex_stream);
ast.cpp:        DimExpr(i) -> Print(lex_stream);
ast.cpp:        brackets_opt -> Print(lex_stream);
ast.cpp:        array_initializer_opt -> Print(lex_stream);
ast.cpp:            << " #" << base -> id << ' '
ast.cpp:    base -> Print(lex_stream);
ast.cpp:            << (base_opt ? base_opt -> id : 0) << ".#"
ast.cpp:            << (type_arguments_opt ? type_arguments_opt -> id : 0) << ' '
ast.cpp:            << " #" << arguments -> id << endl;
ast.cpp:        base_opt -> Print(lex_stream);
ast.cpp:        type_arguments_opt -> Print(lex_stream);
ast.cpp:    arguments -> Print(lex_stream);
ast.cpp:            << '#' << base -> id
ast.cpp:            << " [ #" << expression -> id << " ]" << endl;
ast.cpp:    base -> Print(lex_stream);
ast.cpp:    expression -> Print(lex_stream);
ast.cpp:            << '#' << expression -> id
ast.cpp:    expression -> Print(lex_stream);
ast.cpp:            << " #" << expression -> id << endl;
ast.cpp:    expression -> Print(lex_stream);
ast.cpp:        Coutput << '#' << id << " #" << expression -> id << endl;
ast.cpp:        type -> Print(lex_stream);
ast.cpp:        Coutput << '#' << id << " (Java Semantic Cast to " << Type() -> Name()
ast.cpp:                << "):  #" << expression -> id << endl;
ast.cpp:    expression -> Print(lex_stream);
ast.cpp:            << '#' << left_expression -> id << ' '
ast.cpp:            << " #" << right_expression -> id << endl;
ast.cpp:    left_expression -> Print(lex_stream);
ast.cpp:    right_expression -> Print(lex_stream);
ast.cpp:            << expression -> id << ' '
ast.cpp:            << " #" << type -> id << endl;
ast.cpp:    expression -> Print(lex_stream);
ast.cpp:    type -> Print(lex_stream);
ast.cpp:            << '#' << test_expression -> id
ast.cpp:            << " ? #" << true_expression -> id
ast.cpp:            << " : #" << false_expression -> id << endl;
ast.cpp:    test_expression -> Print(lex_stream);
ast.cpp:    true_expression -> Print(lex_stream);
ast.cpp:    false_expression -> Print(lex_stream);
ast.cpp:            << '#' << left_hand_side -> id << ' '
ast.cpp:            << " #" << expression -> id << endl;
ast.cpp:    left_hand_side -> Print(lex_stream);
ast.cpp:    expression -> Print(lex_stream);
ast.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
ast.h:// each rule consists of a left-hand side nonterminal followed by "-->"
ast.h:// followed by a right-hand side symbol or a sequence enclosed in the pair of
ast.h:// when "Modifiers" is specified in the right-hand side of a rule either no
ast.h://    destruction - simply delete the pool to reclaim the entire tree.
ast.h://    slightly less time-efficient than a straightforward linked list. My
ast.h:    // nodes. The bit-fields allow smaller Ast objects without sacrificing
ast.h:    // type-safety or debug visibility.
ast.h:    // This is a catch-all set of bits free for the use of subclasses.
ast.h:    // by the constructor, thanks to the 0-initialization guaranteed by
ast.h:    // will be zero-initialized except for what the constructor explicitly
ast.h:    // Clones are used for various things, such as pre-evaluating final
ast.h:// This AstArray template class can be used to construct a bounds-checking
ast.h:        --count; // don't count these nodes
ast.h:    virtual TokenIndex LeftToken() { return element -> LeftToken(); }
ast.h:    virtual TokenIndex RightToken() { return element -> RightToken(); }
ast.h:    LiteralValue* value; // The compile-time constant value of the expression.
ast.h:        return block_statements ? block_statements -> Length() : 0;
ast.h:        return defined_variables ? defined_variables -> Length() : 0;
ast.h:        return base_opt ? base_opt -> LeftToken() : identifier_token;
ast.h:// Type --> PrimitiveType
ast.h:// PrimitiveType --> <PrimitiveKind, PrimitiveName>
ast.h:// PrimitiveKind --> BYTE | SHORT | INT | LONG | CHAR | FLOAT | DOUBLE |
ast.h:// PrimitiveName --> byte_token | short_token | int_token | long_token |
ast.h:// ReferenceType --> ClassType
ast.h:// ClassType --> Name
ast.h:// ArrayType --> <ARRAY, ArrayKind, [_token, ]_token>
ast.h:// ArrayKind --> PrimitiveType
ast.h:    inline unsigned NumBrackets() { return brackets -> dims; }
ast.h:    virtual TokenIndex LeftToken() { return type -> LeftToken(); }
ast.h:    virtual TokenIndex RightToken() { return brackets -> right_bracket_token; }
ast.h:    virtual TokenIndex IdentifierToken() { return type -> IdentifierToken(); }
ast.h:        return bounds_opt ? bounds_opt -> RightToken() : question_token;
ast.h:        return type_arguments -> Length();
ast.h:// Represents a type. Occurs in several contexts - imports; supertypes;
ast.h:        return type_arguments_opt -> TypeArgument(i);
ast.h:            ? type_arguments_opt -> NumTypeArguments() : 0;
ast.h:        return base_opt ? base_opt -> LeftToken() : name -> LeftToken();
ast.h:        return type_arguments_opt ? type_arguments_opt -> right_angle_token
ast.h:            :  name -> identifier_token;
ast.h:        return name -> identifier_token;
ast.h:            : member_value -> LeftToken();
ast.h:    virtual TokenIndex RightToken() { return member_value -> RightToken(); }
ast.h:        return member_value_pairs ? member_value_pairs -> Length() : 0;
ast.h:            : name -> identifier_token;
ast.h:    // Allows sorting between static and non-static declarations.
ast.h:        return modifiers -> Length();
ast.h:    virtual TokenIndex LeftToken() { return Modifier(0) -> LeftToken(); }
ast.h:        return Modifier(NumModifiers() - 1) -> RightToken();
ast.h:// in package-info.java by JSR 175.
ast.h:        return modifiers_opt ? modifiers_opt -> LeftToken() : package_token;
ast.h:// ImportDeclaration --> <IMPORT, import_token, Name, *_token_opt, ;_token>
ast.h:        return import_declarations ? import_declarations -> Length() : 0;
ast.h:        return type_declarations ? type_declarations -> Length() : 0;
ast.h:            return package_declaration_opt -> package_token;
ast.h:            return ImportDeclaration(0) -> import_token;
ast.h:            return TypeDeclaration(0) -> LeftToken();
ast.h:            return TypeDeclaration(NumTypeDeclarations() - 1) -> RightToken();
ast.h:            return ImportDeclaration(NumImportDeclarations() - 1) ->
ast.h:            return package_declaration_opt -> semicolon_token;
ast.h:// EmptyDeclaration --> <EMPTY_DECLARATION, ;_token>
ast.h:            ? class_body_declarations -> Length() : 0;
ast.h:        return instance_variables ? instance_variables -> Length() : 0;
ast.h:        return class_variables ? class_variables -> Length() : 0;
ast.h:        return methods ? methods -> Length() : 0;
ast.h:        return constructors ? constructors -> Length() : 0;
ast.h:        return static_initializers ? static_initializers -> Length() : 0;
ast.h:        return instance_initializers ? instance_initializers -> Length() : 0;
ast.h:        return inner_classes ? inner_classes -> Length() : 0;
ast.h:        return inner_enums ? inner_enums -> Length() : 0;
ast.h:        return inner_interfaces ? inner_interfaces -> Length() : 0;
ast.h:        return inner_annotations ? inner_annotations -> Length() : 0;
ast.h:        return empty_declarations ? empty_declarations -> Length() : 0;
ast.h:    inline unsigned NumBounds() { return bounds ? bounds -> Length() : 0; }
ast.h:        return NumBounds() ? Bound(NumBounds() - 1) -> RightToken()
ast.h:        return parameters ? parameters -> Length() : 0;
ast.h:        return interfaces ? interfaces -> Length() : 0;
ast.h:        return modifiers_opt ? modifiers_opt -> LeftToken() : class_token;
ast.h:    virtual TokenIndex RightToken() { return class_body -> right_brace_token; }
ast.h:        return variable_initializers ? variable_initializers -> Length() : 0;
ast.h:// VariableDeclaratorId --> <VARIABLE_DECLARATOR_NAME, identifier_token,
ast.h:        return brackets_opt ? brackets_opt -> dims : 0;
ast.h:        return brackets_opt ? brackets_opt -> right_bracket_token
ast.h:// VariableDeclarator --> <VARIABLE_DECLARATOR, VariableDeclaratorId,
ast.h:        return variable_declarator_name -> LeftToken();
ast.h:            ? variable_initializer_opt -> RightToken()
ast.h:            : variable_declarator_name -> RightToken();
ast.h:// FieldDeclaration --> <FIELD, VariableModifiers, Type, VariableDeclarators,
ast.h:// FieldModifier --> Modifier (PUBLIC, PROTECTED, PRIVATE, FINAL, STATIC,
ast.h:        return variable_declarators ? variable_declarators -> Length() : 0;
ast.h:        return modifiers_opt ? modifiers_opt -> LeftToken()
ast.h:            : type -> LeftToken();
ast.h:// FormalParameter --> <PARAMETER, Type, VariableDeclaratorId>
ast.h:        return modifiers_opt ? modifiers_opt -> LeftToken()
ast.h:            : type -> LeftToken();
ast.h:        return formal_declarator -> RightToken();
ast.h:// MethodDeclarator --> <METHOD_DECLARATOR, identifier_token, (_token,
ast.h:        return formal_parameters ? formal_parameters -> Length() : 0;
ast.h:        return brackets_opt ? brackets_opt -> dims : 0;
ast.h:        return brackets_opt ? brackets_opt -> right_bracket_token
ast.h:    inline unsigned NumThrows() { return throws ? throws -> Length() : 0; }
ast.h:        return modifiers_opt ? modifiers_opt -> LeftToken()
ast.h:            : type_parameters_opt ? type_parameters_opt -> left_angle_token
ast.h:            : type -> LeftToken();
ast.h:        return method_body_opt ? method_body_opt -> right_brace_token
ast.h:        return modifiers_opt ? modifiers_opt -> LeftToken()
ast.h:            : block -> left_brace_token;
ast.h:    virtual TokenIndex RightToken() { return block -> right_brace_token; }
ast.h:        return arguments ? arguments -> Length() : 0;
ast.h:        return shadow_arguments ? shadow_arguments -> Length() : 0;
ast.h:        return type_arguments_opt ? type_arguments_opt -> left_angle_token
ast.h:        return base_opt ? base_opt -> LeftToken()
ast.h:            : type_arguments_opt ? type_arguments_opt -> left_angle_token
ast.h:// ConstructorDeclaration --> <CONSTRUCTOR, ConstructorModifiers,
ast.h:// ConstructorBody --> <METHOD_BODY, {_token,
ast.h:// ConstructorModifier --> Modifier (PUBLIC, PROTECTED or PRIVATE)
ast.h:// ExplicitConstructorInvocation --> ThisCall
ast.h:    inline unsigned NumThrows() { return throws ? throws -> Length() : 0; }
ast.h:        return modifiers_opt ? modifiers_opt -> LeftToken()
ast.h:            : type_parameters_opt ? type_parameters_opt -> left_angle_token
ast.h:            : constructor_declarator -> identifier_token;
ast.h:        return constructor_body -> right_brace_token;
ast.h:        return interfaces ? interfaces -> Length() : 0;
ast.h:        return enum_constants ? enum_constants -> Length() : 0;
ast.h:        return modifiers_opt ? modifiers_opt -> LeftToken() : enum_token;
ast.h:    virtual TokenIndex RightToken() { return class_body -> right_brace_token; }
ast.h:        return modifiers_opt ? modifiers_opt -> LeftToken() : identifier_token;
ast.h:        return class_body_opt ? class_body_opt -> right_brace_token
ast.h:            : arguments_opt ? arguments_opt -> right_parenthesis_token
ast.h:        return interfaces ? interfaces -> Length() : 0;
ast.h:        return modifiers_opt ? modifiers_opt -> LeftToken() : interface_token;
ast.h:    virtual TokenIndex RightToken() { return class_body -> right_brace_token; }
ast.h:        return modifiers_opt ? modifiers_opt -> LeftToken()
ast.h:            : interface_token - 1;
ast.h:    virtual TokenIndex RightToken() { return class_body -> right_brace_token; }
ast.h:        return variable_declarators ? variable_declarators -> Length() : 0;
ast.h:        return modifiers_opt ? modifiers_opt -> LeftToken()
ast.h:            : type -> LeftToken();
ast.h:            : (VariableDeclarator(NumVariableDeclarators() - 1) ->
ast.h:    virtual TokenIndex LeftToken() { return declaration -> LeftToken(); }
ast.h:        return declaration -> class_body -> right_brace_token;
ast.h:        return false_statement_opt ? false_statement_opt -> RightToken()
ast.h:            : true_statement -> RightToken();
ast.h:// EmptyStatement --> <EMPTY_STATEMENT, Label_opt, ;_token>
ast.h:// ExpressionStatement --> <EXPRESSION_STATEMENT, Label_opt, Expression,
ast.h:    virtual TokenIndex LeftToken() { return expression -> LeftToken(); }
ast.h:            : expression -> RightToken();
ast.h:// SwitchBlockStatement --> <SWITCH_BLOCK, SwitchLabels, BlockStatements>
ast.h:        return switch_labels ? switch_labels -> Length() : 0;
ast.h:    virtual TokenIndex LeftToken() { return SwitchLabel(0) -> case_token; }
ast.h:// be a plain-old-data type (POD) for efficient copying.
ast.h:// SwitchStatement --> <SWITCH, Label_opt, switch_token, Expression, {_token,
ast.h:    // default case. Index 1 - size are for the case labels, and get sorted.
ast.h:        return (AstSwitchBlockStatement*) switch_block -> Statement(i);
ast.h:    inline unsigned NumBlocks() { return switch_block -> NumStatements(); }
ast.h:        return switch_block -> right_brace_token;
ast.h:// WhileStatement --> <WHILE, Label_opt, while_token, Expression, Statement>
ast.h:    virtual TokenIndex RightToken() { return statement -> right_brace_token; }
ast.h:// DoStatement --> <DO, Label_opt, do_token, Expression, Statement, ;_token>
ast.h:        return for_init_statements ? for_init_statements -> Length() : 0;
ast.h:        return for_update_statements ? for_update_statements -> Length() : 0;
ast.h:    virtual TokenIndex RightToken() { return statement -> right_brace_token; }
ast.h:    virtual TokenIndex RightToken() { return statement -> right_brace_token; }
ast.h:// BreakStatement --> <BREAK, Label_opt, break_token, identifier_token_opt,
ast.h:// ContinueStatement --> <CONTINUE, Label_opt, continue_token, SimpleName_opt,
ast.h:// ReturnStatement --> <RETURN, Label_opt, return_token, Expression_opt,
ast.h:// ThrowStatement --> <THROW, Label_opt, throw_token, Expression, ;_token>
ast.h:// SynchronizedStatement --> <SYNCHRONIZED_STATEMENT, Label_opt,
ast.h:    virtual TokenIndex RightToken() { return block -> right_brace_token; }
ast.h:// AssertStatement --> <ASSERT, Label_opt, assert_token, Expression, ;_token>
ast.h://                 --> <ASSERT, Label_opt, assert_token, Expression, :_token,
ast.h:// CatchClause --> <CATCH, catch_token, FormalParameter, Block>
ast.h:    virtual TokenIndex RightToken() { return block -> right_brace_token; }
ast.h:// FinallyClause --> <FINALLY, finally_token, Block>
ast.h:    virtual TokenIndex RightToken() { return block -> right_brace_token; }
ast.h:// TryStatement --> <TRY, Label_opt, try-token, Block CatchClauses,
ast.h:        return catch_clauses ? catch_clauses -> Length() : 0;
ast.h:        return finally_clause_opt ? finally_clause_opt -> RightToken()
ast.h:            : CatchClause(NumCatchClauses() - 1) -> RightToken();
ast.h:// LongLiteral --> <LONG_LITERAL, long_literal_token, value>
ast.h:// FloatLiteral --> <FLOAT_LITERAL, Literal, value>
ast.h:// DoubleLiteral --> <DOUBLE_LITERAL, Literal, value>
ast.h:// TrueLiteral --> <TRUE_LITERAL, Literal, value>
ast.h:// FalseLiteral --> <FALSE_LITERAL, Literal, value>
ast.h:// StringLiteral --> <STRING_LITERAL, Literal, value>
ast.h:// CharacterLiteral --> <CHARACTER_LITERAL, literal_token, value>
ast.h:// NullLiteral --> <NULL_EXPRESSION, null_token>
ast.h:    virtual TokenIndex LeftToken() { return type -> LeftToken(); }
ast.h:        return base_opt ? base_opt -> LeftToken() : this_token;
ast.h:        return base_opt ? base_opt -> LeftToken() : super_token;
ast.h:// ParenthesizedExpression --> <PARENTHESIZED_EXPRESSION, (_token, Expression,
ast.h:// base_opt -> generated.
ast.h:        return base_opt ? base_opt -> LeftToken() : new_token;
ast.h:        return class_body_opt ? class_body_opt -> right_brace_token
ast.h:            : arguments -> right_parenthesis_token;
ast.h:// DimExpr --> <DIM, [_token, Expression, ]_token>
ast.h:// ArrayCreationExpression --> <ARRAY_CREATION, new_token, Type, DimExprs,
ast.h:        return dim_exprs ? dim_exprs -> Length() : 0;
ast.h:        return brackets_opt ? brackets_opt -> dims : 0;
ast.h:            ? array_initializer_opt -> right_brace_token
ast.h:            : brackets_opt ? brackets_opt -> right_bracket_token
ast.h:            : DimExpr(NumDimExprs() - 1) -> right_bracket_token;
ast.h:// FieldAccess --> <DOT, Primary, ._token, Identifier>
ast.h:    virtual TokenIndex LeftToken() { return base -> LeftToken(); }
ast.h:// can determine this condition by testing base_opt -> generated.
ast.h:        return base_opt ? base_opt -> LeftToken() : identifier_token;
ast.h:        return arguments -> right_parenthesis_token;
ast.h:// ArrayAccess --> <ARRAY_ACCESS, Base, [_token, Expression, ]_token>
ast.h:    virtual TokenIndex LeftToken() { return base -> LeftToken(); }
ast.h:// UnaryExpression --> PreUnaryExpression
ast.h:// PostUnaryExpression --> <POST_UNARY, PostUnaryTag, Expression, PostOperator>
ast.h:// PostUnaryTag --> PLUSPLUS | MINUSMINUS
ast.h:// PostOperator --> ++_token | --_token
ast.h:    // When the left-hand side of an assignment is a name that refers
ast.h:    // that gives write-permission to that field is recorded here.
ast.h:    virtual TokenIndex LeftToken() { return expression -> LeftToken(); }
ast.h:// PreUnaryExpression -->  <PRE_UNARY, PreUnaryTag, PreOperator, Expression>
ast.h:// PreUnaryTag --> PLUS | MINUS | TWIDDLE | NOT | PLUSPLUS | MINUSMINUS
ast.h:// PreOperator --> +_token | -_token | ~_token | !_token | ++_token | --_token
ast.h:    // When the left-hand side of an assignment is a name that refers
ast.h:    // that gives write-permission to that field is recorded here.
ast.h:    virtual TokenIndex RightToken() { return expression -> RightToken(); }
ast.h:// CastExpression --> <castkind, (_token_opt, Type, )_token_opt, Expression>
ast.h:    virtual TokenIndex RightToken() { return expression -> RightToken(); }
ast.h:// BinaryExpression --> <BINARY, BinaryTag, Expression, BinaryOperator,
ast.h:// BinaryTag --> STAR | SLASH | MOD | PLUS | MINUS | LEFT_SHIFT | RIGHT_SHIFT |
ast.h:// BinaryOperator --> *_token | /_token | %_token | +_token | -_token |
ast.h:    virtual TokenIndex LeftToken() { return left_expression -> LeftToken(); }
ast.h:        return right_expression -> RightToken();
ast.h:    virtual TokenIndex LeftToken() { return expression -> LeftToken(); }
ast.h:    virtual TokenIndex RightToken() { return type -> RightToken(); }
ast.h:// ConditionalExpression --> <CONDITIONAL, Expression, ?_token, Expression,
ast.h:    virtual TokenIndex LeftToken() { return test_expression -> LeftToken(); }
ast.h:        return false_expression -> RightToken();
ast.h:// Assignment --> <ASSIGNMENT, AssignmentTag, LeftHandSide, AssignmentOperator,
ast.h:// AssignmentTag --> EQUAL | STAR_EQUAL | SLASH_EQUAL | MOD_EQUAL |
ast.h:// LeftHandSide --> Name | FieldAccess | ArrayAccess | ParenthesizedExpression
ast.h:// of the operator requires a casting of the value of the left-hand side.
ast.h:// AssignmentOperator --> =_token | *=_token | /=_token | %=_token | +=_token |
ast.h://                        -=_token | <<=_token | >>=_token | >>>=_token |
ast.h:    // When the left-hand side of an assignment is a name that refers
ast.h:    // that gives write-permission to that field is recorded here.
ast.h:    virtual TokenIndex LeftToken() { return left_hand_side -> LeftToken(); }
ast.h:    virtual TokenIndex RightToken() { return expression -> RightToken(); }
ast.h:// zero-initialized.
ast.h:    unsigned base_index; // index of current non-full segment
ast.h:            base_increment = 1U << (log_blksize - 8);
ast.h:            base_increment = 1U << (log_blksize - 10);
ast.h:            base_increment = 1U << (log_blksize - 12);
ast.h:    // to it. The memory will be zero-initialized.
ast.h:        unsigned chunk_size = (n + sizeof(Cell) - 1) / sizeof(Cell);
ast.h:                base[base_index] = base[base_index - 1];
ast.h:                base[base_index - 1] = temp;
ast.h:        p -> block_index = block_index;
ast.h:        p -> case_index = case_index;
ast.h:        p -> generated = true;
ast.h:        p -> no_braces = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:        p -> generated = true;
ast.h:    return class_body && class_body -> semantic_environment;
ast.h:    block_statements -> Next() = statement;
ast.h:        defined_variables = pool -> NewVariableSymbolArray(estimate);
ast.h:    defined_variables -> Next() = variable_symbol;
ast.h:    assert(! argument -> PrimitiveTypeCast());
ast.h:    type_arguments -> Next() = argument;
ast.h:    member_value_pairs -> Next() = pair;
ast.h:    modifiers -> Next() = annotation;
ast.h:    modifiers -> Next() = keyword;
ast.h:    import_declarations -> Next() = import_declaration;
ast.h:    type_declarations -> Next() = type_declaration;
ast.h:    instance_variables -> Next() = field_declaration;
ast.h:    class_variables -> Next() = field_declaration;
ast.h:    methods -> Next() = method_declaration;
ast.h:    constructors -> Next() = constructor_declaration;
ast.h:    static_initializers -> Next() = initializer;
ast.h:    instance_initializers -> Next() = initializer;
ast.h:    inner_classes -> Next() = class_declaration;
ast.h:    inner_enums -> Next() = enum_declaration;
ast.h:    inner_interfaces -> Next() = interface_declaration;
ast.h:    inner_annotations -> Next() = ann;
ast.h:    empty_declarations -> Next() = empty_declaration;
ast.h:    bounds -> Next() = bound;
ast.h:    parameters -> Next() = type;
ast.h:    interfaces -> Next() = interf;
ast.h:    variable_initializers -> Next() = initializer;
ast.h:    variable_declarators -> Next() = variable_declarator;
ast.h:    formal_parameters -> Next() = formal_parameter;
ast.h:    throws -> Next() = exception;
ast.h:    arguments -> Next() = argument;
ast.h:    shadow_arguments -> Next() = argument;
ast.h:    throws -> Next() = exception;
ast.h:    interfaces -> Next() = interf;
ast.h:    constant -> ordinal = enum_constants -> Length();
ast.h:    enum_constants -> Next() = constant;
ast.h:    interfaces -> Next() = interf;
ast.h:    variable_declarators -> Next() = variable_declarator;
ast.h:    switch_labels -> Next() = case_label;
ast.h:    cases = new (pool -> Alloc((estimate + 1) * sizeof(CaseElement*)))
ast.h:    for_init_statements -> Next() = statement;
ast.h:    for_update_statements -> Next() = statement;
ast.h:    catch_clauses -> Next() = catch_clause;
ast.h:    dim_exprs -> Next() = dim_expr;
ast.h:    return pool -> Alloc(size);
ast.h:    return pool -> Alloc(size);
ast.h:    // This bit of code is a compile-time assertion that only Ast* are stuck
ast.h:        array = new (pool -> Alloc(size * sizeof(T))) T[size];
Binary file ast.o matches
body.cpp:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $
body.cpp:    if (block_body -> NumStatements() == 0)
body.cpp:        block_body -> can_complete_normally = block_body -> is_reachable;
body.cpp:        AstStatement* statement = block_body -> Statement(0);
body.cpp:        statement -> is_reachable = block_body -> is_reachable;
body.cpp:            (AstStatement*) (statement -> is_reachable ? NULL : statement);
body.cpp:        for (unsigned i = 1; i < block_body -> NumStatements(); i++)
body.cpp:            statement = block_body -> Statement(i);
body.cpp:            statement -> is_reachable =
body.cpp:                previous_statement -> can_complete_normally;
body.cpp:            if (! statement -> is_reachable &&
body.cpp:        if (statement -> can_complete_normally)
body.cpp:            block_body -> can_complete_normally = true;
body.cpp:            LocalBlockStack().TopBlock() -> is_reachable)
body.cpp:                               first_unreachable_statement -> LeftToken(),
body.cpp:                               statement -> RightToken());
body.cpp:        BlockSymbol* block = block_body -> block_symbol;
body.cpp:        if (block -> max_variable_index <
body.cpp:            block -> max_variable_index =
body.cpp:    int table_size = block_body -> NumStatements() + 3;
body.cpp:        LocalSymbolTable().Top() -> InsertBlockSymbol(table_size);
body.cpp:    block -> max_variable_index =
body.cpp:        ? enclosing_block -> block_symbol -> max_variable_index : 1;
body.cpp:    LocalSymbolTable().Push(block -> Table());
body.cpp:    block_body -> block_symbol = block;
body.cpp:    block_body -> nesting_level = LocalBlockStack().Size();
body.cpp:    if (block_body -> label_opt != BAD_TOKEN)
body.cpp:            lex_stream -> NameSymbol(block_body -> label_opt);
body.cpp:                           block_body -> label_opt,
body.cpp:                           name_symbol -> Name());
body.cpp:                LocalSymbolTable().Top() -> InsertLabelSymbol(name_symbol);
body.cpp:            label -> block = block_body;
body.cpp:            label -> nesting_level = block_body -> nesting_level;
body.cpp:                            block -> max_variable_index))
body.cpp:            block -> max_variable_index;
body.cpp:    block -> CompressSpace(); // space optimization
body.cpp:    for (TypeSymbol* type = this_type; type != 0; type = type -> super)
body.cpp:        VariableSymbol* variable = type -> FindVariableSymbol(name_symbol);
body.cpp:        for (unsigned i = 0; variable == 0 && i < type -> NumInterfaces(); ++i)
body.cpp:            variable = type -> Interface(i) -> FindVariableSymbol(name_symbol);
body.cpp:            // Ignore static variables if we're looking for non-static,
body.cpp:            // and non-static if we're looking for static.
body.cpp:            if (variable -> ACC_STATIC() != is_static)
body.cpp:            TypeSymbol* containing_type = variable -> ContainingType();
body.cpp:                           name -> identifier_token,
body.cpp:                           name_symbol -> Name(),
body.cpp:                           containing_type -> ContainingPackageName(),
body.cpp:                           containing_type -> ExternalName());
body.cpp:    ProcessType(local_decl -> type);
body.cpp:    TypeSymbol* field_type = local_decl -> type -> symbol;
body.cpp:    for (unsigned i = 0; i < local_decl -> NumVariableDeclarators(); i++)
body.cpp:            local_decl -> VariableDeclarator(i);
body.cpp:            variable_declarator -> variable_declarator_name;
body.cpp:            lex_stream -> NameSymbol(name -> identifier_token);
body.cpp:                           name -> identifier_token, name_symbol -> Name(),
body.cpp:                           duplicate -> FileLoc());
body.cpp:                                          name, name_symbol, ThisMethod() -> ACC_STATIC());
body.cpp:            if (block -> Tag() == AstBlock::SWITCH)
body.cpp:                block = LocalBlockStack()[LocalBlockStack().Size() - 2];
body.cpp:                table = LocalSymbolTable()[LocalSymbolTable().Size() - 2];
body.cpp:                table -> InsertVariableSymbol(name_symbol);
body.cpp:            variable_declarator -> symbol = symbol;
body.cpp:                field_type -> num_dimensions + name -> NumBrackets();
body.cpp:            symbol -> SetType(field_type -> GetArrayType(this, dims));
body.cpp:            symbol -> SetFlags(access_flags);
body.cpp:            symbol -> SetOwner(ThisMethod());
body.cpp:            symbol -> declarator = variable_declarator;
body.cpp:            symbol -> SetLocation();
body.cpp:            symbol -> SetLocalVariableIndex(block -> block_symbol ->
body.cpp:            if (control.IsDoubleWordType(symbol -> Type()))
body.cpp:                block -> block_symbol -> max_variable_index++;
body.cpp:            if (! symbol -> ACC_FINAL() &&
body.cpp:                name_symbol -> IsBadStyleForVariable())
body.cpp:                               name -> identifier_token, name_symbol -> Name());
body.cpp:            else if (symbol -> ACC_FINAL() &&
body.cpp:                     name_symbol -> IsBadStyleForVariable() &&
body.cpp:                     name_symbol -> IsBadStyleForConstantField())
body.cpp:                               name -> identifier_token, name_symbol -> Name());
body.cpp:    local_decl -> can_complete_normally = local_decl -> is_reachable;
body.cpp:    ProcessExpression(expression_statement -> expression);
body.cpp:    expression_statement -> can_complete_normally =
body.cpp:        expression_statement -> is_reachable;
body.cpp:    ProcessExpressionOrStringConstant(synchronized_statement -> expression);
body.cpp:    synchronized_statement -> block -> is_reachable =
body.cpp:        synchronized_statement -> is_reachable;
body.cpp:    if (synchronized_statement -> expression -> Type() -> Primitive() ||
body.cpp:        synchronized_statement -> expression -> symbol == control.null_type)
body.cpp:                       synchronized_statement -> expression,
body.cpp:                       synchronized_statement -> expression -> Type() -> Name());
body.cpp:    AstBlock* block_body = synchronized_statement -> block;
body.cpp:    // monitor. However, since a try-finally may require up to four slots, we
body.cpp:    // variable declaration; try-finally} within the same enclosing block will
body.cpp:    // TODO: Is it worth optimizing this and try-finally to avoid wasting
body.cpp:    BlockSymbol* enclosing_block_symbol = enclosing_block -> block_symbol;
body.cpp:    if (enclosing_block_symbol -> helper_variable_index < 0)
body.cpp:        enclosing_block_symbol -> helper_variable_index =
body.cpp:            enclosing_block_symbol -> max_variable_index;
body.cpp:        enclosing_block_symbol -> max_variable_index += 2;
body.cpp:        if (ThisMethod() -> Type() != control.void_type)
body.cpp:            if (control.IsDoubleWordType(ThisMethod() -> Type()))
body.cpp:                enclosing_block_symbol -> max_variable_index += 2;
body.cpp:            else enclosing_block_symbol -> max_variable_index += 1;
body.cpp:    BlockSymbol* block = LocalSymbolTable().Top() ->
body.cpp:        InsertBlockSymbol(block_body -> NumStatements() + 3);
body.cpp:    block -> max_variable_index = enclosing_block_symbol -> max_variable_index;
body.cpp:    LocalSymbolTable().Push(block -> Table());
body.cpp:    block_body -> block_symbol = block;
body.cpp:    block_body -> nesting_level = LocalBlockStack().Size();
body.cpp:        block -> max_variable_index)
body.cpp:            block -> max_variable_index;
body.cpp:    synchronized_statement -> can_complete_normally =
body.cpp:        synchronized_statement -> block -> can_complete_normally;
body.cpp:    block -> CompressSpace(); // space optimization
body.cpp:    // we want to allow the same compiler-quitening fix as gcc:
body.cpp:        expression -> AssignmentExpressionCast();
body.cpp:        assignment_expression -> SimpleAssignment() &&
body.cpp:        assignment_expression -> Type() == control.boolean_type)
body.cpp:    ProcessExpression(if_statement -> expression);
body.cpp:    TypeSymbol* cond_type = if_statement -> expression -> Type();
body.cpp:                       if_statement -> expression,
body.cpp:                       cond_type -> ContainingPackageName(),
body.cpp:                       cond_type -> ExternalName());
body.cpp:    CheckForAssignmentUsedAsTruthValue(if_statement -> expression);
body.cpp:    if_statement -> true_statement -> is_reachable =
body.cpp:        if_statement -> is_reachable;
body.cpp:    ProcessBlock(if_statement -> true_statement);
body.cpp:    if (if_statement -> false_statement_opt)
body.cpp:        if_statement -> false_statement_opt -> is_reachable =
body.cpp:            if_statement -> is_reachable;
body.cpp:        ProcessBlock(if_statement -> false_statement_opt);
body.cpp:        if_statement -> can_complete_normally =
body.cpp:            if_statement -> true_statement -> can_complete_normally ||
body.cpp:            if_statement -> false_statement_opt -> can_complete_normally;
body.cpp:    else if_statement -> can_complete_normally = if_statement -> is_reachable;
body.cpp:    AstBlock* enclosed_statement = while_statement -> statement;
body.cpp:    enclosed_statement -> is_reachable = while_statement -> is_reachable;
body.cpp:    ProcessExpression(while_statement -> expression);
body.cpp:    TypeSymbol* cond_type = while_statement -> expression -> Type();
body.cpp:        if (IsConstantFalse(while_statement -> expression))
body.cpp:            if (while_statement -> is_reachable)
body.cpp:                while_statement -> can_complete_normally = true;
body.cpp:            enclosed_statement -> is_reachable = false;
body.cpp:        else if (! IsConstantTrue(while_statement -> expression) &&
body.cpp:                 while_statement -> is_reachable)
body.cpp:            while_statement -> can_complete_normally = true;
body.cpp:                       while_statement -> expression,
body.cpp:                       cond_type -> ContainingPackageName(),
body.cpp:                       cond_type -> ExternalName());
body.cpp:    CheckForAssignmentUsedAsTruthValue(while_statement -> expression);
body.cpp:    if (! enclosed_statement -> is_reachable &&
body.cpp:        while_statement -> is_reachable)
body.cpp:    if (block_body -> can_complete_normally)
body.cpp:        while_statement -> can_complete_normally = true;
body.cpp:    // for-statement whose for-init-statements starts with a local
body.cpp:    for (unsigned i = 0; i < for_statement -> NumForInitStatements(); i++)
body.cpp:        ProcessStatement(for_statement -> ForInitStatement(i));
body.cpp:    AstBlock* enclosed_statement = for_statement -> statement;
body.cpp:    enclosed_statement -> is_reachable = for_statement -> is_reachable;
body.cpp:    if (for_statement -> end_expression_opt)
body.cpp:        ProcessExpression(for_statement -> end_expression_opt);
body.cpp:        TypeSymbol* cond_type = for_statement -> end_expression_opt -> Type();
body.cpp:            if (IsConstantFalse(for_statement -> end_expression_opt))
body.cpp:                if (for_statement -> is_reachable)
body.cpp:                    for_statement -> can_complete_normally = true;
body.cpp:                enclosed_statement -> is_reachable = false;
body.cpp:            else if (! IsConstantTrue(for_statement -> end_expression_opt) &&
body.cpp:                     for_statement -> is_reachable)
body.cpp:                for_statement -> can_complete_normally = true;
body.cpp:                           for_statement -> end_expression_opt,
body.cpp:                           cond_type -> ContainingPackageName(),
body.cpp:                           cond_type -> ExternalName());
body.cpp:    if (! enclosed_statement -> is_reachable &&
body.cpp:        for_statement -> is_reachable)
body.cpp:    for (unsigned j = 0; j < for_statement -> NumForUpdateStatements(); j++)
body.cpp:        ProcessExpressionStatement(for_statement -> ForUpdateStatement(j));
body.cpp:    if (block_body -> can_complete_normally)
body.cpp:        for_statement -> can_complete_normally = true;
body.cpp:    // for-statement whose for-init-statements starts with a local
body.cpp:    BlockSymbol* enclosing_block_symbol = enclosing_block -> block_symbol;
body.cpp:    assert(enclosing_block_symbol -> helper_variable_index < 0);
body.cpp:    AstBlock* enclosed_statement = foreach -> statement;
body.cpp:    enclosed_statement -> is_reachable = foreach -> is_reachable;
body.cpp:    ProcessType(foreach -> formal_parameter -> type);
body.cpp:    assert(! foreach -> formal_parameter -> ellipsis_token_opt);
body.cpp:    TypeSymbol* index_type = foreach -> formal_parameter -> type -> symbol;
body.cpp:        ProcessFormalModifiers(foreach -> formal_parameter);
body.cpp:        foreach -> formal_parameter -> formal_declarator;
body.cpp:        variable_declarator -> variable_declarator_name;
body.cpp:        lex_stream -> NameSymbol(name -> identifier_token);
body.cpp:                       name -> identifier_token, name_symbol -> Name(),
body.cpp:                       duplicate -> FileLoc());
body.cpp:        VariableSymbol* symbol = table -> InsertVariableSymbol(name_symbol);
body.cpp:        variable_declarator -> symbol = symbol;
body.cpp:        unsigned dims = index_type -> num_dimensions + name -> NumBrackets();
body.cpp:        symbol -> SetType(index_type -> GetArrayType(this, dims));
body.cpp:        symbol -> SetFlags(access_flags);
body.cpp:        symbol -> SetOwner(ThisMethod());
body.cpp:        symbol -> declarator = variable_declarator;
body.cpp:        symbol -> SetLocation();
body.cpp:        symbol -> SetLocalVariableIndex(enclosing_block_symbol ->
body.cpp:        if (control.IsDoubleWordType(symbol -> Type()))
body.cpp:            enclosing_block_symbol -> max_variable_index++;
body.cpp:        if (! symbol -> ACC_FINAL() && name_symbol -> IsBadStyleForVariable())
body.cpp:                           name -> identifier_token, name_symbol -> Name());
body.cpp:        else if (symbol -> ACC_FINAL() &&
body.cpp:                 name_symbol -> IsBadStyleForVariable() &&
body.cpp:                 name_symbol -> IsBadStyleForConstantField())
body.cpp:                           name -> identifier_token, name_symbol -> Name());
body.cpp:    ProcessExpression(foreach -> expression);
body.cpp:    TypeSymbol* cond_type = foreach -> expression -> Type();
body.cpp:                       stmt -> RightToken(),
body.cpp:                       foreach -> statement -> LeftToken() - 1);
body.cpp:    else if (cond_type -> IsArray())
body.cpp:        component_type = cond_type -> ArraySubtype();
body.cpp:                           foreach -> expression,
body.cpp:                           component_type -> ContainingPackageName(),
body.cpp:                           component_type -> ExternalName(),
body.cpp:                           index_type -> ContainingPackageName(),
body.cpp:                           index_type -> ExternalName());
body.cpp:        enclosing_block_symbol -> helper_variable_index =
body.cpp:            enclosing_block_symbol -> max_variable_index;
body.cpp:        enclosing_block_symbol -> max_variable_index += 3;
body.cpp:    else if (cond_type -> IsSubtype(control.Iterable()))
body.cpp:            if (index_type -> Primitive())
body.cpp:                           foreach -> expression,
body.cpp:                           component_type -> ContainingPackageName(),
body.cpp:                           component_type -> ExternalName(),
body.cpp:                           index_type -> ContainingPackageName(),
body.cpp:                           index_type -> ExternalName());
body.cpp:        enclosing_block_symbol -> helper_variable_index =
body.cpp:            enclosing_block_symbol -> max_variable_index;
body.cpp:        enclosing_block_symbol -> max_variable_index++;
body.cpp:        ReportSemError(SemanticError::TYPE_NOT_ITERABLE, foreach -> expression,
body.cpp:                       cond_type -> ContainingPackageName(),
body.cpp:                       cond_type -> ExternalName());
body.cpp:    foreach -> can_complete_normally = foreach -> is_reachable;
body.cpp:    AstBlock* block_body = switch_statement -> switch_block;
body.cpp:    BlockSymbol* main_block = LocalSymbolTable().Top() -> InsertBlockSymbol();
body.cpp:    main_block -> max_variable_index =
body.cpp:        enclosing_block -> block_symbol -> max_variable_index;
body.cpp:    LocalSymbolTable().Push(main_block -> Table());
body.cpp:    block_body -> block_symbol = main_block;
body.cpp:    block_body -> nesting_level = LocalBlockStack().Size();
body.cpp:    ProcessExpression(switch_statement -> expression);
body.cpp:    TypeSymbol* type = switch_statement -> expression -> Type();
body.cpp:                       switch_statement -> expression,
body.cpp:                       type -> ContainingPackageName(),
body.cpp:                       type -> ExternalName());
body.cpp:    for (unsigned i = 0; i < block_body -> NumStatements(); i++)
body.cpp:        num_case_labels += switch_statement -> Block(i) -> NumSwitchLabels();
body.cpp:    switch_statement -> AllocateCases(num_case_labels);
body.cpp:    block_body -> is_reachable = switch_statement -> is_reachable;
body.cpp:    for (unsigned j = 0; j < block_body -> NumStatements(); j++)
body.cpp:            switch_statement -> Block(j);
body.cpp:             k < switch_block_statement -> NumSwitchLabels(); k++)
body.cpp:                switch_block_statement -> SwitchLabel(k);
body.cpp:            if (switch_label -> expression_opt)
body.cpp:                ProcessExpression(switch_label -> expression_opt);
body.cpp:                    switch_label -> expression_opt -> Type();
body.cpp:                                   switch_label -> expression_opt,
body.cpp:                                   case_type -> ContainingPackageName(),
body.cpp:                                   case_type -> ExternalName());
body.cpp:                    switch_label -> expression_opt -> symbol = control.no_type;
body.cpp:                else if (! switch_label -> expression_opt -> IsConstant())
body.cpp:                                   switch_label -> expression_opt);
body.cpp:                    switch_label -> expression_opt -> symbol = control.no_type;
body.cpp:                                              switch_label -> expression_opt))
body.cpp:                    switch_label -> expression_opt =
body.cpp:                        ConvertToType(switch_label -> expression_opt, type);
body.cpp:                        compilation_unit -> ast_pool -> GenCaseElement(j, k);
body.cpp:                    switch_statement -> AddCase(case_element);
body.cpp:                    case_element -> value = DYNAMIC_CAST<IntLiteralValue*>
body.cpp:                        (switch_label -> expression_opt -> value) -> value;
body.cpp:                                       (switch_label -> expression_opt ->
body.cpp:                                        value) -> value);
body.cpp:                                   switch_label -> expression_opt,
body.cpp:                                   type -> Name());
body.cpp:            else if (! switch_statement -> DefaultCase())
body.cpp:                switch_statement -> DefaultCase() =
body.cpp:                    compilation_unit -> ast_pool -> GenCaseElement(j, k);
body.cpp:                switch_label -> map_index = num_case_labels - 1;
body.cpp:                               switch_block_statement -> SwitchLabel(k));
body.cpp:        assert(switch_block_statement -> NumStatements() > 0);
body.cpp:            LocalSymbolTable().Top() -> InsertBlockSymbol();
body.cpp:        statement_block -> max_variable_index =
body.cpp:            main_block -> max_variable_index;
body.cpp:        LocalSymbolTable().Push(statement_block -> Table());
body.cpp:        switch_block_statement -> block_symbol = statement_block;
body.cpp:        switch_block_statement -> nesting_level = LocalBlockStack().Size();
body.cpp:        switch_block_statement -> is_reachable =
body.cpp:            switch_statement -> is_reachable;
body.cpp:        if (switch_block_statement -> can_complete_normally &&
body.cpp:            j != block_body -> NumStatements() - 1)
body.cpp:        if (statement_block -> max_variable_index <
body.cpp:            statement_block -> max_variable_index =
body.cpp:            statement_block -> max_variable_index)
body.cpp:                statement_block -> max_variable_index;
body.cpp:        statement_block -> CompressSpace();
body.cpp:    if (block_body -> can_complete_normally ||
body.cpp:        ! switch_statement -> DefaultCase())
body.cpp:        switch_statement -> can_complete_normally = true;
body.cpp:            switch_statement -> Block(block_body -> NumStatements() - 1);
body.cpp:        assert(last_switch_block_statement -> NumStatements() > 0);
body.cpp:        AstStatement* last_statement = last_switch_block_statement ->
body.cpp:            Statement(last_switch_block_statement -> NumStatements() - 1);
body.cpp:        if (last_statement -> can_complete_normally)
body.cpp:            switch_statement -> can_complete_normally = true;
body.cpp:    // the map_index field of each AstCaseLabel (1-based, in order to leave
body.cpp:    if (switch_statement -> NumCases())
body.cpp:        switch_statement -> SortCases();
body.cpp:        CaseElement* first_case = switch_statement -> Case(0);
body.cpp:        switch_statement -> Block(first_case -> block_index) ->
body.cpp:            SwitchLabel(first_case -> case_index) -> map_index = 0;
body.cpp:    for (unsigned k = 1; k < switch_statement -> NumCases(); k++)
body.cpp:        CaseElement* case_elt = switch_statement -> Case(k);
body.cpp:        switch_statement -> Block(case_elt -> block_index) ->
body.cpp:            SwitchLabel(case_elt -> case_index) -> map_index = k;
body.cpp:        if (case_elt -> value == switch_statement -> Case(k - 1) -> value)
body.cpp:            IntToWstring value(case_elt -> value);
body.cpp:                           (switch_statement ->
body.cpp:                            Block(case_elt -> block_index) ->
body.cpp:                            SwitchLabel(case_elt -> case_index) ->
body.cpp:    if (main_block -> max_variable_index <
body.cpp:        main_block -> max_variable_index =
body.cpp:                            main_block -> max_variable_index))
body.cpp:            main_block -> max_variable_index;
body.cpp:    main_block -> CompressSpace(); // space optimization
body.cpp:    AstBlock* enclosed_statement = do_statement -> statement;
body.cpp:    enclosed_statement -> is_reachable = do_statement -> is_reachable;
body.cpp:    ProcessExpression(do_statement -> expression);
body.cpp:    TypeSymbol* type = do_statement -> expression -> Type();
body.cpp:                       do_statement -> expression,
body.cpp:                       type -> ContainingPackageName(),
body.cpp:                       type -> ExternalName());
body.cpp:    CheckForAssignmentUsedAsTruthValue(do_statement -> expression);
body.cpp:    do_statement -> can_complete_normally =
body.cpp:        ((enclosed_statement -> can_complete_normally &&
body.cpp:          ! IsConstantTrue(do_statement -> expression)) ||
body.cpp:         block_body -> can_complete_normally);
body.cpp:    if (break_statement -> identifier_token_opt)
body.cpp:            lex_stream -> NameSymbol(break_statement -> identifier_token_opt);
body.cpp:            break_statement -> nesting_level = label_symbol -> nesting_level;
body.cpp:            AstBlock* block_body = label_symbol -> block;
body.cpp:            if (block_body && break_statement -> is_reachable &&
body.cpp:                AbruptFinallyStack().Top() < block_body -> nesting_level)
body.cpp:                block_body -> can_complete_normally = true;
body.cpp:            break_statement -> nesting_level = block_body -> nesting_level;
body.cpp:                           break_statement -> identifier_token_opt,
body.cpp:                           lex_stream -> NameString(break_statement ->
body.cpp:        break_statement -> nesting_level = block_body -> nesting_level;
body.cpp:            if (break_statement -> is_reachable &&
body.cpp:                AbruptFinallyStack().Top() < block_body -> nesting_level)
body.cpp:                block_body -> can_complete_normally = true;
body.cpp:    else if (continue_statement -> identifier_token_opt)
body.cpp:        NameSymbol* name_symbol = lex_stream ->
body.cpp:            NameSymbol(continue_statement -> identifier_token_opt);
body.cpp:            continue_statement -> nesting_level =
body.cpp:                label_symbol -> nesting_level;
body.cpp:            assert(label_symbol -> block -> NumStatements() > 0);
body.cpp:            loop_statement = label_symbol -> block -> Statement(0);
body.cpp:            continue_statement -> nesting_level = block_body -> nesting_level;
body.cpp:                           continue_statement -> identifier_token_opt,
body.cpp:                           lex_stream -> NameString(continue_statement ->
body.cpp:        loop_statement = block_body -> Statement(0);
body.cpp:        continue_statement -> nesting_level = block_body -> nesting_level;
body.cpp:        AstDoStatement* do_statement = loop_statement -> DoStatementCast();
body.cpp:        AstForStatement* for_statement = loop_statement -> ForStatementCast();
body.cpp:            loop_statement -> WhileStatementCast();
body.cpp:            loop_statement -> ForeachStatementCast();
body.cpp:                                        ? do_statement -> statement
body.cpp:                                        ? for_statement -> statement
body.cpp:                                        ? while_statement -> statement
body.cpp:                                        ? foreach_statement -> statement
body.cpp:                continue_statement -> nesting_level)
body.cpp:                enclosed_statement -> can_complete_normally = true;
body.cpp:            assert(continue_statement -> identifier_token_opt);
body.cpp:                           lex_stream -> NameString(continue_statement ->
body.cpp:    if (this_method -> name_symbol == control.clinit_name_symbol ||
body.cpp:        this_method -> name_symbol == control.block_init_name_symbol)
body.cpp:    else if (return_statement -> expression_opt)
body.cpp:        AstExpression* expression = return_statement -> expression_opt;
body.cpp:        TypeSymbol* method_type = this_method -> Type();
body.cpp:        TypeSymbol* expression_type = expression -> Type();
body.cpp:            this_method -> name_symbol == control.init_name_symbol)
body.cpp:                 method_type -> IsArray())
body.cpp:                    return_statement -> expression_opt =
body.cpp:                                   expression_type -> ContainingPackageName(),
body.cpp:                                   expression_type -> ExternalName(),
body.cpp:                                   method_type -> ContainingPackageName(),
body.cpp:                                   method_type -> ExternalName());
body.cpp:    else if (this_method -> Type() != control.void_type &&
body.cpp:             this_method -> name_symbol != control.init_name_symbol)
body.cpp:            ! exception -> IsSubclass(control.RuntimeException()) &&
body.cpp:            ! exception -> IsSubclass(control.Error()));
body.cpp:    for (int i = TryStatementStack().Size() - 1; i >= 0; i--)
body.cpp:        if (try_statement -> finally_clause_opt &&
body.cpp:            (! try_statement -> finally_clause_opt -> block ->
body.cpp:        if (try_statement -> processing_try_block)
body.cpp:            for (unsigned k = 0; k < try_statement -> NumCatchClauses(); k++)
body.cpp:                AstCatchClause* clause = try_statement -> CatchClause(k);
body.cpp:                VariableSymbol* symbol = clause -> parameter_symbol;
body.cpp:                if (CanAssignmentConvertReference(symbol -> Type(), exception))
body.cpp:        for (int l = this_method -> NumThrows() - 1; l >= 0; l--)
body.cpp:            if (CanAssignmentConvertReference(this_method -> Throws(l),
body.cpp:         this_method -> Identity() == control.block_init_name_symbol) ||
body.cpp:        (ThisVariable() && ! ThisVariable() -> ACC_STATIC()))
body.cpp:            this_type -> FindMethodSymbol(control.init_name_symbol);
body.cpp:        if (! this_type -> Anonymous())
body.cpp:            for ( ; ctor; ctor = ctor -> next_method)
body.cpp:                for (k = ctor -> NumThrows() - 1; k >= 0; k--)
body.cpp:                    if (CanAssignmentConvertReference(ctor -> Throws(k),
body.cpp:            for (k = ctor -> NumThrows() - 1; k >= 0; k--)
body.cpp:                if (CanAssignmentConvertReference(ctor -> Throws(k),
body.cpp:                ctor -> AddThrows(exception);
body.cpp:        if (this_method -> Identity() == control.clinit_name_symbol)
body.cpp:            if (this_method -> Identity() == control.block_init_name_symbol)
body.cpp:                assert(! ThisType() -> Anonymous());
body.cpp:            else if (this_method -> Identity() == control.init_name_symbol)
body.cpp:    else if (ThisType() -> ACC_INTERFACE())
body.cpp:        if (this_variable -> ACC_STATIC())
body.cpp:            assert(! ThisType() -> Anonymous());
body.cpp:    ProcessExpression(throw_statement -> expression);
body.cpp:    TypeSymbol* type = throw_statement -> expression -> Type();
body.cpp:        exception_set -> AddElement(type);
body.cpp:                       throw_statement, type -> ContainingPackageName(),
body.cpp:                       type -> ExternalName(), UncaughtExceptionContext());
body.cpp:    // return address of the jsr.  And if the method has a return type, 1-2
body.cpp:        enclosing_block -> block_symbol -> max_variable_index;
body.cpp:    if (try_statement -> finally_clause_opt)
body.cpp:        BlockSymbol* enclosing_block_symbol = enclosing_block -> block_symbol;
body.cpp:        if (enclosing_block_symbol -> helper_variable_index < 0)
body.cpp:            enclosing_block_symbol -> helper_variable_index =
body.cpp:                enclosing_block_symbol -> max_variable_index;
body.cpp:            enclosing_block_symbol -> max_variable_index += 2;
body.cpp:            if (ThisMethod() -> Type() != control.void_type)
body.cpp:                if (control.IsDoubleWordType(ThisMethod() -> Type()))
body.cpp:                    enclosing_block_symbol -> max_variable_index += 2;
body.cpp:                else enclosing_block_symbol -> max_variable_index++;
body.cpp:        AstBlock* block_body = try_statement -> finally_clause_opt -> block;
body.cpp:        block_body -> is_reachable = try_statement -> is_reachable;
body.cpp:        assert(! try_statement -> can_complete_normally);
body.cpp:        max_variable_index = block_body -> block_symbol -> max_variable_index;
body.cpp:        if (block_body -> NumStatements() == 0)
body.cpp:        if (! block_body -> can_complete_normally)
body.cpp:            AbruptFinallyStack().Push(block_body -> nesting_level);
body.cpp:    // Note that the catch clauses are processed first - prior to processing
body.cpp:    // the main block - so that we can have their parameters available when we
body.cpp:    for (unsigned i = 0; i < try_statement -> NumCatchClauses(); i++)
body.cpp:        AstCatchClause* clause = try_statement -> CatchClause(i);
body.cpp:        AstFormalParameter* parameter = clause -> formal_parameter;
body.cpp:        assert(! parameter -> ellipsis_token_opt);
body.cpp:            parameter -> formal_declarator -> variable_declarator_name;
body.cpp:        ProcessType(parameter -> type);
body.cpp:        TypeSymbol* parm_type = parameter -> type -> symbol;
body.cpp:        if (name -> NumBrackets())
body.cpp:            parm_type = parm_type ->
body.cpp:                GetArrayType(this, (parm_type -> num_dimensions +
body.cpp:                                    name -> NumBrackets()));
body.cpp:        if (! parm_type -> IsSubclass(control.Throwable()) &&
body.cpp:                           parm_type -> ContainingPackageName(),
body.cpp:                           parm_type -> ExternalName());
body.cpp:            lex_stream -> NameSymbol(name -> identifier_token);
body.cpp:                           name -> identifier_token, name_symbol -> Name(),
body.cpp:                           duplicate -> FileLoc());
body.cpp:        AstBlock* block_body = clause -> block;
body.cpp:        if (control.option.pedantic && block_body -> NumStatements() == 0)
body.cpp:        BlockSymbol* block = LocalSymbolTable().Top() ->
body.cpp:            InsertBlockSymbol(block_body -> NumStatements() + 1);
body.cpp:        block -> max_variable_index = max_variable_index;
body.cpp:        LocalSymbolTable().Push(block -> Table());
body.cpp:            LocalSymbolTable().Top() -> InsertVariableSymbol(name_symbol);
body.cpp:        symbol -> SetFlags(access_flags);
body.cpp:        symbol -> SetType(parm_type);
body.cpp:        symbol -> SetOwner(ThisMethod());
body.cpp:        symbol -> SetLocalVariableIndex(block -> max_variable_index++);
body.cpp:        symbol -> MarkComplete();
body.cpp:        symbol -> declarator = parameter -> formal_declarator;
body.cpp:        symbol -> SetLocation();
body.cpp:        parameter -> formal_declarator -> symbol = symbol;
body.cpp:        clause -> parameter_symbol = symbol;
body.cpp:        block_body -> is_reachable = true;
body.cpp:        block_body -> block_symbol = block;
body.cpp:        block_body -> nesting_level = LocalBlockStack().Size();
body.cpp:            block -> max_variable_index)
body.cpp:                block -> max_variable_index;
body.cpp:        if (block_body -> can_complete_normally)
body.cpp:            try_statement -> can_complete_normally = true;
body.cpp:        block -> CompressSpace(); // space optimization
body.cpp:    try_statement -> processing_try_block = true;
body.cpp:    try_statement -> block -> is_reachable = try_statement -> is_reachable;
body.cpp:    AstBlock* block_body = try_statement -> block;
body.cpp:    // declarations in things like for-init, without expensive reallocation.
body.cpp:    BlockSymbol* block = LocalSymbolTable().Top() ->
body.cpp:        InsertBlockSymbol(block_body -> NumStatements() + 3);
body.cpp:    block -> max_variable_index = max_variable_index;
body.cpp:    LocalSymbolTable().Push(block -> Table());
body.cpp:    block_body -> block_symbol = block;
body.cpp:    block_body -> nesting_level = LocalBlockStack().Size();
body.cpp:        block -> max_variable_index)
body.cpp:            block -> max_variable_index;
body.cpp:    block -> CompressSpace(); // space optimization
body.cpp:    if (try_statement -> block -> can_complete_normally)
body.cpp:        try_statement -> can_complete_normally = true;
body.cpp:    exception_set -> AddElement(control.Error());
body.cpp:    exception_set -> AddElement(control.RuntimeException());
body.cpp:    for (unsigned l = 0; l < try_statement -> NumCatchClauses(); l++)
body.cpp:        AstCatchClause* clause = try_statement -> CatchClause(l);
body.cpp:        TypeSymbol* type = clause -> parameter_symbol -> Type();
body.cpp:                 (TypeSymbol*) exception_set -> FirstElement();
body.cpp:             exception = (TypeSymbol*) exception_set -> NextElement())
body.cpp:                           clause -> formal_parameter,
body.cpp:                           type -> ContainingPackageName(),
body.cpp:                           type -> ExternalName());
body.cpp:                previous_clause = try_statement -> CatchClause(k);
body.cpp:                if (type -> IsSubclass(previous_clause -> parameter_symbol ->
body.cpp:                                 (previous_clause -> formal_parameter ->
body.cpp:                    previous_clause -> parameter_symbol -> Type();
body.cpp:                               clause -> formal_parameter,
body.cpp:                               type -> ContainingPackageName(),
body.cpp:                               type -> ExternalName(),
body.cpp:                               prev_type -> ContainingPackageName(),
body.cpp:                               prev_type -> ExternalName(),
body.cpp:            else clause -> block -> is_reachable = true;
body.cpp:    try_statement -> processing_try_block = false;
body.cpp:            exception_set -> RemoveElement(catchable_exceptions[i]);
body.cpp:        TryExceptionTableStack().Top() -> Union(*exception_set);
body.cpp:    if (try_statement -> finally_clause_opt &&
body.cpp:        ! try_statement -> finally_clause_opt -> block -> can_complete_normally)
body.cpp:        try_statement -> can_complete_normally = false;
body.cpp:    ProcessExpression(assert_statement -> condition);
body.cpp:    TypeSymbol* type = assert_statement -> condition -> Type();
body.cpp:                       assert_statement -> condition,
body.cpp:                       type -> ContainingPackageName(),
body.cpp:                       type -> ExternalName());
body.cpp:    // assert variable (creating it if necessary as a side-effect). However,
body.cpp:    else if (! IsConstantTrue(assert_statement -> condition) &&
body.cpp:        assert_statement -> assert_variable =
body.cpp:            ThisType() -> FindOrInsertAssertVariable();
body.cpp:    if (assert_statement -> message_opt)
body.cpp:        ProcessExpressionOrStringConstant(assert_statement -> message_opt);
body.cpp:        if (assert_statement -> message_opt -> Type() == control.void_type)
body.cpp:                           assert_statement -> message_opt,
body.cpp:                           assert_statement -> message_opt -> Type() -> Name());
body.cpp:    assert_statement -> can_complete_normally =
body.cpp:        assert_statement -> is_reachable;
body.cpp:    empty_statement -> can_complete_normally = empty_statement -> is_reachable;
body.cpp:    NameSymbol* name_symbol = lex_stream ->
body.cpp:        NameSymbol(class_declaration -> class_body -> identifier_token);
body.cpp:        LocalSymbolTable().Top() -> InsertTypeSymbol(name_symbol);
body.cpp:    TypeSymbol* outermost_type = this_type -> outermost_type;
body.cpp:    if (! this_type -> local)
body.cpp:        this_type -> local = new SymbolSet;
body.cpp:    IntToWstring value(this_type -> NumLocalTypes() +
body.cpp:                       this_type -> NumAnonymousTypes() + 1);
body.cpp:    int length = this_type -> ExternalNameLength() + 1 + value.Length() +
body.cpp:        name_symbol -> NameLength(); // +1 for $
body.cpp:    wcscpy(external_name, this_type -> ExternalName());
body.cpp:    wcscat(external_name, name_symbol -> Name());
body.cpp:    type -> outermost_type = outermost_type;
body.cpp:    type -> SetExternalIdentity(control.FindOrInsertName(external_name,
body.cpp:    this_type -> local -> AddElement(type);
body.cpp:    AstDeclaredType* class_declaration = class_statement -> declaration;
body.cpp:    AstClassBody* class_body = class_declaration -> class_body;
body.cpp:                               class_body -> identifier_token);
body.cpp:    inner_type -> outermost_type = ThisType() -> outermost_type;
body.cpp:    inner_type -> supertypes_closure = new SymbolSet;
body.cpp:    inner_type -> subtypes_closure = new SymbolSet;
body.cpp:    inner_type -> subtypes = new SymbolSet;
body.cpp:    inner_type -> semantic_environment =
body.cpp:    inner_type -> declaration = class_body;
body.cpp:    inner_type -> file_symbol = source_file_symbol;
body.cpp:    inner_type -> SetFlags(ProcessLocalClassModifiers(class_declaration));
body.cpp:    inner_type -> SetOwner(ThisMethod());
body.cpp:    inner_type -> SetSymbolTable(class_body -> NumClassBodyDeclarations() + 3);
body.cpp:    inner_type -> SetLocation();
body.cpp:    inner_type -> SetSignature(control);
body.cpp:        inner_type -> InsertThis0();
body.cpp:    class_body -> semantic_environment = inner_type -> semantic_environment;
body.cpp:    if (this_call -> type_arguments_opt)
body.cpp:                       this_call -> type_arguments_opt);
body.cpp:    bool bad_argument = ProcessArguments(this_call -> arguments);
body.cpp:                                                    this_call -> this_token,
body.cpp:                                                    this_call -> RightToken());
body.cpp:            this_call -> symbol = constructor;
body.cpp:            MethodInvocationConversion(this_call -> arguments, constructor);
body.cpp:            for (unsigned i = 0; i < constructor -> NumThrows(); i++)
body.cpp:                TypeSymbol* exception = constructor -> Throws(i);
body.cpp:                                   this_call -> this_token,
body.cpp:                                   exception -> ContainingPackageName(),
body.cpp:                                   exception -> ExternalName());
body.cpp:    if (super_call -> symbol)
body.cpp:        assert(this_type -> Anonymous());
body.cpp:    TypeSymbol* super_type = this_type -> super;
body.cpp:                       super_call -> super_token);
body.cpp:    if (super_call -> base_opt)
body.cpp:        ProcessExpression(super_call -> base_opt);
body.cpp:        TypeSymbol* expr_type = super_call -> base_opt -> Type();
body.cpp:            TypeSymbol* containing_type = super_type -> EnclosingType();
body.cpp:            if (expr_type -> Primitive() || expr_type == control.null_type)
body.cpp:                               super_call -> base_opt,
body.cpp:                               expr_type -> ExternalName());
body.cpp:                super_call -> base_opt -> symbol = control.no_type;
body.cpp:                if (! super_type -> Bad())
body.cpp:                                   super_call -> base_opt,
body.cpp:                                   super_type -> ContainingPackageName(),
body.cpp:                                   super_type -> ExternalName(),
body.cpp:                                   this_type -> ContainingPackageName(),
body.cpp:                                   this_type -> ExternalName(),
body.cpp:                                   expr_type -> ContainingPackageName(),
body.cpp:                                   expr_type -> ExternalName());
body.cpp:                super_call -> base_opt -> symbol = control.no_type;
body.cpp:            else if (! expr_type -> IsSubclass(containing_type))
body.cpp:                               super_call -> base_opt,
body.cpp:                               this_type -> ContainingPackageName(),
body.cpp:                               this_type -> ExternalName(),
body.cpp:                               containing_type -> ContainingPackageName(),
body.cpp:                               containing_type -> ExternalName(),
body.cpp:                               expr_type -> ContainingPackageName(),
body.cpp:                               expr_type -> ExternalName());
body.cpp:                super_call -> base_opt -> symbol = control.no_type;
body.cpp:    else // (! super_call -> base_opt)
body.cpp:        if (super_type && super_type -> EnclosingType())
body.cpp:            super_call -> base_opt =
body.cpp:                CreateAccessToType(super_call, super_type -> EnclosingType());
body.cpp:    if (super_call -> type_arguments_opt)
body.cpp:                       super_call -> type_arguments_opt);
body.cpp:    bool bad_argument = ProcessArguments(super_call -> arguments);
body.cpp:                                      super_call -> super_token,
body.cpp:                                      super_call -> RightToken());
body.cpp:        if (constructor -> ACC_PRIVATE())
body.cpp:            constructor = super_type -> GetReadAccessConstructor(constructor);
body.cpp:            super_call -> arguments -> AddNullArgument();
body.cpp:        super_call -> symbol = constructor;
body.cpp:        if (super_call -> base_opt)
body.cpp:            assert(CanAssignmentConvertReference(super_type -> EnclosingType(),
body.cpp:                                                 super_call -> base_opt -> Type()));
body.cpp:            super_call -> base_opt =
body.cpp:                ConvertToType(super_call -> base_opt,
body.cpp:                              super_type -> EnclosingType());
body.cpp:        MethodInvocationConversion(super_call -> arguments, constructor);
body.cpp:        for (i = 0; i < constructor -> NumThrows(); i++)
body.cpp:            TypeSymbol* exception = constructor -> Throws(i);
body.cpp:                               exception -> ContainingPackageName(),
body.cpp:                               exception -> ExternalName(),
body.cpp:                               constructor -> containing_type -> ContainingPackageName(),
body.cpp:                               constructor -> containing_type -> ExternalName());
body.cpp:        if (super_type -> IsLocal())
body.cpp:            unsigned param_count = super_type -> NumConstructorParameters();
body.cpp:            if (super_type -> LocalClassProcessingCompleted() && param_count)
body.cpp:                super_call -> arguments -> AllocateLocalArguments(param_count);
body.cpp:                    AstName* simple_name = compilation_unit ->
body.cpp:                        ast_pool -> GenName(super_call -> super_token);
body.cpp:                        FindLocalVariable(super_type -> ConstructorParameter(i),
body.cpp:                    simple_name -> symbol = accessor;
body.cpp:                    TypeSymbol* owner = accessor -> ContainingType();
body.cpp:                    super_call -> arguments -> AddLocalArgument(simple_name);
body.cpp:                super_type -> AddLocalConstructorCallEnvironment
body.cpp:                    (GetEnvironment(super_call -> arguments));
body.cpp:    TypeSymbol* throw_type = throw_expression -> symbol;
body.cpp:    if (throw_type -> Bad())
body.cpp:    if (throw_type -> ACC_INTERFACE())
body.cpp:                       throw_type -> ContainingPackageName(),
body.cpp:                       throw_type -> ExternalName());
body.cpp:    else if (! throw_type -> IsSubclass(control.Throwable()))
body.cpp:                       throw_type -> ContainingPackageName(),
body.cpp:                       throw_type -> ExternalName());
body.cpp:                           throw_type -> ContainingPackageName(),
body.cpp:                           throw_type -> ExternalName());
body.cpp:            for (unsigned i = 0; i < throws_list -> Length(); i++)
body.cpp:                TypeSymbol* other_type = other_expr -> symbol;
body.cpp:                                   throw_type -> ContainingPackageName(),
body.cpp:                                   throw_type -> ExternalName());
body.cpp:                else if (throw_type -> IsSubclass(other_type))
body.cpp:                                   throw_type -> ContainingPackageName(),
body.cpp:                                   throw_type -> ExternalName(),
body.cpp:                                   other_type -> ContainingPackageName(),
body.cpp:                                   other_type -> ExternalName());
body.cpp:                else if (other_type -> IsSubclass(throw_type))
body.cpp:                                   other_type -> ContainingPackageName(),
body.cpp:                                   other_type -> ExternalName(),
body.cpp:                                   throw_type -> ContainingPackageName(),
body.cpp:                                   throw_type -> ExternalName());
body.cpp:                    int last_index = throws_list -> Length() - 1;
body.cpp:                    throws_list -> Reset(last_index);
body.cpp:                    i--;
body.cpp:                throws_list -> Next() = throw_expression;
body.cpp:    if (method_declaration -> NumThrows())
body.cpp:                (method_declaration -> NumThrows());
body.cpp:        for (unsigned k = 0; k < method_declaration -> NumThrows(); k++)
body.cpp:            CheckThrow(method_declaration -> Throw(k), throws_list);
body.cpp:    if (method_declaration -> method_body_opt)
body.cpp:        AstMethodBody* method_body = method_declaration -> method_body_opt;
body.cpp:        if (method_body -> explicit_constructor_opt)
body.cpp:                           method_body -> explicit_constructor_opt);
body.cpp:        method_body -> block_symbol = this_method -> block_symbol;
body.cpp:        method_body -> nesting_level = LocalBlockStack().Size();
body.cpp:        if (method_body -> can_complete_normally)
body.cpp:            if (this_method -> Type() == control.void_type)
body.cpp:                    compilation_unit -> ast_pool -> GenReturnStatement();
body.cpp:                return_statement -> return_token =
body.cpp:                    method_body -> right_brace_token;
body.cpp:                return_statement -> semicolon_token =
body.cpp:                    method_body -> right_brace_token;
body.cpp:                return_statement -> is_reachable = true;
body.cpp:                method_body -> can_complete_normally = false;
body.cpp:                method_body -> AddStatement(return_statement);
body.cpp:                               method_declaration -> type -> LeftToken(),
body.cpp:                               method_declaration -> method_declarator -> identifier_token,
body.cpp:                               this_method -> Header(),
body.cpp:                               this_method -> Type() -> Name());
body.cpp:        if (this_method -> ACC_ABSTRACT() || this_method -> ACC_NATIVE())
body.cpp:                           method_declaration, this_method -> Header());
body.cpp:    else if (! (this_method -> ACC_ABSTRACT() || this_method -> ACC_NATIVE()))
body.cpp:                       method_declaration, this_method -> Header());
body.cpp:    this_method -> block_symbol -> CompressSpace(); // space optimization
body.cpp:    if (constructor_declaration -> NumThrows())
body.cpp:                (constructor_declaration -> NumThrows());
body.cpp:        for (unsigned k = 0; k < constructor_declaration -> NumThrows(); k++)
body.cpp:            CheckThrow(constructor_declaration -> Throw(k), throws_list);
body.cpp:        constructor_declaration -> constructor_body;
body.cpp:    TypeSymbol* super_type = this_type -> super;
body.cpp:    if (constructor_block -> explicit_constructor_opt)
body.cpp:            constructor_block -> explicit_constructor_opt -> SuperCallCast();
body.cpp:            AstThisCall* this_call = constructor_block ->
body.cpp:                explicit_constructor_opt -> ThisCallCast();
body.cpp:        TokenIndex loc = constructor_block -> LeftToken();
body.cpp:        super_call = compilation_unit -> ast_pool -> GenSuperCall();
body.cpp:        super_call -> super_token = loc;
body.cpp:        super_call -> arguments =
body.cpp:            compilation_unit -> ast_pool -> GenArguments(loc, loc);
body.cpp:        super_call -> semicolon_token = loc;
body.cpp:        constructor_block -> explicit_constructor_opt = super_call;
body.cpp:    int table_size = constructor_block -> NumStatements();
body.cpp:    BlockSymbol* block = LocalSymbolTable().Top() ->
body.cpp:    block -> max_variable_index =
body.cpp:        this_method -> block_symbol -> max_variable_index;
body.cpp:    LocalSymbolTable().Push(block -> Table());
body.cpp:    constructor_block -> block_symbol = block;
body.cpp:    constructor_block -> nesting_level = LocalBlockStack().Size();
body.cpp:    if (constructor_block -> can_complete_normally)
body.cpp:            compilation_unit -> ast_pool -> GenReturnStatement();
body.cpp:        return_statement -> return_token =
body.cpp:            constructor_block -> right_brace_token;
body.cpp:        return_statement -> semicolon_token =
body.cpp:            constructor_block -> right_brace_token;
body.cpp:        return_statement -> is_reachable = true;
body.cpp:        constructor_block -> can_complete_normally = false;
body.cpp:        constructor_block -> AddStatement(return_statement);
body.cpp:    if (this_method -> block_symbol -> max_variable_index <
body.cpp:        block -> max_variable_index)
body.cpp:        this_method -> block_symbol -> max_variable_index =
body.cpp:            block -> max_variable_index;
body.cpp:    block -> CompressSpace(); // space optimization
body.cpp:    if (compilation_unit -> BadCompilationUnitCast())
body.cpp:    state_stack.Push(class_body -> semantic_environment);
body.cpp:    assert(this_type -> HeaderProcessed());
body.cpp:    assert(this_type -> ConstructorMembersProcessed());
body.cpp:    assert(this_type -> MethodMembersProcessed());
body.cpp:    assert(this_type -> FieldMembersProcessed());
body.cpp:    if (! this_type -> ACC_INTERFACE())
body.cpp:        Tuple<VariableSymbol*> unassigned(FinalFields() -> Length());
body.cpp:        for (i = 0; i < FinalFields() -> Length(); i++)
body.cpp:            if (! DefinitelyAssignedVariables() -> da_set[i])
body.cpp:                assert(! variable_symbol -> ACC_STATIC());
body.cpp:        if (class_body -> NumConstructors() == 0)
body.cpp:                               unassigned[i] -> declarator,
body.cpp:                               unassigned[i] -> Name());
body.cpp:            if (class_body -> default_constructor)
body.cpp:                    class_body -> default_constructor -> constructor_symbol;
body.cpp:                LocalSymbolTable().Push(ThisMethod() -> block_symbol ->
body.cpp:                ProcessConstructorBody(class_body -> default_constructor);
body.cpp:                ThisMethod() -> max_block_depth = 1;
body.cpp:            for (i = 0; i < class_body -> NumConstructors(); i++)
body.cpp:                    class_body -> Constructor(i);
body.cpp:                    constructor_decl -> constructor_symbol;
body.cpp:                    constructor_decl -> constructor_body;
body.cpp:                LocalSymbolTable().Push(this_method -> block_symbol ->
body.cpp:                this_method -> max_block_depth = LocalBlockStack().max_size;
body.cpp:                if (constructor_block -> explicit_constructor_opt &&
body.cpp:                    (constructor_block -> explicit_constructor_opt ->
body.cpp:                    DefinitelyAssignedVariables() -> AssignAll();
body.cpp:                        if (! DefinitelyAssignedVariables() ->
body.cpp:                            da_set[variable_symbol -> LocalVariableIndex()])
body.cpp:                                           variable_symbol -> Name());
body.cpp:    DefinitelyAssignedVariables() -> AssignAll();
body.cpp:    BlankFinals() -> SetEmpty();
body.cpp:    for (i = 0; i < class_body -> NumMethods(); i++)
body.cpp:        AstMethodDeclaration* method_decl = class_body -> Method(i);
body.cpp:        ThisMethod() = method_decl -> method_symbol;
body.cpp:            LocalSymbolTable().Push(this_method -> block_symbol -> Table());
body.cpp:            this_method -> max_block_depth = LocalBlockStack().max_size;
body.cpp:    for (i = 0; i < class_body -> NumNestedClasses(); i++)
body.cpp:        AstClassDeclaration* declaration = class_body -> NestedClass(i);
body.cpp:        if (declaration -> class_body -> semantic_environment)
body.cpp:            ProcessExecutableBodies(declaration -> class_body);
body.cpp:    for (i = 0; i < class_body -> NumNestedInterfaces(); i++)
body.cpp:            class_body -> NestedInterface(i);
body.cpp:        if (declaration -> class_body -> semantic_environment)
body.cpp:            ProcessExecutableBodies(declaration -> class_body);
Binary file body.o matches
bytecode.cpp:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $
bytecode.cpp:    AstClassBody* class_body = unit_type -> declaration;
bytecode.cpp:    for (i = 0; i < class_body -> NumClassVariables(); i++)
bytecode.cpp:        AstFieldDeclaration* field_decl = class_body -> ClassVariable(i);
bytecode.cpp:             vi < field_decl -> NumVariableDeclarators(); vi++)
bytecode.cpp:            AstVariableDeclarator* vd = field_decl -> VariableDeclarator(vi);
bytecode.cpp:            DeclareField(vd -> symbol);
bytecode.cpp:        (unit_type -> NumVariableSymbols());
bytecode.cpp:    for (i = 0; i < class_body -> NumInstanceVariables(); i++)
bytecode.cpp:        AstFieldDeclaration* field_decl  = class_body -> InstanceVariable(i);
bytecode.cpp:             vi < field_decl -> NumVariableDeclarators(); vi++)
bytecode.cpp:            AstVariableDeclarator* vd = field_decl -> VariableDeclarator(vi);
bytecode.cpp:            VariableSymbol* vsym = vd -> symbol;
bytecode.cpp:            if (vd -> variable_initializer_opt && vsym -> initial_value)
bytecode.cpp:                assert(init = vd -> variable_initializer_opt ->
bytecode.cpp:                assert(init -> IsConstant() && vd -> symbol -> ACC_FINAL());
bytecode.cpp:    if (unit_type -> EnclosingType())
bytecode.cpp:        DeclareField(unit_type -> EnclosingInstance());
bytecode.cpp:    for (i = 0; i < unit_type -> NumConstructorParameters(); i++)
bytecode.cpp:        DeclareField(unit_type -> ConstructorParameter(i));
bytecode.cpp:    for (i = 0; i < unit_type -> NumClassLiterals(); i++)
bytecode.cpp:        DeclareField(unit_type -> ClassLiteral(i));
bytecode.cpp:    VariableSymbol* assert_variable = unit_type -> AssertVariable();
bytecode.cpp:                                    unit_type -> declaration,
bytecode.cpp:                                    unit_type -> ContainingPackageName(),
bytecode.cpp:                                    unit_type -> ExternalName());
bytecode.cpp:    for (i = 0; i < class_body -> NumMethods(); i++)
bytecode.cpp:        AstMethodDeclaration* method = class_body -> Method(i);
bytecode.cpp:        if (method -> method_symbol)
bytecode.cpp:            BeginMethod(method_index, method -> method_symbol);
bytecode.cpp:            if (method -> method_body_opt) // not an abstract method ?
bytecode.cpp:                EmitBlockStatement(method -> method_body_opt);
bytecode.cpp:            EndMethod(method_index, method -> method_symbol);
bytecode.cpp:    for (i = 0; i < unit_type -> NumPrivateAccessMethods(); i++)
bytecode.cpp:        MethodSymbol* method_sym = unit_type -> PrivateAccessMethod(i);
bytecode.cpp:        AstMethodDeclaration* method = method_sym -> declaration ->
bytecode.cpp:        EmitBlockStatement(method -> method_body_opt);
bytecode.cpp:    MethodSymbol* class_literal_sym = unit_type -> ClassLiteralMethod();
bytecode.cpp:    if (unit_type -> instance_initializer_method)
bytecode.cpp:            unit_type -> instance_initializer_method -> declaration;
bytecode.cpp:        AstBlock* init_block = declaration -> method_body_opt;
bytecode.cpp:                        unit_type -> instance_initializer_method);
bytecode.cpp:            EndMethod(method_index, unit_type -> instance_initializer_method);
bytecode.cpp:    if (class_body -> default_constructor)
bytecode.cpp:        CompileConstructor(class_body -> default_constructor,
bytecode.cpp:        for (i = 0; i < class_body -> NumConstructors(); i++)
bytecode.cpp:            CompileConstructor(class_body -> Constructor(i),
bytecode.cpp:    for (i = 0; i < unit_type -> NumPrivateAccessConstructors(); i++)
bytecode.cpp:            unit_type -> PrivateAccessConstructor(i);
bytecode.cpp:            constructor_sym -> declaration -> ConstructorDeclarationCast();
bytecode.cpp:    if (unit_type -> static_initializer_method)
bytecode.cpp:            unit_type -> static_initializer_method -> declaration;
bytecode.cpp:        AstBlock* init_block = declaration -> method_body_opt;
bytecode.cpp:            BeginMethod(method_index, unit_type -> static_initializer_method);
bytecode.cpp:                GenerateAssertVariableInitializer(unit_type -> outermost_type,
bytecode.cpp:            EndMethod(method_index, unit_type -> static_initializer_method);
bytecode.cpp:                                unit_type -> declaration,
bytecode.cpp:                                unit_type -> ContainingPackageName(),
bytecode.cpp:                                unit_type -> ExternalName());
bytecode.cpp:                                unit_type -> declaration,
bytecode.cpp:                                unit_type -> ContainingPackageName(),
bytecode.cpp:                                unit_type -> ExternalName());
bytecode.cpp:                                unit_type -> declaration,
bytecode.cpp:                                unit_type -> ContainingPackageName(),
bytecode.cpp:                                unit_type -> ExternalName());
bytecode.cpp:                                unit_type -> declaration,
bytecode.cpp:                                unit_type -> ContainingPackageName(),
bytecode.cpp:                                unit_type -> ExternalName());
bytecode.cpp:                                unit_type -> declaration,
bytecode.cpp:                                unit_type -> ContainingPackageName(),
bytecode.cpp:                                unit_type -> ExternalName());
bytecode.cpp:                                unit_type -> declaration,
bytecode.cpp:                                unit_type -> ContainingPackageName(),
bytecode.cpp:                                unit_type -> ExternalName());
bytecode.cpp:    MethodSymbol* method_symbol = constructor -> constructor_symbol;
bytecode.cpp:    AstMethodBody* constructor_block = constructor -> constructor_body;
bytecode.cpp:    shadow_parameter_offset = unit_type -> EnclosingType() ? 2 : 1;
bytecode.cpp:    if (unit_type -> NumConstructorParameters())
bytecode.cpp:        for (unsigned j = 0; j < method_symbol -> NumFormalParameters(); j++)
bytecode.cpp:                GetTypeWords(method_symbol -> FormalParameter(j) -> Type());
bytecode.cpp:        if (constructor_block -> explicit_constructor_opt)
bytecode.cpp:            EmitStatement(constructor_block -> explicit_constructor_opt);
bytecode.cpp:    if (constructor_block -> explicit_constructor_opt &&
bytecode.cpp:        ! constructor_block -> explicit_constructor_opt -> ThisCallCast())
bytecode.cpp:        if (unit_type -> EnclosingType())
bytecode.cpp:            VariableSymbol* this0_parameter = unit_type -> EnclosingInstance();
bytecode.cpp:            LoadLocal(1, this0_parameter -> Type());
bytecode.cpp:             i < unit_type -> NumConstructorParameters(); i++)
bytecode.cpp:            VariableSymbol* shadow = unit_type -> ConstructorParameter(i);
bytecode.cpp:            LoadLocal(index, shadow -> Type());
bytecode.cpp:            if (control.IsDoubleWordType(shadow -> Type()))
bytecode.cpp:                ChangeStack(-1);
bytecode.cpp:            index += GetTypeWords(shadow -> Type());
bytecode.cpp:        if (constructor_block -> explicit_constructor_opt)
bytecode.cpp:            EmitStatement(constructor_block -> explicit_constructor_opt);
bytecode.cpp:        constructor_block -> explicit_constructor_opt &&
bytecode.cpp:        ! constructor_block -> explicit_constructor_opt -> ThisCallCast())
bytecode.cpp:        CompleteCall(unit_type -> instance_initializer_method, 0);
bytecode.cpp:    const TypeSymbol* type = symbol -> Type();
bytecode.cpp:    if (type -> num_dimensions > 255)
bytecode.cpp:                                symbol -> declarator);
bytecode.cpp:    fields[field_index] -> SetFlags(symbol -> Flags());
bytecode.cpp:    fields[field_index] -> SetNameIndex(RegisterName(symbol ->
bytecode.cpp:    fields[field_index] -> SetDescriptorIndex(RegisterUtf8(type -> signature));
bytecode.cpp:    if (symbol -> initial_value)
bytecode.cpp:        assert(symbol -> ACC_FINAL());
bytecode.cpp:        assert(type -> Primitive() || type == control.String());
bytecode.cpp:                                      (symbol -> initial_value))
bytecode.cpp:                                     (symbol -> initial_value))
bytecode.cpp:                                    (symbol -> initial_value))
bytecode.cpp:                                   (symbol -> initial_value))
bytecode.cpp:                                     (symbol -> initial_value)));
bytecode.cpp:        fields[field_index] ->
bytecode.cpp:    if (symbol -> ACC_SYNTHETIC() &&
bytecode.cpp:        fields[field_index] -> AddAttribute(CreateSyntheticAttribute());
bytecode.cpp:    if (symbol -> IsDeprecated())
bytecode.cpp:        fields[field_index] -> AddAttribute(CreateDeprecatedAttribute());
bytecode.cpp:        Coutput << "(51) Generating code for method \"" << msym -> Name()
bytecode.cpp:                << unit_type -> ContainingPackageName() << "/"
bytecode.cpp:                << unit_type -> ExternalName() << endl;
bytecode.cpp:                << unit_type -> ContainingPackageName() << '.'
bytecode.cpp:                << unit_type -> ExternalName() << '.' << msym -> Name()
bytecode.cpp:                << msym -> signature -> value << endl;
bytecode.cpp:    methods[method_index] ->
bytecode.cpp:        SetNameIndex(RegisterName(msym -> ExternalIdentity()));
bytecode.cpp:    methods[method_index] ->
bytecode.cpp:        SetDescriptorIndex(RegisterUtf8(msym -> signature));
bytecode.cpp:    methods[method_index] -> SetFlags(msym -> Flags());
bytecode.cpp:    if (msym -> ACC_SYNTHETIC() &&
bytecode.cpp:        methods[method_index] -> AddAttribute(CreateSyntheticAttribute());
bytecode.cpp:    if (msym -> IsDeprecated())
bytecode.cpp:        methods[method_index] -> AddAttribute(CreateDeprecatedAttribute());
bytecode.cpp:    if (msym -> NumThrows())
bytecode.cpp:        for (unsigned i = 0; i < msym -> NumThrows(); i++)
bytecode.cpp:            exceptions_attribute ->
bytecode.cpp:                AddExceptionIndex(RegisterClass(msym -> Throws(i)));
bytecode.cpp:        methods[method_index] -> AddAttribute(exceptions_attribute);
bytecode.cpp:    if (! (msym -> ACC_ABSTRACT() || msym -> ACC_NATIVE()))
bytecode.cpp:            new MethodStack(msym -> max_block_depth,
bytecode.cpp:                            msym -> block_symbol -> max_variable_index);
bytecode.cpp:                              msym -> block_symbol -> max_variable_index);
bytecode.cpp:    if (msym -> Type() -> num_dimensions > 255)
bytecode.cpp:        assert(msym -> declaration -> MethodDeclarationCast());
bytecode.cpp:        Ast* type = ((AstMethodDeclaration*) msym -> declaration) -> type;
bytecode.cpp:    for (unsigned i = 0; i < msym -> NumFormalParameters(); i++)
bytecode.cpp:        parameter = msym -> FormalParameter(i);
bytecode.cpp:        if (parameter -> Type() -> num_dimensions > 255)
bytecode.cpp:                                    parameter -> declarator);
bytecode.cpp:        int last_parameter_index = parameter -> LocalVariableIndex();
bytecode.cpp:        if (control.IsDoubleWordType(parameter -> Type()))
bytecode.cpp:            assert(msym -> declaration);
bytecode.cpp:                msym -> declaration -> MethodDeclarationCast();
bytecode.cpp:                msym -> declaration -> ConstructorDeclarationCast();
bytecode.cpp:                ? method_declaration -> method_declarator
bytecode.cpp:                : constructor_declaration -> constructor_declarator;
bytecode.cpp:                                    declarator -> left_parenthesis_token,
bytecode.cpp:                                    declarator -> right_parenthesis_token,
bytecode.cpp:                                    msym -> Header(),
bytecode.cpp:                                    unit_type -> ContainingPackageName(),
bytecode.cpp:                                    unit_type -> ExternalName());
bytecode.cpp:    if (! (msym -> ACC_ABSTRACT() || msym -> ACC_NATIVE()))
bytecode.cpp:        if (msym -> block_symbol -> max_variable_index > 65535)
bytecode.cpp:                                    msym -> declaration, msym -> Header(),
bytecode.cpp:                                    unit_type -> ContainingPackageName(),
bytecode.cpp:                                    unit_type -> ExternalName());
bytecode.cpp:                                    msym -> declaration, msym -> Header(),
bytecode.cpp:                                    unit_type -> ContainingPackageName(),
bytecode.cpp:                                    unit_type -> ExternalName());
bytecode.cpp:        if (code_attribute -> CodeLengthExceeded())
bytecode.cpp:                                    msym -> declaration, msym -> Header(),
bytecode.cpp:                                    unit_type -> ContainingPackageName(),
bytecode.cpp:                                    unit_type -> ExternalName());
bytecode.cpp:        code_attribute -> SetMaxStack(max_stack);
bytecode.cpp:        // Sanity check - make sure nothing jumped past here
bytecode.cpp:        assert((u2) last_label_pc < code_attribute -> CodeLength() ||
bytecode.cpp:               code_attribute -> CodeLength() == 0x0ffff);
bytecode.cpp:        // write, and -g:lines is enabled.
bytecode.cpp:            line_number_table_attribute -> LineNumberTableLength())
bytecode.cpp:             code_attribute -> AddAttribute(line_number_table_attribute);
bytecode.cpp:        // Debug level -g:vars & not dealing with generated accessed method
bytecode.cpp:            && (! msym -> accessed_member)
bytecode.cpp:            && (msym -> Identity() != control.class_name_symbol))
bytecode.cpp:            if (! msym -> ACC_STATIC()) // add 'this' to local variable table
bytecode.cpp:                local_variable_table_attribute ->
bytecode.cpp:                    AddLocalVariable(0, code_attribute -> CodeLength(),
bytecode.cpp:                                     RegisterUtf8(control.this_name_symbol -> Utf8_literal),
bytecode.cpp:                                     RegisterUtf8(msym -> containing_type -> signature),
bytecode.cpp:            for (unsigned i = 0; i < msym -> NumFormalParameters(); i++)
bytecode.cpp:                VariableSymbol* parameter = msym -> FormalParameter(i);
bytecode.cpp:                local_variable_table_attribute ->
bytecode.cpp:                    AddLocalVariable(0, code_attribute -> CodeLength(),
bytecode.cpp:                                     RegisterName(parameter -> ExternalIdentity()),
bytecode.cpp:                                     RegisterUtf8(parameter -> Type() -> signature),
bytecode.cpp:                                     parameter -> LocalVariableIndex());
bytecode.cpp:            if (local_variable_table_attribute -> LocalVariableTableLength())
bytecode.cpp:                 code_attribute -> AddAttribute(local_variable_table_attribute);
bytecode.cpp:        methods[method_index] -> AddAttribute(code_attribute);
bytecode.cpp:// This is called to initialize non-constant static fields, and all instance
bytecode.cpp:    assert(vd -> variable_initializer_opt && vd -> symbol);
bytecode.cpp:        vd -> variable_initializer_opt -> ExpressionCast();
bytecode.cpp:        if (vd -> symbol -> ACC_STATIC())
bytecode.cpp:            assert(! vd -> symbol -> initial_value);
bytecode.cpp:            vd -> variable_initializer_opt -> ArrayInitializerCast();
bytecode.cpp:        if (! vd -> symbol -> ACC_STATIC())
bytecode.cpp:        InitializeArray(vd -> symbol -> Type(), array_initializer);
bytecode.cpp:    PutOp(vd -> symbol -> ACC_STATIC() ? OP_PUTSTATIC : OP_PUTFIELD);
bytecode.cpp:    if (expression && control.IsDoubleWordType(expression -> Type()))
bytecode.cpp:        ChangeStack(-1);
bytecode.cpp:    PutU2(RegisterFieldref(vd -> symbol));
bytecode.cpp:    TypeSymbol* subtype = type -> ArraySubtype();
bytecode.cpp:        LoadImmediateInteger(array_initializer -> NumVariableInitializers());
bytecode.cpp:         i < array_initializer -> NumVariableInitializers(); i++)
bytecode.cpp:        Ast* entry = array_initializer -> VariableInitializer(i);
bytecode.cpp:        AstExpression* expr = entry -> ExpressionCast();
bytecode.cpp:        if (expr && (IsZero(expr) || expr -> Type() == control.null_type))
bytecode.cpp:            if (expr -> Type() == control.float_type)
bytecode.cpp:                    (expr -> value);
bytecode.cpp:                optimize = value -> value.IsPositiveZero();
bytecode.cpp:            else if (expr -> Type() == control.double_type)
bytecode.cpp:                    (expr -> value);
bytecode.cpp:                optimize = value -> value.IsPositiveZero();
bytecode.cpp:            assert(entry -> ArrayInitializerCast());
bytecode.cpp:            InitializeArray(subtype, entry -> ArrayInitializerCast(),
bytecode.cpp:        assert(method_stack -> StartPc(declarator -> symbol) == 0xFFFF);
bytecode.cpp:        Coutput << "(53) Variable \"" << declarator -> symbol -> Name()
bytecode.cpp:                << declarator -> symbol -> LocalVariableIndex()
bytecode.cpp:        method_stack -> StartPc(declarator -> symbol) =
bytecode.cpp:            code_attribute -> CodeLength();
bytecode.cpp:    TypeSymbol* type = declarator -> symbol -> Type();
bytecode.cpp:    if (type -> num_dimensions > 255)
bytecode.cpp:    if (declarator -> symbol -> initial_value)
bytecode.cpp:        LoadLiteral(declarator -> symbol -> initial_value,
bytecode.cpp:                    declarator -> symbol -> Type());
bytecode.cpp:    else if (declarator -> variable_initializer_opt)
bytecode.cpp:        AstArrayCreationExpression* ace = declarator ->
bytecode.cpp:            variable_initializer_opt -> ArrayCreationExpressionCast();
bytecode.cpp:        AstArrayInitializer* ai = declarator ->
bytecode.cpp:            variable_initializer_opt -> ArrayInitializerCast();
bytecode.cpp:                (AstExpression*) declarator -> variable_initializer_opt;
bytecode.cpp:            assert(declarator -> variable_initializer_opt -> ExpressionCast());
bytecode.cpp:            // multi-dimensional array on the aastore opcode).  The
bytecode.cpp:            // assigned to a multi-dimensional local variable or directly
bytecode.cpp:                (StripNops(expr) -> Type() == control.null_type))
bytecode.cpp:    StoreLocal(declarator -> symbol -> LocalVariableIndex(), type);
bytecode.cpp:    if (! statement -> BlockCast())
bytecode.cpp:        line_number_table_attribute ->
bytecode.cpp:            AddLineNumber(code_attribute -> CodeLength(),
bytecode.cpp:                          semantic.lex_stream -> Line(statement -> LeftToken()));
bytecode.cpp:    switch (statement -> kind)
bytecode.cpp:                statement -> LocalVariableStatementCast();
bytecode.cpp:            for (unsigned i = 0; i < lvs -> NumVariableDeclarators(); i++)
bytecode.cpp:                DeclareLocalVariable(lvs -> VariableDeclarator(i));
bytecode.cpp:        EmitStatementExpression(statement -> ExpressionStatementCast() ->
bytecode.cpp:            if (IsOne(if_statement -> expression))
bytecode.cpp:                return EmitBlockStatement(if_statement -> true_statement);
bytecode.cpp:            if (IsZero(if_statement -> expression))
bytecode.cpp:                if (if_statement -> false_statement_opt)
bytecode.cpp:                    return EmitBlockStatement(if_statement ->
bytecode.cpp:            if (if_statement -> false_statement_opt &&
bytecode.cpp:                ! IsNop(if_statement -> false_statement_opt))
bytecode.cpp:                if (IsNop(if_statement -> true_statement))
bytecode.cpp:                    EmitBranchIfExpression(if_statement -> expression,
bytecode.cpp:                                           (if_statement ->
bytecode.cpp:                    EmitBlockStatement(if_statement -> false_statement_opt);
bytecode.cpp:                AstBlock* true_statement = if_statement -> true_statement;
bytecode.cpp:                EmitBranchIfExpression(if_statement -> expression,
bytecode.cpp:                               if_statement -> false_statement_opt);
bytecode.cpp:                abrupt &= EmitBlockStatement(if_statement ->
bytecode.cpp:            if (IsNop(if_statement -> true_statement))
bytecode.cpp:                EmitExpression(if_statement -> expression, false);
bytecode.cpp:            EmitBranchIfExpression(if_statement -> expression,
bytecode.cpp:                                   if_statement -> true_statement);
bytecode.cpp:            EmitBlockStatement(if_statement -> true_statement);
bytecode.cpp:        return EmitSwitchStatement(statement -> SwitchStatementCast());
bytecode.cpp:            AstWhileStatement* wp = statement -> WhileStatementCast();
bytecode.cpp:            if (! wp -> statement -> can_complete_normally)
bytecode.cpp:                if (wp -> expression -> IsConstant())
bytecode.cpp:                    assert(semantic.IsConstantTrue(wp -> expression));
bytecode.cpp:                    line_number_table_attribute ->
bytecode.cpp:                        AddLineNumber(code_attribute -> CodeLength(),
bytecode.cpp:                                      semantic.lex_stream -> Line(wp -> expression -> LeftToken()));
bytecode.cpp:                    EmitBranchIfExpression(wp -> expression, false,
bytecode.cpp:                                           method_stack -> TopBreakLabel(),
bytecode.cpp:                                           wp -> statement);
bytecode.cpp:                EmitBlockStatement(wp -> statement);
bytecode.cpp:            Label& continue_label = method_stack -> TopContinueLabel();
bytecode.cpp:            if (wp -> expression -> IsConstant())
bytecode.cpp:                assert(semantic.IsConstantTrue(wp -> expression));
bytecode.cpp:                EmitBranch(OP_GOTO, continue_label, wp -> statement);
bytecode.cpp:            u2 begin_pc = code_attribute -> CodeLength();
bytecode.cpp:            abrupt |= EmitBlockStatement(wp -> statement);
bytecode.cpp:            bool empty = (begin_pc == code_attribute -> CodeLength());
bytecode.cpp:            line_number_table_attribute ->
bytecode.cpp:                AddLineNumber(code_attribute -> CodeLength(),
bytecode.cpp:                              semantic.lex_stream -> Line(wp -> expression -> LeftToken()));
bytecode.cpp:            EmitBranchIfExpression(wp -> expression, true,
bytecode.cpp:                                   wp -> statement);
bytecode.cpp:            return abrupt && ! wp -> can_complete_normally;
bytecode.cpp:            AstDoStatement* sp = statement -> DoStatementCast();
bytecode.cpp:            bool abrupt = EmitBlockStatement(sp -> statement);
bytecode.cpp:            if (IsLabelUsed(method_stack -> TopContinueLabel()))
bytecode.cpp:                DefineLabel(method_stack -> TopContinueLabel());
bytecode.cpp:                CompleteLabel(method_stack -> TopContinueLabel());
bytecode.cpp:                line_number_table_attribute ->
bytecode.cpp:                    AddLineNumber(code_attribute -> CodeLength(),
bytecode.cpp:                                  semantic.lex_stream -> Line(sp -> expression -> LeftToken()));
bytecode.cpp:                EmitBranchIfExpression(sp -> expression, true,
bytecode.cpp:                                       begin_label, sp -> statement);
bytecode.cpp:            return (abrupt || IsOne(sp -> expression)) &&
bytecode.cpp:                ! sp -> can_complete_normally;
bytecode.cpp:            AstForStatement* for_statement = statement -> ForStatementCast();
bytecode.cpp:            for (unsigned i = 0; i < for_statement -> NumForInitStatements(); i++)
bytecode.cpp:                EmitStatement(for_statement -> ForInitStatement(i));
bytecode.cpp:            if (! for_statement -> statement -> can_complete_normally)
bytecode.cpp:                if (for_statement -> end_expression_opt)
bytecode.cpp:                    if (for_statement -> end_expression_opt -> IsConstant())
bytecode.cpp:                        assert(semantic.IsConstantTrue(for_statement -> end_expression_opt));
bytecode.cpp:                        line_number_table_attribute ->
bytecode.cpp:                            AddLineNumber(code_attribute -> CodeLength(),
bytecode.cpp:                                          semantic.lex_stream -> Line(for_statement -> end_expression_opt -> LeftToken()));
bytecode.cpp:                        EmitBranchIfExpression(for_statement -> end_expression_opt,
bytecode.cpp:                                               method_stack -> TopBreakLabel(),
bytecode.cpp:                                               for_statement -> statement);
bytecode.cpp:                EmitBlockStatement(for_statement -> statement);
bytecode.cpp:            Label& continue_label = method_stack -> TopContinueLabel();
bytecode.cpp:            if (for_statement -> end_expression_opt &&
bytecode.cpp:                ! for_statement -> end_expression_opt -> IsConstant())
bytecode.cpp:                           (for_statement -> NumForUpdateStatements()
bytecode.cpp:                           for_statement -> statement);
bytecode.cpp:            u2 begin_pc = code_attribute -> CodeLength();
bytecode.cpp:            abrupt |= EmitBlockStatement(for_statement -> statement);
bytecode.cpp:            bool empty = (begin_pc == code_attribute -> CodeLength());
bytecode.cpp:                 j < for_statement -> NumForUpdateStatements(); j++)
bytecode.cpp:                EmitStatement(for_statement -> ForUpdateStatement(j));
bytecode.cpp:            AstExpression* end_expr = for_statement -> end_expression_opt;
bytecode.cpp:                line_number_table_attribute ->
bytecode.cpp:                    AddLineNumber(code_attribute -> CodeLength(),
bytecode.cpp:                                  semantic.lex_stream -> Line(end_expr ->
bytecode.cpp:                                       for_statement -> statement);
bytecode.cpp:                            for_statement -> statement);
bytecode.cpp:            return abrupt && ! for_statement -> can_complete_normally;
bytecode.cpp:                statement -> BreakStatementCast() -> nesting_level;
bytecode.cpp:            AstBlock* over = method_stack -> Block(nesting_level);
bytecode.cpp:            u2 jump_size = (over -> RightToken() - over -> LeftToken() <
bytecode.cpp:                EmitBranch(OP_GOTO, method_stack -> BreakLabel(nesting_level),
bytecode.cpp:                statement -> ContinueStatementCast() -> nesting_level;
bytecode.cpp:            AstBlock* over = method_stack -> Block(nesting_level);
bytecode.cpp:            u2 jump_size = (over -> RightToken() - over -> LeftToken() <
bytecode.cpp:                           method_stack -> ContinueLabel(nesting_level),
bytecode.cpp:        EmitReturnStatement(statement -> ReturnStatementCast());
bytecode.cpp:        EmitExpression(statement -> ThrowStatementCast() -> expression);
bytecode.cpp:        return ! statement -> can_complete_normally;
bytecode.cpp:    AstExpression* expression = statement -> expression_opt;
bytecode.cpp:        if (ProcessAbruptExit(method_stack -> NestingLevel(0), 1))
bytecode.cpp:        TypeSymbol* type = expression -> Type();
bytecode.cpp:        if (ProcessAbruptExit(method_stack -> NestingLevel(0), 1, type))
bytecode.cpp:    method_stack -> Push(block);
bytecode.cpp:    for (unsigned i = 0; i < block -> NumStatements() && ! abrupt; i++)
bytecode.cpp:        abrupt = EmitStatement(block -> Statement(i));
bytecode.cpp:    if (IsLabelUsed(method_stack -> TopBreakLabel()))
bytecode.cpp:        DefineLabel(method_stack -> TopBreakLabel());
bytecode.cpp:        CompleteLabel(method_stack -> TopBreakLabel());
bytecode.cpp:        for (unsigned i = 0; i < block -> NumLocallyDefinedVariables(); i++)
bytecode.cpp:            VariableSymbol* variable = block -> LocallyDefinedVariable(i);
bytecode.cpp:            if (method_stack -> StartPc(variable) == 0xFFFF) // never used
bytecode.cpp:            Coutput << "(56) The symbol \"" << variable -> Name()
bytecode.cpp:                    << "\" numbered " << variable -> LocalVariableIndex()
bytecode.cpp:            local_variable_table_attribute ->
bytecode.cpp:                AddLocalVariable(method_stack -> StartPc(variable),
bytecode.cpp:                                 code_attribute -> CodeLength(),
bytecode.cpp:                                 RegisterName(variable -> ExternalIdentity()),
bytecode.cpp:                                 RegisterUtf8(variable -> Type() -> signature),
bytecode.cpp:                                 variable -> LocalVariableIndex());
bytecode.cpp:    method_stack -> Pop();
bytecode.cpp:    switch (expression -> kind)
bytecode.cpp:    AstBlock* switch_block = switch_statement -> switch_block;
bytecode.cpp:    u2 op_start = code_attribute -> CodeLength();
bytecode.cpp:    if (switch_statement -> expression -> IsConstant())
bytecode.cpp:        CaseElement* target = switch_statement ->
bytecode.cpp:                         (switch_statement -> expression -> value) -> value);
bytecode.cpp:        // Bring all previously-declared variables into scope, then compile
bytecode.cpp:        method_stack -> Push(switch_block);
bytecode.cpp:        for (i = 0; i < target -> block_index; i++)
bytecode.cpp:            EmitSwitchBlockStatement(switch_statement -> Block(i), true);
bytecode.cpp:        for ( ; ! abrupt && i < switch_statement -> NumBlocks(); i++)
bytecode.cpp:                EmitSwitchBlockStatement(switch_statement -> Block(i), abrupt);
bytecode.cpp:        if (IsLabelUsed(method_stack -> TopBreakLabel()))
bytecode.cpp:            DefineLabel(method_stack -> TopBreakLabel());
bytecode.cpp:            CompleteLabel(method_stack -> TopBreakLabel());
bytecode.cpp:        method_stack -> Pop();
bytecode.cpp:    if (! switch_statement -> NumBlocks())
bytecode.cpp:        EmitExpression(switch_statement -> expression, false);
bytecode.cpp:    if (switch_statement -> NumBlocks() == 1 &&
bytecode.cpp:        switch_statement -> DefaultCase())
bytecode.cpp:        EmitExpression(switch_statement -> expression, false);
bytecode.cpp:        method_stack -> Push(switch_block);
bytecode.cpp:        abrupt = EmitSwitchBlockStatement(switch_statement -> Block(0), false);
bytecode.cpp:        if (IsLabelUsed(method_stack -> TopBreakLabel()))
bytecode.cpp:            DefineLabel(method_stack -> TopBreakLabel());
bytecode.cpp:            CompleteLabel(method_stack -> TopBreakLabel());
bytecode.cpp:        method_stack -> Pop();
bytecode.cpp:    // Optimization: If there is one non-default label, turn this into an
bytecode.cpp:    if (switch_statement -> NumCases() == 1)
bytecode.cpp:        if (! switch_statement -> DefaultCase())
bytecode.cpp:            EmitExpression(switch_statement -> expression);
bytecode.cpp:            if (switch_statement -> Case(0) -> value)
bytecode.cpp:                LoadImmediateInteger(switch_statement -> Case(0) -> value);
bytecode.cpp:            method_stack -> Push(switch_block);
bytecode.cpp:            EmitSwitchBlockStatement(switch_statement -> Block(0), false);
bytecode.cpp:            if (IsLabelUsed(method_stack -> TopBreakLabel()))
bytecode.cpp:                DefineLabel(method_stack -> TopBreakLabel());
bytecode.cpp:                CompleteLabel(method_stack -> TopBreakLabel());
bytecode.cpp:            method_stack -> Pop();
bytecode.cpp:    unsigned ncases = switch_statement -> NumCases();
bytecode.cpp:        low = switch_statement -> Case(0) -> value;
bytecode.cpp:        high = switch_statement -> Case(ncases - 1) -> value;
bytecode.cpp:            // We want to compute (1 + (high - low + 1)) < (ncases * 2 + 8).
bytecode.cpp:            i4 range = high - low + 1;
bytecode.cpp:    method_stack -> Push(switch_block);
bytecode.cpp:    line_number_table_attribute ->
bytecode.cpp:        AddLineNumber(code_attribute -> CodeLength(),
bytecode.cpp:                      semantic.lex_stream -> Line(switch_statement ->
bytecode.cpp:                                                  expression -> LeftToken()));
bytecode.cpp:    EmitExpression(switch_statement -> expression);
bytecode.cpp:    while (code_attribute -> CodeLength() % 4 != 0)
bytecode.cpp:             code_attribute -> CodeLength() - op_start);
bytecode.cpp:            PutU4(switch_statement -> Case(i) -> value);
bytecode.cpp:                     code_attribute -> CodeLength() - op_start);
bytecode.cpp:                     code_attribute -> CodeLength() - op_start);
bytecode.cpp:    for (i = 0; i < switch_block -> NumStatements(); i++)
bytecode.cpp:            switch_statement -> Block(i);
bytecode.cpp:             li < switch_block_statement -> NumSwitchLabels(); li++)
bytecode.cpp:                switch_block_statement -> SwitchLabel(li);
bytecode.cpp:                DefineLabel(case_labels[switch_label -> map_index]);
bytecode.cpp:            else if (switch_label -> expression_opt)
bytecode.cpp:                    (switch_label -> expression_opt -> value) -> value;
bytecode.cpp:                DefineLabel(case_labels[value - low]);
bytecode.cpp:                for ( ; j < switch_statement -> NumCases(); j++, k++)
bytecode.cpp:                    while (k != switch_statement -> Case(j) -> value)
bytecode.cpp:                        DefineLabel(case_labels[k++ - low]);
bytecode.cpp:    if (IsLabelUsed(method_stack -> TopBreakLabel()))
bytecode.cpp:        DefineLabel(method_stack -> TopBreakLabel());
bytecode.cpp:        CompleteLabel(method_stack -> TopBreakLabel());
bytecode.cpp:    method_stack -> Pop();
bytecode.cpp:    assert(abrupt || switch_statement -> can_complete_normally);
bytecode.cpp:    for (unsigned i = 0; i < block -> NumStatements(); i++)
bytecode.cpp:            abrupt = EmitStatement(block -> Statement(i));
bytecode.cpp:        else if (block -> Statement(i) -> LocalVariableStatementCast())
bytecode.cpp:                (AstLocalVariableStatement*) block -> Statement(i);
bytecode.cpp:            for (unsigned j = 0; j < lvs -> NumVariableDeclarators(); j++)
bytecode.cpp:                    lvs -> VariableDeclarator(j);
bytecode.cpp:                    method_stack -> StartPc(declarator -> symbol) =
bytecode.cpp:                        code_attribute -> CodeLength();
bytecode.cpp:                if (declarator -> symbol -> Type() -> num_dimensions > 255)
bytecode.cpp:             i < switch_block -> NumLocallyDefinedVariables(); i++)
bytecode.cpp:                switch_block -> LocallyDefinedVariable(i);
bytecode.cpp:            if (method_stack -> StartPc(variable) > op_start)
bytecode.cpp:                if (method_stack -> StartPc(variable) == 0xFFFF) // never used
bytecode.cpp:                Coutput << "(58) The symbol \"" << variable -> Name()
bytecode.cpp:                        << "\" numbered " << variable -> LocalVariableIndex()
bytecode.cpp:                local_variable_table_attribute ->
bytecode.cpp:                    AddLocalVariable(method_stack -> StartPc(variable),
bytecode.cpp:                                     code_attribute -> CodeLength(),
bytecode.cpp:                                     RegisterName(variable -> ExternalIdentity()),
bytecode.cpp:                                     RegisterUtf8(variable -> Type() -> signature),
bytecode.cpp:                                     variable -> LocalVariableIndex());
bytecode.cpp:    assert(method_stack -> TopFinallyLabel().uses.Length() == 0);
bytecode.cpp:    assert(method_stack -> TopFinallyLabel().defined == false);
bytecode.cpp:    assert(method_stack -> TopFinallyLabel().definition == 0);
bytecode.cpp:    u2 start_try_block_pc = code_attribute -> CodeLength(); // start pc
bytecode.cpp:    assert(method_stack -> TopHandlerRangeStart().Length() == 0 &&
bytecode.cpp:           method_stack -> TopHandlerRangeEnd().Length() == 0);
bytecode.cpp:    method_stack -> TopHandlerRangeStart().Push(start_try_block_pc);
bytecode.cpp:    bool emit_finally_clause = statement -> finally_clause_opt &&
bytecode.cpp:        ! IsNop(statement -> finally_clause_opt -> block);
bytecode.cpp:    if (statement -> finally_clause_opt)
bytecode.cpp:            statement -> block -> SetTag(AstBlock::NONE);
bytecode.cpp:        else if (! statement -> finally_clause_opt -> block ->
bytecode.cpp:            statement -> block -> SetTag(AstBlock::ABRUPT_TRY_FINALLY);
bytecode.cpp:    if (statement -> block -> Tag() == AstBlock::NONE &&
bytecode.cpp:        statement -> NumCatchClauses())
bytecode.cpp:        statement -> block -> SetTag(AstBlock::TRY_CLAUSE_WITH_CATCH);
bytecode.cpp:    bool abrupt = EmitBlockStatement(statement -> block);
bytecode.cpp:    u2 end_try_block_pc = code_attribute -> CodeLength();
bytecode.cpp:    Tuple<u2> handler_starts(method_stack -> TopHandlerRangeStart());
bytecode.cpp:    Tuple<u2> handler_ends(method_stack -> TopHandlerRangeEnd());
bytecode.cpp:        Label& finally_label = method_stack -> TopFinallyLabel();
bytecode.cpp:            (emit_finally_clause || statement -> NumCatchClauses()))
bytecode.cpp:        for (unsigned i = 0; i < statement -> NumCatchClauses(); i++)
bytecode.cpp:            u2 handler_pc = code_attribute -> CodeLength();
bytecode.cpp:            AstCatchClause* catch_clause = statement -> CatchClause(i);
bytecode.cpp:                catch_clause -> parameter_symbol;
bytecode.cpp:            line_number_table_attribute ->
bytecode.cpp:                AddLineNumber(code_attribute -> CodeLength(),
bytecode.cpp:                              semantic.lex_stream -> Line(catch_clause ->
bytecode.cpp:                ! IsNop(catch_clause -> block))
bytecode.cpp:                StoreLocal(parameter_symbol -> LocalVariableIndex(),
bytecode.cpp:                           parameter_symbol -> Type());
bytecode.cpp:            u2 handler_type = RegisterClass(parameter_symbol -> Type());
bytecode.cpp:            for (int j = handler_starts.Length(); --j >= 0; )
bytecode.cpp:                code_attribute ->
bytecode.cpp:            if (statement -> finally_clause_opt)
bytecode.cpp:                    catch_clause -> block -> SetTag(AstBlock::NONE);
bytecode.cpp:                else if (! statement -> finally_clause_opt -> block ->
bytecode.cpp:                    catch_clause -> block ->
bytecode.cpp:            abrupt = EmitBlockStatement(catch_clause -> block);
bytecode.cpp:                local_variable_table_attribute ->
bytecode.cpp:                                     code_attribute -> CodeLength(),
bytecode.cpp:                                     RegisterName(parameter_symbol -> ExternalIdentity()),
bytecode.cpp:                                     RegisterUtf8(parameter_symbol -> Type() -> signature),
bytecode.cpp:                                     parameter_symbol -> LocalVariableIndex());
bytecode.cpp:                             i < (statement -> NumCatchClauses() - 1)))
bytecode.cpp:            int variable_index = method_stack -> TopBlock() ->
bytecode.cpp:                block_symbol -> helper_variable_index;
bytecode.cpp:            u2 finally_start_pc = code_attribute -> CodeLength();
bytecode.cpp:            if (statement -> finally_clause_opt -> block ->
bytecode.cpp:                special_end_pc = code_attribute -> CodeLength();
bytecode.cpp:            method_stack -> TopHandlerRangeEnd().Push(special_end_pc);
bytecode.cpp:            unsigned count = method_stack -> TopHandlerRangeStart().Length();
bytecode.cpp:            assert(count == method_stack -> TopHandlerRangeEnd().Length());
bytecode.cpp:            while (count--)
bytecode.cpp:                code_attribute ->
bytecode.cpp:                    AddException(method_stack -> TopHandlerRangeStart().Pop(),
bytecode.cpp:                                 method_stack -> TopHandlerRangeEnd().Pop(),
bytecode.cpp:            if (statement -> finally_clause_opt -> block ->
bytecode.cpp:            EmitBlockStatement(statement -> finally_clause_opt -> block);
bytecode.cpp:            if (statement -> finally_clause_opt -> block ->
bytecode.cpp:                               statement -> finally_clause_opt -> block);
bytecode.cpp:                    special_end_pc = code_attribute -> CodeLength();
bytecode.cpp:                    code_attribute -> AddException(special_end_pc - 3,
bytecode.cpp:            method_stack -> TopHandlerRangeStart().Reset();
bytecode.cpp:            method_stack -> TopHandlerRangeEnd().Reset();
bytecode.cpp:        method_stack -> TopHandlerRangeStart().Reset();
bytecode.cpp:            EmitBlockStatement(statement -> finally_clause_opt -> block);
bytecode.cpp:    int variable_index = -1;
bytecode.cpp:    // stack, in case a finally block contains an embedded try-catch which
bytecode.cpp:        for (unsigned i = method_stack -> Size() - 1;
bytecode.cpp:             i > 0 && method_stack -> NestingLevel(i) != level; i--)
bytecode.cpp:            unsigned nesting_level = method_stack -> NestingLevel(i);
bytecode.cpp:            unsigned enclosing_level = method_stack -> NestingLevel(i - 1);
bytecode.cpp:            AstBlock* block = method_stack -> Block(nesting_level);
bytecode.cpp:            if (block -> Tag() == AstBlock::TRY_CLAUSE_WITH_FINALLY)
bytecode.cpp:                variable_index = method_stack -> Block(enclosing_level) ->
bytecode.cpp:                    block_symbol -> helper_variable_index + 2;
bytecode.cpp:            else if (block -> Tag() == AstBlock::ABRUPT_TRY_FINALLY)
bytecode.cpp:                variable_index = -1;
bytecode.cpp:    for (unsigned i = method_stack -> Size() - 1;
bytecode.cpp:         i > 0 && method_stack -> NestingLevel(i) != level; i--)
bytecode.cpp:        unsigned nesting_level = method_stack -> NestingLevel(i);
bytecode.cpp:        unsigned enclosing_level = method_stack -> NestingLevel(i - 1);
bytecode.cpp:        AstBlock* block = method_stack -> Block(nesting_level);
bytecode.cpp:        if (block -> Tag() == AstBlock::TRY_CLAUSE_WITH_FINALLY)
bytecode.cpp:            EmitBranch(OP_JSR, method_stack -> FinallyLabel(enclosing_level),
bytecode.cpp:                       method_stack -> Block(enclosing_level));
bytecode.cpp:            method_stack -> HandlerRangeEnd(enclosing_level).
bytecode.cpp:                Push(code_attribute -> CodeLength());
bytecode.cpp:        else if (block -> Tag() == AstBlock::ABRUPT_TRY_FINALLY)
bytecode.cpp:            EmitBranch(OP_GOTO, method_stack -> FinallyLabel(enclosing_level),
bytecode.cpp:                       method_stack -> Block(enclosing_level));
bytecode.cpp:            method_stack -> HandlerRangeEnd(enclosing_level).
bytecode.cpp:                Push(code_attribute -> CodeLength());
bytecode.cpp:        else if (block -> Tag() == AstBlock::SYNCHRONIZED)
bytecode.cpp:            int variable_index = method_stack -> Block(enclosing_level) ->
bytecode.cpp:                block_symbol -> helper_variable_index;
bytecode.cpp:            method_stack -> HandlerRangeEnd(enclosing_level).
bytecode.cpp:                Push(code_attribute -> CodeLength());
bytecode.cpp:        else if (block -> Tag() == AstBlock::TRY_CLAUSE_WITH_CATCH)
bytecode.cpp:            method_stack -> HandlerRangeEnd(enclosing_level).
bytecode.cpp:                Push(code_attribute -> CodeLength());
bytecode.cpp:    for (unsigned j = method_stack -> Size() - 1;
bytecode.cpp:         j > 0 && method_stack -> NestingLevel(j) != level; j--)
bytecode.cpp:        unsigned nesting_level = method_stack -> NestingLevel(j);
bytecode.cpp:        unsigned enclosing_level = method_stack -> NestingLevel(j - 1);
bytecode.cpp:        AstBlock* block = method_stack -> Block(nesting_level);
bytecode.cpp:        if (block -> Tag() == AstBlock::SYNCHRONIZED ||
bytecode.cpp:            block -> Tag() == AstBlock::TRY_CLAUSE_WITH_CATCH ||
bytecode.cpp:            block -> Tag() == AstBlock::TRY_CLAUSE_WITH_FINALLY)
bytecode.cpp:            method_stack -> HandlerRangeStart(enclosing_level).
bytecode.cpp:                Push(code_attribute -> CodeLength() + width);
bytecode.cpp:        else if (block -> Tag() == AstBlock::ABRUPT_TRY_FINALLY)
bytecode.cpp:            method_stack -> HandlerRangeStart(enclosing_level).
bytecode.cpp:                Push(code_attribute -> CodeLength());
bytecode.cpp:    // to the 4-byte branch opcode or write out a branch around a goto_w for
bytecode.cpp:    int sizeHeuristic = over ? over -> RightToken() - over -> LeftToken() : 0;
bytecode.cpp:    assert(p -> Type() == control.boolean_type);
bytecode.cpp:    if (p -> IsConstant())
bytecode.cpp:    AstPreUnaryExpression* pre = p -> PreUnaryExpressionCast();
bytecode.cpp:        assert(pre -> Tag() == AstPreUnaryExpression::NOT);
bytecode.cpp:        EmitBranchIfExpression(pre -> expression, ! cond, lab, over);
bytecode.cpp:    AstConditionalExpression* conditional = p -> ConditionalExpressionCast();
bytecode.cpp:        if (conditional -> test_expression -> IsConstant())
bytecode.cpp:            EmitBranchIfExpression((IsZero(conditional -> test_expression)
bytecode.cpp:                                    ? conditional -> false_expression
bytecode.cpp:                                    : conditional -> true_expression),
bytecode.cpp:        else if (IsOne(conditional -> true_expression))
bytecode.cpp:            if (IsOne(conditional -> false_expression))
bytecode.cpp:                EmitExpression(conditional -> test_expression, false);
bytecode.cpp:            else if (IsZero(conditional -> false_expression))
bytecode.cpp:                EmitBranchIfExpression(conditional -> test_expression,
bytecode.cpp:                EmitBranchIfExpression(conditional -> test_expression, true,
bytecode.cpp:                EmitBranchIfExpression(conditional -> false_expression, true,
bytecode.cpp:                EmitBranchIfExpression(conditional -> test_expression, true,
bytecode.cpp:                EmitBranchIfExpression(conditional -> false_expression, false,
bytecode.cpp:        else if (IsZero(conditional -> true_expression))
bytecode.cpp:            if (IsOne(conditional -> false_expression))
bytecode.cpp:                EmitBranchIfExpression(conditional -> test_expression,
bytecode.cpp:            else if (IsZero(conditional -> false_expression))
bytecode.cpp:                EmitExpression(conditional -> test_expression, false);
bytecode.cpp:                EmitBranchIfExpression(conditional -> test_expression, true,
bytecode.cpp:                EmitBranchIfExpression(conditional -> false_expression, false,
bytecode.cpp:                EmitBranchIfExpression(conditional -> test_expression, true,
bytecode.cpp:                EmitBranchIfExpression(conditional -> false_expression, true,
bytecode.cpp:        else if (IsOne(conditional -> false_expression))
bytecode.cpp:                EmitBranchIfExpression(conditional -> test_expression, false,
bytecode.cpp:                EmitBranchIfExpression(conditional -> true_expression, true,
bytecode.cpp:                EmitBranchIfExpression(conditional -> test_expression, false,
bytecode.cpp:                EmitBranchIfExpression(conditional -> true_expression, false,
bytecode.cpp:        else if (IsZero(conditional -> false_expression))
bytecode.cpp:                EmitBranchIfExpression(conditional -> test_expression, false,
bytecode.cpp:                EmitBranchIfExpression(conditional -> true_expression, false,
bytecode.cpp:                EmitBranchIfExpression(conditional -> test_expression, false,
bytecode.cpp:                EmitBranchIfExpression(conditional -> true_expression, true,
bytecode.cpp:            EmitBranchIfExpression(conditional -> test_expression, false, lab1,
bytecode.cpp:            EmitBranchIfExpression(conditional -> true_expression, cond, lab,
bytecode.cpp:            EmitBranchIfExpression(conditional -> false_expression, cond, lab,
bytecode.cpp:    AstInstanceofExpression* instanceof = p -> InstanceofExpressionCast();
bytecode.cpp:        AstExpression* expr = StripNops(instanceof -> expression);
bytecode.cpp:        TypeSymbol* left_type = expr -> Type();
bytecode.cpp:        TypeSymbol* right_type = instanceof -> type -> symbol;
bytecode.cpp:        if (right_type -> num_dimensions > 255)
bytecode.cpp:                                    instanceof -> type);
bytecode.cpp:        else if (expr -> IsConstant() || // a String constant
bytecode.cpp:                 expr -> BinaryExpressionCast()) // a String concat
bytecode.cpp:            // We know the result: true, since the expression is non-null
bytecode.cpp:        else if ((expr -> ThisExpressionCast() ||
bytecode.cpp:                  expr -> SuperExpressionCast() ||
bytecode.cpp:                  expr -> ClassLiteralCast() ||
bytecode.cpp:                  expr -> ClassCreationExpressionCast() ||
bytecode.cpp:                  expr -> ArrayCreationExpressionCast()) &&
bytecode.cpp:                 left_type -> IsSubtype(right_type))
bytecode.cpp:            // We know the result: true, since the expression is non-null.
bytecode.cpp:    // dispose of non-binary expression case by just evaluating
bytecode.cpp:    AstBinaryExpression* bp = p -> BinaryExpressionCast();
bytecode.cpp:    AstExpression* left = StripNops(bp -> left_expression);
bytecode.cpp:    AstExpression* right = StripNops(bp -> right_expression);
bytecode.cpp:    TypeSymbol* left_type = left -> Type();
bytecode.cpp:    TypeSymbol* right_type = right -> Type();
bytecode.cpp:    switch (bp -> Tag())
bytecode.cpp:        if (left -> IsConstant())
bytecode.cpp:        else if (right -> IsConstant())
bytecode.cpp:        if (left -> IsConstant())
bytecode.cpp:        else if (right -> IsConstant())
bytecode.cpp:                if (cond == (bp -> Tag() == AstBinaryExpression::EQUAL_EQUAL))
bytecode.cpp:                if (bp -> Tag() == AstBinaryExpression::EQUAL_EQUAL)
bytecode.cpp:                                   cond == (bp -> Tag() == AstBinaryExpression::EQUAL_EQUAL),
bytecode.cpp:                                           cond == (bp -> Tag() != AstBinaryExpression::EQUAL_EQUAL),
bytecode.cpp:                    if (bp -> Tag() == AstBinaryExpression::EQUAL_EQUAL)
bytecode.cpp:                if (bp -> Tag() == AstBinaryExpression::EQUAL_EQUAL)
bytecode.cpp:            if (bp -> Tag() == AstBinaryExpression::EQUAL_EQUAL)
bytecode.cpp:    // here if not comparison, comparison for non-integral numeric types, or
bytecode.cpp:    // Begin by dealing with non-comparisons
bytecode.cpp:    switch (bp -> Tag())
bytecode.cpp:            switch (bp -> Tag())
bytecode.cpp:            switch (bp -> Tag())
bytecode.cpp:            switch (bp -> Tag())
bytecode.cpp:        switch (bp -> Tag())
bytecode.cpp:        switch (bp -> Tag())
bytecode.cpp:        switch (bp -> Tag())
bytecode.cpp:        method_stack -> TopBlock() -> block_symbol -> helper_variable_index;
bytecode.cpp:    // statement be asynch-exception safe.  Note that the user can cause
bytecode.cpp:    u2 handler_pc = code_attribute -> CodeLength();
bytecode.cpp:    u2 throw_pc = code_attribute -> CodeLength();
bytecode.cpp:    code_attribute -> AddException(handler_pc, throw_pc, handler_pc, 0);
bytecode.cpp:    EmitExpression(statement -> expression);
bytecode.cpp:    assert(method_stack -> TopHandlerRangeStart().Length() == 0 &&
bytecode.cpp:           method_stack -> TopHandlerRangeEnd().Length() == 0);
bytecode.cpp:    method_stack -> TopHandlerRangeStart().Push(code_attribute -> CodeLength());
bytecode.cpp:    bool abrupt = EmitBlockStatement(statement -> block);
bytecode.cpp:    u2 end_pc = code_attribute -> CodeLength();
bytecode.cpp:    method_stack -> TopHandlerRangeEnd().Push(end_pc);
bytecode.cpp:    unsigned count = method_stack -> TopHandlerRangeStart().Length();
bytecode.cpp:    assert(count == method_stack -> TopHandlerRangeEnd().Length());
bytecode.cpp:    while (count--)
bytecode.cpp:        code_attribute ->
bytecode.cpp:            AddException(method_stack -> TopHandlerRangeStart().Pop(),
bytecode.cpp:                         method_stack -> TopHandlerRangeEnd().Pop(),
bytecode.cpp:    // When constant true, the assert statement is a no-op.
bytecode.cpp:    if (semantic.IsConstantTrue(assertion -> condition) ||
bytecode.cpp:    PutU2(RegisterFieldref(assertion -> assert_variable));
bytecode.cpp:    EmitBranchIfExpression(assertion -> condition, true, label);
bytecode.cpp:    if (assertion -> message_opt)
bytecode.cpp:        EmitExpression(assertion -> message_opt);
bytecode.cpp:        TypeSymbol* type = assertion -> message_opt -> Type();
bytecode.cpp:        if (! control.AssertionError() -> Bad())
bytecode.cpp:                                        unit_type -> ContainingPackageName(),
bytecode.cpp:                                        unit_type -> ExternalName());
bytecode.cpp:        ChangeStack(- GetTypeWords(type));
bytecode.cpp:        method_stack -> TopBlock() -> block_symbol -> helper_variable_index;
bytecode.cpp:    EmitExpression(foreach -> expression);
bytecode.cpp:    Label& comp = method_stack -> TopContinueLabel();
bytecode.cpp:    TypeSymbol* expr_type = foreach -> expression -> Type();
bytecode.cpp:        foreach -> formal_parameter -> formal_declarator -> symbol;
bytecode.cpp:    TypeSymbol* component_type = var -> Type();
bytecode.cpp:    if (expr_type -> IsArray())
bytecode.cpp:        // assignment-conversion (if necessary)
bytecode.cpp:        TypeSymbol* expr_subtype = expr_type -> ArraySubtype();
bytecode.cpp:        if (IsNop(foreach -> statement) &&
bytecode.cpp:            (! component_type -> Primitive() || expr_subtype -> Primitive()))
bytecode.cpp:            // array is non-null from arraylength. But beware of autounboxing,
bytecode.cpp:        LoadArrayElement(expr_type -> ArraySubtype());
bytecode.cpp:        EmitCast(component_type, expr_type -> ArraySubtype());
bytecode.cpp:        u2 var_pc = code_attribute -> CodeLength();        
bytecode.cpp:        StoreLocal(var -> LocalVariableIndex(), component_type);
bytecode.cpp:        abrupt = EmitStatement(foreach -> statement);
bytecode.cpp:            local_variable_table_attribute ->
bytecode.cpp:                AddLocalVariable(var_pc, code_attribute -> CodeLength(),
bytecode.cpp:                                 RegisterName(var -> ExternalIdentity()),
bytecode.cpp:                                 RegisterUtf8(component_type -> signature),
bytecode.cpp:                                 var -> LocalVariableIndex());
bytecode.cpp:        if (! abrupt || foreach -> statement -> can_complete_normally)
bytecode.cpp:        assert(foreach -> expression -> Type() ->
bytecode.cpp:        u2 var_pc = code_attribute -> CodeLength();        
bytecode.cpp:        StoreLocal(var -> LocalVariableIndex(), component_type);
bytecode.cpp:        abrupt = EmitStatement(foreach -> statement);
bytecode.cpp:            local_variable_table_attribute ->
bytecode.cpp:                AddLocalVariable(var_pc, code_attribute -> CodeLength(),
bytecode.cpp:                                 RegisterName(var -> ExternalIdentity()),
bytecode.cpp:                                 RegisterUtf8(component_type -> signature),
bytecode.cpp:                                 var -> LocalVariableIndex());
bytecode.cpp:        if (! abrupt || foreach -> statement -> can_complete_normally)
bytecode.cpp:    if (expression -> IsConstant())
bytecode.cpp:            LoadLiteral(expression -> value, expression -> Type());
bytecode.cpp:            return GetTypeWords(expression -> Type());
bytecode.cpp:    switch (expression -> kind)
bytecode.cpp:            if (this_expr -> resolution_opt && need_value)
bytecode.cpp:                return EmitExpression(this_expr -> resolution_opt, true);
bytecode.cpp:            if (super_expr -> resolution_opt && need_value)
bytecode.cpp:                return EmitExpression(super_expr -> resolution_opt, true);
bytecode.cpp:            if (class_lit -> resolution_opt)
bytecode.cpp:            TypeSymbol* type = expression -> symbol -> TypeCast();
bytecode.cpp:                LoadConstantAtIndex(RegisterClass(class_lit -> type ->
bytecode.cpp:                assert(expression -> symbol -> VariableCast());
bytecode.cpp:                PutU2(RegisterFieldref((VariableSymbol*) expression ->
bytecode.cpp:    AstFieldAccess* field = expression -> FieldAccessCast();
bytecode.cpp:    if (field && field -> resolution_opt)
bytecode.cpp:        return field -> resolution_opt;
bytecode.cpp:    AstName* name = expression -> NameCast();
bytecode.cpp:    if (name && name -> resolution_opt)
bytecode.cpp:        return name -> resolution_opt;
bytecode.cpp:    AstFieldAccess* field = expression -> FieldAccessCast();
bytecode.cpp:    AstName* name = expression -> NameCast();
bytecode.cpp:    TypeSymbol* candidate = field ? field -> base -> Type()
bytecode.cpp:        : name -> base_opt ? name -> base_opt -> Type() : unit_type;
bytecode.cpp:    return (sym -> ContainingType() -> ACC_INTERFACE() &&
bytecode.cpp:        ? sym -> ContainingType() : candidate;
bytecode.cpp:    TypeSymbol* owner_type = msym -> containing_type;
bytecode.cpp:    TypeSymbol* base_type = msym -> ACC_SYNTHETIC() ? owner_type
bytecode.cpp:        : base ? base -> Type() : unit_type;
bytecode.cpp:    AstFieldAccess* field = expression -> FieldAccessCast();
bytecode.cpp:    AstName* name = expression -> NameCast();
bytecode.cpp:    if (field || (name && name -> base_opt))
bytecode.cpp:        EmitExpression(field ? field -> base : name -> base_opt);
bytecode.cpp:    if (control.IsDoubleWordType(expression -> Type()))
bytecode.cpp:    VariableSymbol* sym = (VariableSymbol*) expression -> symbol;
bytecode.cpp:    // Here, we add a line-number attribute entry for this method.
bytecode.cpp:    line_number_table_attribute -> AddLineNumber(0, 0);
bytecode.cpp:    // pre-SDK1_4 exception handler if forName fails (optimization: the
bytecode.cpp:    // post-SDK1_4 exception handler if forName fails (optimization: the
bytecode.cpp:    code_attribute ->
bytecode.cpp:        ChangeStack(-1); // account for the argument to the constructor
bytecode.cpp:    // dup                       optimize: common case is non-null
bytecode.cpp:    assert(class_lit -> symbol -> VariableCast());
bytecode.cpp:    VariableSymbol* cache = (VariableSymbol*) class_lit -> symbol;
bytecode.cpp:    TypeSymbol* type = class_lit -> type -> symbol;
bytecode.cpp:    if (type -> num_dimensions > 255)
bytecode.cpp:    bool is_array = type -> IsArray();
bytecode.cpp:        type = type -> GetArrayType(control.system_semantic, 1);
bytecode.cpp:    LoadLiteral(type -> FindOrInsertClassLiteralName(control),
bytecode.cpp:    CompleteCall(cache -> ContainingType() -> ClassLiteralMethod(), 2);
bytecode.cpp:    //   - we use fewer bytecodes if the rest of the class does not use class
bytecode.cpp:    //     literals (and we need no try-catch block)
bytecode.cpp:    //   - determining assertion status will not initialize an enclosing class.
bytecode.cpp:    // semantics of assert - until class initialization starts, the default
bytecode.cpp:    tsym = tsym -> GetArrayType(control.system_semantic, 1);
bytecode.cpp:    LoadLiteral(tsym -> FindOrInsertClassLiteralName(control),
bytecode.cpp:    if (expression -> symbol -> TypeCast())
bytecode.cpp:    VariableSymbol* var = expression -> symbol -> VariableCast();
bytecode.cpp:    return LoadVariable((expression -> resolution_opt ? ACCESSED_VAR
bytecode.cpp:                         : var -> owner -> MethodCast() ? LOCAL_VAR
bytecode.cpp:                         : var -> ACC_STATIC() ? STATIC_VAR : FIELD_VAR),
bytecode.cpp:    unsigned num_dims = expression -> NumDimExprs();
bytecode.cpp:    if (expression -> Type() -> num_dimensions > 255)
bytecode.cpp:    if (expression -> array_initializer_opt)
bytecode.cpp:        InitializeArray(expression -> Type(),
bytecode.cpp:                        expression -> array_initializer_opt, need_value);
bytecode.cpp:        // dimensions are non-negative.
bytecode.cpp:                StripNops(expression -> DimExpr(i) -> expression);
bytecode.cpp:            if (expr -> IsConstant())
bytecode.cpp:                if (DYNAMIC_CAST<IntLiteralValue*> (expr -> value) ->
bytecode.cpp:            else if (expr -> Type() != control.char_type)
bytecode.cpp:            EmitExpression(expression -> DimExpr(j) -> expression,
bytecode.cpp:            EmitNewArray(num_dims, expression -> Type());
bytecode.cpp:        assignment_expression -> left_hand_side -> CastExpressionCast();
bytecode.cpp:                    ? casted_left_hand_side -> expression
bytecode.cpp:                    : assignment_expression -> left_hand_side);
bytecode.cpp:    TypeSymbol* left_type = left_hand_side -> Type();
bytecode.cpp:    VariableSymbol* accessed_member = assignment_expression -> write_method
bytecode.cpp:        ? (assignment_expression -> write_method -> accessed_member ->
bytecode.cpp:    if (assignment_expression -> SimpleAssignment())
bytecode.cpp:            EmitArrayAccessLhs(left_hand_side -> ArrayAccessCast());
bytecode.cpp:            if (left_hand_side -> FieldAccessCast())
bytecode.cpp:                    ((AstFieldAccess*) left_hand_side) -> base;
bytecode.cpp:            else if (left_hand_side -> NameCast())
bytecode.cpp:                AstName* base = ((AstName*) left_hand_side) -> base_opt;
bytecode.cpp:            if (! accessed_member -> ACC_STATIC())
bytecode.cpp:                AstExpression* resolve = left_hand_side -> FieldAccessCast()
bytecode.cpp:                    ? left_hand_side -> FieldAccessCast() -> resolution_opt
bytecode.cpp:                    : left_hand_side -> NameCast() -> resolution_opt;
bytecode.cpp:                    resolve -> MethodInvocationCast() -> base_opt;
bytecode.cpp:            else if (left_hand_side -> FieldAccessCast())
bytecode.cpp:                EmitExpression(((AstFieldAccess*) left_hand_side) -> base,
bytecode.cpp:        EmitExpression(assignment_expression -> expression);
bytecode.cpp:            EmitArrayAccessLhs(left_hand_side -> ArrayAccessCast());
bytecode.cpp:            LoadArrayElement(assignment_expression -> Type());
bytecode.cpp:                assignment_expression -> Type() == control.int_type &&
bytecode.cpp:                assignment_expression -> expression -> IsConstant() &&
bytecode.cpp:                ((assignment_expression -> Tag() ==
bytecode.cpp:                 (assignment_expression -> Tag() ==
bytecode.cpp:                    (assignment_expression -> expression -> value);
bytecode.cpp:                int val = ((assignment_expression -> Tag() ==
bytecode.cpp:                           ? -(vp -> value) // we treat "a -= x" as "a += (-x)"
bytecode.cpp:                           : vp -> value);
bytecode.cpp:                if (val >= -32768 && val < 32768) // if value in range
bytecode.cpp:                        (VariableSymbol*) left_hand_side -> symbol;
bytecode.cpp:                    PutOpIINC(sym -> LocalVariableIndex(), val);
bytecode.cpp:                    return GetTypeWords(assignment_expression -> Type());
bytecode.cpp:            if (accessed_member -> ACC_STATIC())
bytecode.cpp:        if ((assignment_expression -> Tag() ==
bytecode.cpp:            AppendString(assignment_expression -> expression, true);
bytecode.cpp:                                   ? casted_left_hand_side -> Type()
bytecode.cpp:                                   : assignment_expression -> Type());
bytecode.cpp:                switch (assignment_expression -> Tag())
bytecode.cpp:                switch (assignment_expression -> Tag())
bytecode.cpp:                switch (assignment_expression -> Tag())
bytecode.cpp:                switch (assignment_expression -> Tag())
bytecode.cpp:                EmitCast(casted_left_hand_side -> Type(), left_type);
bytecode.cpp:            EmitExpression(assignment_expression -> expression);
bytecode.cpp:                EmitCast(left_type, casted_left_hand_side -> Type());
bytecode.cpp:        StoreArrayElement(assignment_expression -> Type());
bytecode.cpp:                if (accessed_member -> ACC_STATIC())
bytecode.cpp:                               (accessed_member -> ACC_STATIC() ? 0 : 1));
bytecode.cpp:            CompleteCall(assignment_expression -> write_method, stack_words);
bytecode.cpp:        // was not being treated as compatible with a multi-dimensional array
bytecode.cpp:        // time null might be assigned to a multi-dimensional local variable
bytecode.cpp:            (StripNops(assignment_expression -> expression) -> Type() ==
bytecode.cpp:            assert(assignment_expression -> SimpleAssignment());
bytecode.cpp:    return GetTypeWords(assignment_expression -> Type());
bytecode.cpp:    TypeSymbol* type = expression -> Type();
bytecode.cpp:        assert(expression -> Tag() == AstBinaryExpression::PLUS);
bytecode.cpp:    // Next, simplify if no result is needed. Be careful of side-effects with
bytecode.cpp:        if ((expression -> Tag() == AstBinaryExpression::SLASH ||
bytecode.cpp:             expression -> Tag() == AstBinaryExpression::MOD) &&
bytecode.cpp:            (IsZero(expression -> right_expression) ||
bytecode.cpp:             ! expression -> right_expression -> IsConstant()))
bytecode.cpp:            if (IsZero(expression -> right_expression))
bytecode.cpp:                // Undo compiler-inserted numeric promotion.
bytecode.cpp:                AstExpression* left_expr = expression -> left_expression;
bytecode.cpp:                if (left_expr -> CastExpressionCast() &&
bytecode.cpp:                    left_expr -> generated)
bytecode.cpp:                    left_expr = ((AstCastExpression*) left_expr) -> expression;
bytecode.cpp:                type = left_expr -> Type();
bytecode.cpp:                EmitExpression(expression -> left_expression);
bytecode.cpp:                EmitExpression(expression -> right_expression);
bytecode.cpp:                PutOp(expression -> Tag() == AstBinaryExpression::SLASH
bytecode.cpp:                PutOp(expression -> Tag() == AstBinaryExpression::SLASH
bytecode.cpp:        else if (expression -> Tag() == AstBinaryExpression::OR_OR)
bytecode.cpp:            if (expression -> right_expression -> IsConstant())
bytecode.cpp:                EmitExpression(expression -> left_expression, false);
bytecode.cpp:            else if (! IsOne(expression -> left_expression))
bytecode.cpp:                EmitBranchIfExpression(expression -> left_expression, true,
bytecode.cpp:                EmitExpression(expression -> right_expression, false);
bytecode.cpp:        else if (expression -> Tag() == AstBinaryExpression::AND_AND)
bytecode.cpp:            if (expression -> right_expression -> IsConstant())
bytecode.cpp:                EmitExpression(expression -> left_expression, false);
bytecode.cpp:            else if (! IsZero(expression -> left_expression))
bytecode.cpp:                EmitBranchIfExpression(expression -> left_expression, false,
bytecode.cpp:                EmitExpression(expression -> right_expression, false);
bytecode.cpp:            EmitExpression(expression -> left_expression, false);
bytecode.cpp:            EmitExpression(expression -> right_expression, false);
bytecode.cpp:    if (IsZero(expression -> left_expression))
bytecode.cpp:        // Undo compiler-inserted numeric promotion, as well as narrowing from
bytecode.cpp:        AstExpression* right_expr = expression -> right_expression;
bytecode.cpp:        if (right_expr -> CastExpressionCast() && right_expr -> generated)
bytecode.cpp:            right_expr = ((AstCastExpression*) right_expr) -> expression;
bytecode.cpp:        TypeSymbol* right_type = right_expr -> Type();
bytecode.cpp:        switch (expression -> Tag())
bytecode.cpp:            // point, because of -0.0 rules.
bytecode.cpp:                if (expression -> left_expression -> Type() ==
bytecode.cpp:                        (expression -> left_expression -> value);
bytecode.cpp:                    if (value -> value.IsPositiveZero())
bytecode.cpp:                else if (expression -> left_expression -> Type() ==
bytecode.cpp:                        (expression -> left_expression -> value);
bytecode.cpp:                    if (value -> value.IsPositiveZero())
bytecode.cpp:            EmitExpression(expression -> right_expression);
bytecode.cpp:            // of NaN, infinity, and -0.0 rules. And in general, division
bytecode.cpp:            // 0 - x is negation, but note that +0.0 - expr cannot be
bytecode.cpp:            // simplified if expr is floating point, because of -0.0 rules.
bytecode.cpp:                if (expression -> left_expression -> Type() ==
bytecode.cpp:                        (expression -> left_expression -> value);
bytecode.cpp:                    if (value -> value.IsPositiveZero())
bytecode.cpp:                else if (expression -> left_expression -> Type() ==
bytecode.cpp:                        (expression -> left_expression -> value);
bytecode.cpp:                    if (value -> value.IsPositiveZero())
bytecode.cpp:            EmitExpression(expression -> right_expression);
bytecode.cpp:    if (IsOne(expression -> left_expression))
bytecode.cpp:        if (expression -> Tag() == AstBinaryExpression::STAR)
bytecode.cpp:            EmitExpression(expression -> right_expression);
bytecode.cpp:        if (expression -> left_expression -> Type() == control.boolean_type)
bytecode.cpp:            switch (expression -> Tag())
bytecode.cpp:                EmitExpression(expression -> right_expression);
bytecode.cpp:                EmitExpression(expression -> right_expression, false);
bytecode.cpp:                EmitExpression(expression -> right_expression);
bytecode.cpp:    if (IsZero(expression -> right_expression))
bytecode.cpp:        // Undo compiler-inserted numeric promotion to avoid unnecessary type
bytecode.cpp:        AstExpression* left_expr = expression -> left_expression;
bytecode.cpp:        if (left_expr -> CastExpressionCast() && left_expr -> generated)
bytecode.cpp:            left_expr = ((AstCastExpression*) left_expr) -> expression;
bytecode.cpp:        TypeSymbol* left_type = left_expr -> Type();
bytecode.cpp:        switch (expression -> Tag())
bytecode.cpp:            // (expr + +0.0) and (expr - -0.0) cannot be simplified if expr
bytecode.cpp:            // is floating point, because of -0.0 rules.
bytecode.cpp:                if (expression -> right_expression -> Type() ==
bytecode.cpp:                        (expression -> right_expression -> value);
bytecode.cpp:                    if (value -> value.IsPositiveZero() ==
bytecode.cpp:                        (expression -> Tag() == AstBinaryExpression::PLUS))
bytecode.cpp:                else if (expression -> right_expression -> Type() ==
bytecode.cpp:                        (expression -> right_expression -> value);
bytecode.cpp:                    if (value -> value.IsPositiveZero() ==
bytecode.cpp:                        (expression -> Tag() == AstBinaryExpression::PLUS))
bytecode.cpp:            EmitExpression(expression -> left_expression);
bytecode.cpp:            // of NaN, infinity, and -0.0 rules. And in general, division
bytecode.cpp:    if (IsOne(expression -> right_expression))
bytecode.cpp:        if (expression -> Tag() == AstBinaryExpression::STAR ||
bytecode.cpp:            expression -> Tag() == AstBinaryExpression::SLASH)
bytecode.cpp:            EmitExpression(expression -> left_expression);
bytecode.cpp:        if (expression -> right_expression -> Type() == control.boolean_type)
bytecode.cpp:            switch (expression -> Tag())
bytecode.cpp:                EmitExpression(expression -> left_expression);
bytecode.cpp:                EmitExpression(expression -> left_expression, false);
bytecode.cpp:                EmitExpression(expression -> left_expression);
bytecode.cpp:    if (expression -> left_expression -> Type() == control.boolean_type &&
bytecode.cpp:        (expression -> Tag() == AstBinaryExpression::EQUAL_EQUAL ||
bytecode.cpp:         expression -> Tag() == AstBinaryExpression::NOT_EQUAL))
bytecode.cpp:        EmitExpression(expression -> left_expression);
bytecode.cpp:        EmitExpression(expression -> right_expression);
bytecode.cpp:        if (expression -> Tag() == AstBinaryExpression::EQUAL_EQUAL)
bytecode.cpp:    switch (expression -> Tag())
bytecode.cpp:    EmitExpression(expression -> left_expression);
bytecode.cpp:    EmitExpression(expression -> right_expression);
bytecode.cpp:    switch (expression -> Tag())
bytecode.cpp:    return GetTypeWords(expression -> Type());
bytecode.cpp:    TypeSymbol* left_type = expr -> expression -> Type();
bytecode.cpp:    TypeSymbol* right_type = expr -> type -> symbol;
bytecode.cpp:    if (right_type -> num_dimensions > 255)
bytecode.cpp:        semantic.ReportSemError(SemanticError::ARRAY_OVERFLOW, expr -> type);
bytecode.cpp:        EmitExpression(expr -> expression, false);
bytecode.cpp:    else if (expr -> expression -> IsConstant() ||
bytecode.cpp:             expr -> expression -> BinaryExpressionCast())
bytecode.cpp:        // concats are non-null and String is a final class.
bytecode.cpp:        EmitExpression(expr -> expression, false);
bytecode.cpp:    else if ((expr -> expression -> ThisExpressionCast() ||
bytecode.cpp:              expr -> expression -> SuperExpressionCast() ||
bytecode.cpp:              expr -> expression -> ClassLiteralCast() ||
bytecode.cpp:              expr -> expression -> ClassCreationExpressionCast() ||
bytecode.cpp:              expr -> expression -> ArrayCreationExpressionCast()) &&
bytecode.cpp:             left_type -> IsSubtype(right_type))
bytecode.cpp:        // We know the result: true, since the expression is non-null.
bytecode.cpp:        EmitExpression(expr -> expression, false);
bytecode.cpp:        EmitExpression(expr -> expression, need_value);
bytecode.cpp:    TypeSymbol* dest_type = expression -> Type();
bytecode.cpp:    TypeSymbol* source_type = expression -> expression -> Type();
bytecode.cpp:    if (dest_type -> num_dimensions > 255 && expression -> type)
bytecode.cpp:                                expression -> type);
bytecode.cpp:    EmitExpression(expression -> expression,
bytecode.cpp:                   need_value || dest_type -> IsSubtype(source_type));
bytecode.cpp:    if (need_value || dest_type -> IsSubtype(source_type))
bytecode.cpp:            assert(source_type -> IsSubtype(control.Object()));
bytecode.cpp:    if (source_type -> IsSubtype(dest_type) ||
bytecode.cpp:    if (expression -> Type() == control.null_type)
bytecode.cpp:    VariableSymbol* variable = expression -> symbol -> VariableCast();
bytecode.cpp:    if (expression -> ClassCreationExpressionCast() ||
bytecode.cpp:        expression -> ThisExpressionCast() ||
bytecode.cpp:        expression -> SuperExpressionCast() ||
bytecode.cpp:        expression -> ClassLiteralCast() ||
bytecode.cpp:        (variable && variable -> ACC_SYNTHETIC() &&
bytecode.cpp:         variable -> Identity() == control.this_name_symbol))
bytecode.cpp:    // We did not bother checking for other guaranteed non-null conditions:
bytecode.cpp:    // Object, we can be certain it has no side-effects.
bytecode.cpp:    if (expr -> resolution_opt)
bytecode.cpp:        expr = expr -> resolution_opt;
bytecode.cpp:    MethodSymbol* constructor = (MethodSymbol*) expr -> symbol;
bytecode.cpp:    TypeSymbol* type = constructor -> containing_type;
bytecode.cpp:    if (expr -> base_opt)
bytecode.cpp:        EmitCheckForNull(expr -> base_opt);
bytecode.cpp:    if (type -> Anonymous() && type -> super -> EnclosingInstance())
bytecode.cpp:        EmitCheckForNull(expr -> arguments -> Argument(i++));
bytecode.cpp:    for ( ; i < expr -> arguments -> NumArguments(); i++)
bytecode.cpp:        stack_words += EmitExpression(expr -> arguments -> Argument(i));
bytecode.cpp:    for (i = 0; i < expr -> arguments -> NumLocalArguments(); i++)
bytecode.cpp:            EmitExpression(expr -> arguments -> LocalArgument(i));
bytecode.cpp:    if (expr -> arguments -> NeedsExtraNullArgument())
bytecode.cpp:    ChangeStack(-stack_words);
bytecode.cpp:    if (expression -> test_expression -> IsConstant())
bytecode.cpp:        return EmitExpression((IsZero(expression -> test_expression)
bytecode.cpp:                               ? expression -> false_expression
bytecode.cpp:                               : expression -> true_expression),
bytecode.cpp:    if (expression -> Type() == control.null_type)
bytecode.cpp:        if (expression -> false_expression -> NullLiteralCast())
bytecode.cpp:            if (expression -> true_expression -> NullLiteralCast())
bytecode.cpp:                EmitExpression(expression -> test_expression, false);
bytecode.cpp:                EmitBranchIfExpression(expression -> test_expression, false,
bytecode.cpp:                EmitExpression(expression -> true_expression, false);
bytecode.cpp:        if (expression -> true_expression -> NullLiteralCast())
bytecode.cpp:            EmitBranchIfExpression(expression -> test_expression, true, lab);
bytecode.cpp:            EmitExpression(expression -> false_expression, false);
bytecode.cpp:    else if (expression -> true_expression -> IsConstant())
bytecode.cpp:        if (expression -> false_expression -> IsConstant())
bytecode.cpp:                return EmitExpression(expression -> test_expression, false);
bytecode.cpp:            if (expression -> true_expression -> value ==
bytecode.cpp:                expression -> false_expression -> value)
bytecode.cpp:                EmitExpression(expression -> test_expression, false);
bytecode.cpp:                return EmitExpression(expression -> true_expression);
bytecode.cpp:            if (control.IsSimpleIntegerValueType(expression -> Type()) ||
bytecode.cpp:                expression -> Type() == control.boolean_type)
bytecode.cpp:                // Optimize (expr ? value - 1 : value) to (value - expr).
bytecode.cpp:                    (expression -> true_expression -> value);
bytecode.cpp:                    (expression -> false_expression -> value);
bytecode.cpp:                if (left -> value == 1 && right -> value == 0)
bytecode.cpp:                    return EmitExpression(expression -> test_expression);
bytecode.cpp:                if (left -> value == right -> value + 1)
bytecode.cpp:                    EmitExpression(expression -> test_expression);
bytecode.cpp:                    EmitExpression(expression -> false_expression);
bytecode.cpp:                if (left -> value == right -> value - 1)
bytecode.cpp:                    EmitExpression(expression -> false_expression);
bytecode.cpp:                    EmitExpression(expression -> test_expression);
bytecode.cpp:        else if ((control.IsSimpleIntegerValueType(expression -> Type()) ||
bytecode.cpp:                  expression -> Type() == control.boolean_type) &&
bytecode.cpp:                 (IsOne(expression -> true_expression) ||
bytecode.cpp:                  IsZero(expression -> true_expression)))
bytecode.cpp:                PutOp(IsZero(expression -> true_expression)
bytecode.cpp:            EmitBranchIfExpression(expression -> test_expression, true, label);
bytecode.cpp:            EmitExpression(expression -> false_expression, need_value);
bytecode.cpp:    else if ((control.IsSimpleIntegerValueType(expression -> Type()) ||
bytecode.cpp:              expression -> Type() == control.boolean_type) &&
bytecode.cpp:             (IsOne(expression -> false_expression) ||
bytecode.cpp:              IsZero(expression -> false_expression)))
bytecode.cpp:            PutOp(IsZero(expression -> false_expression)
bytecode.cpp:        EmitBranchIfExpression(expression -> test_expression, false, label);
bytecode.cpp:        EmitExpression(expression -> true_expression, need_value);
bytecode.cpp:    EmitBranchIfExpression(expression -> test_expression, false, lab1);
bytecode.cpp:    EmitExpression(expression -> true_expression, need_value);
bytecode.cpp:        ChangeStack(- GetTypeWords(expression -> Type()));
bytecode.cpp:    EmitExpression(expression -> false_expression, need_value);
bytecode.cpp:    return GetTypeWords(expression -> true_expression -> Type());
bytecode.cpp:    if (expression -> resolution_opt)
bytecode.cpp:    VariableSymbol* sym = expression -> symbol -> VariableCast();
bytecode.cpp:    return LoadVariable(sym -> ACC_STATIC() ? STATIC_VAR : FIELD_VAR,
bytecode.cpp:    AstMethodInvocation* method_call = expression -> resolution_opt
bytecode.cpp:        ? expression -> resolution_opt -> MethodInvocationCast() : expression;
bytecode.cpp:    MethodSymbol* msym = (MethodSymbol*) method_call -> symbol;
bytecode.cpp:    AstExpression* base = method_call -> base_opt;
bytecode.cpp:    if (msym -> ACC_STATIC())
bytecode.cpp:        if (base && (! msym -> accessed_member ||
bytecode.cpp:                      msym -> AccessesStaticMember()))
bytecode.cpp:            is_super = base -> SuperExpressionCast() != NULL;
bytecode.cpp:    for (unsigned i = 0; i < method_call -> arguments -> NumArguments(); i++)
bytecode.cpp:        stack_words += EmitExpression(method_call -> arguments -> Argument(i));
bytecode.cpp:    TypeSymbol* type = MethodTypeResolution(method_call -> base_opt, msym);
bytecode.cpp:    PutOp(msym -> ACC_STATIC() ? OP_INVOKESTATIC
bytecode.cpp:          : (is_super || msym -> ACC_PRIVATE()) ? OP_INVOKESPECIAL
bytecode.cpp:          : type -> ACC_INTERFACE() ? OP_INVOKEINTERFACE
bytecode.cpp:    ChangeStack(- stack_words);
bytecode.cpp:    TypeSymbol* type = (base_type ? base_type : msym -> containing_type);
bytecode.cpp:    if (type -> ACC_INTERFACE())
bytecode.cpp:    if (msym -> Type() == control.void_type)
bytecode.cpp:    bool wide = control.IsDoubleWordType(msym -> Type());
bytecode.cpp:    while (! expr -> IsConstant())
bytecode.cpp:        if (expr -> ParenthesizedExpressionCast())
bytecode.cpp:            expr = ((AstParenthesizedExpression*) expr) -> expression;
bytecode.cpp:        else if (expr -> CastExpressionCast())
bytecode.cpp:            TypeSymbol* cast_type = expr -> Type();
bytecode.cpp:            AstExpression* sub_expr = StripNops(cast_expr -> expression);
bytecode.cpp:            TypeSymbol* sub_type = sub_expr -> Type();
bytecode.cpp:            if (sub_type -> IsSubtype(cast_type) ||
bytecode.cpp:                 cast_type -> num_dimensions <= 255))
bytecode.cpp:    for (int i = block -> NumStatements() - 1; i >= 0; i--)
bytecode.cpp:        Ast* statement = block -> Statement(i);
bytecode.cpp:        if (statement -> EmptyStatementCast() ||
bytecode.cpp:            statement -> LocalClassStatementCast() ||
bytecode.cpp:            (statement -> BlockCast() && IsNop((AstBlock*) statement)))
bytecode.cpp:        if (statement -> kind == Ast::IF)
bytecode.cpp:            if ((IsOne(ifstat -> expression) &&
bytecode.cpp:                 IsNop(ifstat -> true_statement)) ||
bytecode.cpp:                (IsZero(ifstat -> expression) &&
bytecode.cpp:                 (! ifstat -> false_statement_opt ||
bytecode.cpp:                  IsNop(ifstat -> false_statement_opt))))
bytecode.cpp:        TypeSymbol* element_type = type -> ArraySubtype();
bytecode.cpp:        ChangeStack(1 - num_dims);
bytecode.cpp:    TypeSymbol* base_type = expression -> base -> Type();
bytecode.cpp:    AstExpression* base = StripNops(expression -> base);
bytecode.cpp:        base -> Type() == control.null_type)
bytecode.cpp:        // was not being treated as compatible with a multi-dimensional array
bytecode.cpp:        // time null might be assigned to a multi-dimensional local variable
bytecode.cpp:    EmitExpression(expression -> expression);
bytecode.cpp:                expression -> write_method -> accessed_member -> VariableCast();
bytecode.cpp:            if (accessed_member -> ACC_STATIC())
bytecode.cpp:    return GetTypeWords(expression -> Type());
bytecode.cpp:        ResolveAccess(expression -> expression); // get address and value
bytecode.cpp:    else EmitFieldAccessLhs(expression -> expression);
bytecode.cpp:    TypeSymbol* expression_type = expression -> Type();
bytecode.cpp:        PutOp(expression -> Tag() == AstPostUnaryExpression::PLUSPLUS
bytecode.cpp:        PutOp(expression -> Tag() == AstPostUnaryExpression::PLUSPLUS
bytecode.cpp:        PutOp(expression -> Tag() == AstPostUnaryExpression::PLUSPLUS
bytecode.cpp:        PutOp(expression -> Tag() == AstPostUnaryExpression::PLUSPLUS
bytecode.cpp:        CompleteCall(expression -> write_method, stack_words);
bytecode.cpp:            ChangeStack(-1);
bytecode.cpp:        VariableSymbol* sym = (VariableSymbol*) expression -> symbol;
bytecode.cpp:        PutU2(RegisterFieldref(VariableTypeResolution(expression ->
bytecode.cpp:    TypeSymbol* expression_type = expression -> Type();
bytecode.cpp:        LoadVariable(kind, StripNops(expression -> expression), need_value);
bytecode.cpp:        PutOpIINC(expression -> symbol -> VariableCast() -> LocalVariableIndex(),
bytecode.cpp:                  expression -> Tag() == AstPostUnaryExpression::PLUSPLUS ? 1 : -1);
bytecode.cpp:    LoadVariable(kind, StripNops(expression -> expression));
bytecode.cpp:        PutOp(expression -> Tag() == AstPostUnaryExpression::PLUSPLUS
bytecode.cpp:        PutOp(expression -> Tag() == AstPostUnaryExpression::PLUSPLUS
bytecode.cpp:        PutOp(expression -> Tag() == AstPostUnaryExpression::PLUSPLUS
bytecode.cpp:        PutOp(expression -> Tag() == AstPostUnaryExpression::PLUSPLUS
bytecode.cpp:         CompleteCall(expression -> write_method, stack_words);
bytecode.cpp:    else StoreVariable(kind, expression -> expression);
bytecode.cpp:    EmitArrayAccessLhs((AstArrayAccess*) StripNops(expression -> expression));
bytecode.cpp:    TypeSymbol* expression_type = expression -> Type();
bytecode.cpp:         PutOp(expression -> Tag() == AstPostUnaryExpression::PLUSPLUS
bytecode.cpp:         PutOp(expression -> Tag() == AstPostUnaryExpression::PLUSPLUS
bytecode.cpp:         PutOp(expression -> Tag() == AstPostUnaryExpression::PLUSPLUS
bytecode.cpp:         PutOp(expression -> Tag() == AstPostUnaryExpression::PLUSPLUS
bytecode.cpp:         PutOp(expression -> Tag() == AstPostUnaryExpression::PLUSPLUS
bytecode.cpp:         PutOp(expression -> Tag() == AstPostUnaryExpression::PLUSPLUS
bytecode.cpp:         PutOp(expression -> Tag() == AstPostUnaryExpression::PLUSPLUS
bytecode.cpp:    TypeSymbol* type = expression -> Type();
bytecode.cpp:    if (expression -> Tag() == AstPreUnaryExpression::PLUSPLUS ||
bytecode.cpp:        expression -> Tag() == AstPreUnaryExpression::MINUSMINUS)
bytecode.cpp:        EmitExpression(expression -> expression, need_value);
bytecode.cpp:        switch (expression -> Tag())
bytecode.cpp:                PutOp(OP_ICONST_M1); // -1
bytecode.cpp:                PutOp(OP_LCONST_1); // make -1
bytecode.cpp:// PRE_UNARY with side effects (++X or --X)
bytecode.cpp:                expression -> write_method -> accessed_member -> VariableCast();
bytecode.cpp:            if (accessed_member -> ACC_STATIC())
bytecode.cpp:    TypeSymbol* type = expression -> Type();
bytecode.cpp:        PutOpIINC(expression -> symbol -> VariableCast() -> LocalVariableIndex(),
bytecode.cpp:                  expression -> Tag() == AstPreUnaryExpression::PLUSPLUS ? 1 : -1);
bytecode.cpp:        LoadVariable(kind, StripNops(expression -> expression), need_value);
bytecode.cpp:    LoadVariable(kind, StripNops(expression -> expression));
bytecode.cpp:        PutOp(expression -> Tag() == AstPreUnaryExpression::PLUSPLUS
bytecode.cpp:        PutOp(expression -> Tag() == AstPreUnaryExpression::PLUSPLUS
bytecode.cpp:        PutOp(expression -> Tag() == AstPreUnaryExpression::PLUSPLUS
bytecode.cpp:        PutOp(expression -> Tag() == AstPreUnaryExpression::PLUSPLUS
bytecode.cpp:        CompleteCall(expression -> write_method, stack_words);
bytecode.cpp:    else StoreVariable(kind, expression -> expression);
bytecode.cpp:    EmitArrayAccessLhs((AstArrayAccess*) StripNops(expression -> expression));
bytecode.cpp:    TypeSymbol* type = expression -> Type();
bytecode.cpp:         PutOp(expression -> Tag() == AstPreUnaryExpression::PLUSPLUS
bytecode.cpp:         PutOp(expression -> Tag() == AstPreUnaryExpression::PLUSPLUS
bytecode.cpp:         PutOp(expression -> Tag() == AstPreUnaryExpression::PLUSPLUS
bytecode.cpp:         PutOp(expression -> Tag() == AstPreUnaryExpression::PLUSPLUS
bytecode.cpp:         PutOp(expression -> Tag() == AstPreUnaryExpression::PLUSPLUS
bytecode.cpp:         PutOp(expression -> Tag() == AstPreUnaryExpression::PLUSPLUS
bytecode.cpp:         PutOp(expression -> Tag() == AstPreUnaryExpression::PLUSPLUS
bytecode.cpp:        ResolveAccess(expression -> expression); // get address and value
bytecode.cpp:        EmitFieldAccessLhs(expression -> expression);
bytecode.cpp:    TypeSymbol* expression_type = expression -> Type();
bytecode.cpp:        PutOp(expression -> Tag() == AstPreUnaryExpression::PLUSPLUS
bytecode.cpp:        PutOp(expression -> Tag() == AstPreUnaryExpression::PLUSPLUS
bytecode.cpp:        PutOp(expression -> Tag() == AstPreUnaryExpression::PLUSPLUS
bytecode.cpp:        PutOp(expression -> Tag() == AstPreUnaryExpression::PLUSPLUS
bytecode.cpp:        CompleteCall(expression -> write_method, stack_words);
bytecode.cpp:            ChangeStack(-1);
bytecode.cpp:        VariableSymbol* sym = (VariableSymbol*) expression -> symbol;
bytecode.cpp:        PutU2(RegisterFieldref(VariableTypeResolution(expression ->
bytecode.cpp:    if (unit_type -> EnclosingType())
bytecode.cpp:        LoadLocal(++stack_words, unit_type -> EnclosingType());
bytecode.cpp:    for (unsigned k = 0; k < this_call -> arguments -> NumArguments(); k++)
bytecode.cpp:        stack_words += EmitExpression(this_call -> arguments -> Argument(k));
bytecode.cpp:        for (unsigned i = 0; i < unit_type -> NumConstructorParameters(); i++)
bytecode.cpp:            VariableSymbol* shadow = unit_type -> ConstructorParameter(i);
bytecode.cpp:            LoadLocal(offset, shadow -> Type());
bytecode.cpp:            int words = GetTypeWords(shadow -> Type());
bytecode.cpp:    ChangeStack(-stack_words);
bytecode.cpp:    PutU2(RegisterMethodref(unit_type, this_call -> symbol));
bytecode.cpp:    if (super_call -> base_opt)
bytecode.cpp:        if (unit_type -> Anonymous())
bytecode.cpp:            // Special case - the null check was done during the class instance
bytecode.cpp:            EmitExpression(super_call -> base_opt);
bytecode.cpp:        else EmitCheckForNull(super_call -> base_opt);
bytecode.cpp:    for (i = 0; i < super_call -> arguments -> NumArguments(); i++)
bytecode.cpp:        stack_words += EmitExpression(super_call -> arguments -> Argument(i));
bytecode.cpp:    for (i = 0; i < super_call -> arguments -> NumLocalArguments(); i++)
bytecode.cpp:            EmitExpression(super_call -> arguments -> LocalArgument(i));
bytecode.cpp:    if (super_call -> arguments -> NeedsExtraNullArgument())
bytecode.cpp:    ChangeStack(-stack_words);
bytecode.cpp:    PutU2(RegisterMethodref(unit_type -> super, super_call -> symbol));
bytecode.cpp:    AstExpression* left_expr = StripNops(expression -> left_expression);
bytecode.cpp:    if (left_expr -> Type() == control.String() &&
bytecode.cpp:        left_expr -> BinaryExpressionCast() &&
bytecode.cpp:        ! left_expr -> IsConstant())
bytecode.cpp:        if (left_expr -> IsConstant())
bytecode.cpp:                DYNAMIC_CAST<Utf8LiteralValue*> (left_expr -> value);
bytecode.cpp:            if (value -> length == 0 || ! need_value)
bytecode.cpp:                ChangeStack(-1); // account for the argument
bytecode.cpp:            AppendString(expression -> left_expression, need_value);
bytecode.cpp:    AppendString(expression -> right_expression, need_value);
bytecode.cpp:    // Grab the type before reducing no-ops, in the case of ""+(int)char.
bytecode.cpp:    TypeSymbol* type = expression -> Type();
bytecode.cpp:    if (expression -> IsConstant())
bytecode.cpp:            DYNAMIC_CAST<Utf8LiteralValue*> (expression -> value);
bytecode.cpp:        if (value -> length == 0 || ! need_value)
bytecode.cpp:        if (value -> length == 1)
bytecode.cpp:            LoadImmediateInteger(value -> value[0]);
bytecode.cpp:        else if (value -> length == 2 &&
bytecode.cpp:                 (value -> value[0] & 0x00E0) == 0x00C0)
bytecode.cpp:            // 2-byte string in UTF-8, but still single character.
bytecode.cpp:            LoadImmediateInteger(((value -> value[0] & 0x001F) << 6) |
bytecode.cpp:                                 (value -> value[1] & 0x003F));
bytecode.cpp:        else if (value -> length == 3 &&
bytecode.cpp:                 (value -> value[0] & 0x00E0) == 0x00E0)
bytecode.cpp:            // 3-byte string in UTF-8, but still single character.
bytecode.cpp:            LoadImmediateInteger(((value -> value[0] & 0x000F) << 12) |
bytecode.cpp:                                 ((value -> value[1] & 0x003F) << 6) |
bytecode.cpp:                                 (value -> value[2] & 0x003F));
bytecode.cpp:            expression -> BinaryExpressionCast();
bytecode.cpp:            assert(binary_expression -> Tag() == AstBinaryExpression::PLUS);
bytecode.cpp:            AppendString(binary_expression -> left_expression, need_value);
bytecode.cpp:            AppendString(binary_expression -> right_expression, need_value);
bytecode.cpp:            // Optimization: appending non-Object is no-op if result is unused.
bytecode.cpp:        ChangeStack(-1);
bytecode.cpp:    , control(type -> semantic_environment -> sem -> control)
bytecode.cpp:    , semantic(*type -> semantic_environment -> sem)
bytecode.cpp:    // strictfp. Also, a non-access flag, the super bit, must be set for
bytecode.cpp:    // classes but not interfaces. For top-level types, this changes nothing
bytecode.cpp:    SetFlags(unit_type -> Flags());
bytecode.cpp:    if (! unit_type -> ACC_INTERFACE())
bytecode.cpp:		<< unit_type -> fully_qualified_name -> value << " as version "
bytecode.cpp:    super_class = (unit_type -> super ? RegisterClass(unit_type -> super) : 0);
bytecode.cpp:    for (unsigned k = 0; k < unit_type -> NumInterfaces(); k++)
bytecode.cpp:        interfaces.Next() = RegisterClass(unit_type -> Interface(k));
bytecode.cpp:    // two-pass algorithm with straight-forward emission the first time, and
bytecode.cpp:    // try-finally, or in private methods); and might allow us to finally
bytecode.cpp:    // implement the -O option as more than a no-op.
bytecode.cpp:    int index = lab.uses.Length() - 1;
bytecode.cpp:        int start = luse - lab.uses[index].op_offset;
bytecode.cpp:            code_attribute -> CodeLength() != last_label_pc)
bytecode.cpp:            code_attribute -> DeleteCode(lab.uses[index].op_offset +
bytecode.cpp:            line_number_table_attribute -> SetMax(start);
bytecode.cpp:    lab.definition = code_attribute -> CodeLength();
bytecode.cpp:        // Sanity check - when completing method, make sure nothing jumps out
bytecode.cpp:        if (lab.definition > code_attribute -> CodeLength())
bytecode.cpp:            lab.definition = code_attribute -> CodeLength();
bytecode.cpp:        // as 16-bit signed offset.
bytecode.cpp:            int start = luse - lab.uses[i].op_offset,
bytecode.cpp:                offset = lab.definition - start;
bytecode.cpp:                assert(offset < 32768 && offset >= -32768 &&
bytecode.cpp:                code_attribute -> ResetCode(luse, (offset >> 8) & 0xFF);
bytecode.cpp:                code_attribute -> ResetCode(luse + 1, offset & 0xFF);
bytecode.cpp:                code_attribute -> ResetCode(luse, (offset >> 24) & 0xFF);
bytecode.cpp:                code_attribute -> ResetCode(luse + 1, (offset >> 16) & 0xFF);
bytecode.cpp:                code_attribute -> ResetCode(luse + 2, (offset >>  8) & 0xFF);
bytecode.cpp:                code_attribute -> ResetCode(luse + 3, offset & 0xFF);
bytecode.cpp:    lab.uses[lab_index].use_offset = code_attribute -> CodeLength();
bytecode.cpp:        code_attribute -> AddCode(0);
bytecode.cpp:        LoadImmediateInteger(vp -> value);
bytecode.cpp:        if (vp -> value == 0)
bytecode.cpp:        else if (vp -> value == 1)
bytecode.cpp:        else if (vp -> value >= -1 && vp -> value <= 5)
bytecode.cpp:            LoadImmediateInteger(vp -> value.LowWord());
bytecode.cpp:        IEEEfloat val = vp -> value;
bytecode.cpp:        else if (val == -1.0f)
bytecode.cpp:        IEEEdouble val = vp -> value;
bytecode.cpp:        else if (val == -1.0)
bytecode.cpp:    if (val >= -1 && val <= 5)
bytecode.cpp:    else if (val >= -128 && val < 128)
bytecode.cpp:    else if (val >= -32768 && val < 32768)
bytecode.cpp:// Call to an access method for a compound operator such as ++, --,
bytecode.cpp:    AstFieldAccess* field = p -> FieldAccessCast();
bytecode.cpp:    AstExpression* resolve_expression = field ? field -> resolution_opt
bytecode.cpp:        : p -> NameCast() -> resolution_opt;
bytecode.cpp:        resolve_expression -> MethodInvocationCast();
bytecode.cpp:    assert(read_method && read_method -> arguments -> NumArguments() == 1);
bytecode.cpp:    int stack_words = EmitExpression(read_method -> arguments -> Argument(0));
bytecode.cpp:    CompleteCall(read_method -> symbol -> MethodCast(), stack_words);
bytecode.cpp:    VariableSymbol* sym = (VariableSymbol*) expr -> symbol;
bytecode.cpp:    TypeSymbol* expression_type = expr -> Type();
bytecode.cpp:    AstFieldAccess* field_access = expr -> FieldAccessCast();
bytecode.cpp:    AstName* name = expr -> NameCast();
bytecode.cpp:    AstExpression* base = name ? name -> base_opt : field_access -> base;
bytecode.cpp:        if (expr -> IsConstant())
bytecode.cpp:            LoadLiteral(expr -> value, expression_type);
bytecode.cpp:        else LoadLocal(sym -> LocalVariableIndex(), expression_type);
bytecode.cpp:            MethodSymbol* method = expr -> symbol -> MethodCast();
bytecode.cpp:            if (! need_value && method && method -> AccessesStaticMember())
bytecode.cpp:            return EmitExpression((name ? name -> resolution_opt
bytecode.cpp:                                   : field_access -> resolution_opt),
bytecode.cpp:        assert(sym -> IsInitialized() || ! sym -> ACC_FINAL());
bytecode.cpp:        if (shadow_parameter_offset && sym -> owner == unit_type &&
bytecode.cpp:            (sym -> accessed_local ||
bytecode.cpp:             sym -> Identity() == control.this_name_symbol))
bytecode.cpp:            if (! sym -> accessed_local)
bytecode.cpp:                 i < unit_type -> NumConstructorParameters(); i++)
bytecode.cpp:                VariableSymbol* shadow = unit_type -> ConstructorParameter(i);
bytecode.cpp:                offset += GetTypeWords(shadow -> Type());
bytecode.cpp:        if (base && base -> Type() -> IsArray())
bytecode.cpp:            assert(sym -> name_symbol == control.length_name_symbol);
bytecode.cpp:            if (base -> ArrayCreationExpressionCast() && ! need_value)
bytecode.cpp:        if (sym -> initial_value)
bytecode.cpp:                LoadLiteral(sym -> initial_value, expression_type);
bytecode.cpp:        if (need_value || sym -> ACC_VOLATILE())
bytecode.cpp:            if (sym -> initial_value)
bytecode.cpp:                LoadLiteral(sym -> initial_value, expression_type);
bytecode.cpp:    VariableSymbol* sym = (VariableSymbol*) expression -> symbol;
bytecode.cpp:    TypeSymbol* expression_type = expression -> Type();
bytecode.cpp:    if (sym -> ACC_STATIC())
bytecode.cpp:        ChangeStack(1 - GetTypeWords(expression_type));
bytecode.cpp:        ChangeStack(1 - GetTypeWords(expression_type));
bytecode.cpp:    VariableSymbol* sym = (VariableSymbol*) expr -> symbol;
bytecode.cpp:        StoreLocal(sym -> LocalVariableIndex(), sym -> Type());
bytecode.cpp:            if (sym -> ACC_STATIC())
bytecode.cpp:                ChangeStack(1 - GetTypeWords(expr -> Type()));
bytecode.cpp:                ChangeStack(1 - GetTypeWords(expr -> Type()));
bytecode.cpp:// Finish off code by writing remaining type-level attributes.
bytecode.cpp:    // Only output SourceFile attribute if -g:source is enabled.
bytecode.cpp:                      RegisterUtf8(unit_type -> file_symbol ->
bytecode.cpp:    if (unit_type -> IsDeprecated())
bytecode.cpp:    if (unit_type -> ACC_SYNTHETIC() &&
bytecode.cpp:    if (unit_type -> owner -> MethodCast())
bytecode.cpp:        MethodSymbol* enclosing = (MethodSymbol*) unit_type -> owner;
bytecode.cpp:    unsigned i = unit_type -> NumNestedTypes();
bytecode.cpp:    while (i--)
bytecode.cpp:        RegisterClass(unit_type -> NestedType(i));
bytecode.cpp:        code_attribute -> CodeLength() == (u2) control.option.debug_trap_op)
bytecode.cpp:    last_op_pc = code_attribute -> CodeLength();
bytecode.cpp:    code_attribute -> AddCode(opc);
bytecode.cpp:    if (var <= 255 && (val >= -128 && val <= 127))  // if can use standard form
bytecode.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
bytecode.h:        assert(block -> nesting_level < stack_size &&
bytecode.h:                (block -> nesting_level > nesting_level[top_index - 1])));
bytecode.h:        nesting_level[top_index] = block -> nesting_level;
bytecode.h:        break_labels[block -> nesting_level].uses.Reset();
bytecode.h:        continue_labels[block -> nesting_level].uses.Reset();
bytecode.h:        finally_labels[block -> nesting_level].uses.Reset();
bytecode.h:        handler_range_start[block -> nesting_level].Reset();
bytecode.h:        handler_range_end[block -> nesting_level].Reset();
bytecode.h:        blocks[block -> nesting_level] = block;
bytecode.h:            memset(local_variables_start_pc[block -> nesting_level],
bytecode.h:            top_index--;
bytecode.h:        return nesting_level[top_index - 1];
bytecode.h:        assert(variable -> LocalVariableIndex() >= 0 &&
bytecode.h:               variable -> LocalVariableIndex() < (int) size);
bytecode.h:        return TopLocalVariablesStartPc()[variable -> LocalVariableIndex()];
bytecode.h:    // This variable is non-zero only in constructors of local classes; it
bytecode.h:    // Does p refer to a non-null reference type?
bytecode.h:        return ! p -> Primitive() && p != control.null_type;
bytecode.h:        return p -> num_dimensions > 1 ||
bytecode.h:            p -> base_type == control.Object() ||
bytecode.h:            p -> base_type == control.Cloneable() ||
bytecode.h:            p -> base_type == control.Serializable();
bytecode.h:    // See if operand is constant zero (including -0.0).
bytecode.h:        TypeSymbol* type = p -> Type();
bytecode.h:        if (p -> IsConstant() && type != control.String())
bytecode.h:                return (DYNAMIC_CAST<IntLiteralValue*> (p -> value)) ->
bytecode.h:                return (DYNAMIC_CAST<LongLiteralValue*> (p -> value)) ->
bytecode.h:                return (DYNAMIC_CAST<FloatLiteralValue*> (p -> value)) ->
bytecode.h:                return (DYNAMIC_CAST<DoubleLiteralValue*> (p -> value)) ->
bytecode.h:        TypeSymbol* type = p -> Type();
bytecode.h:        if (p -> IsConstant() && type != control.String())
bytecode.h:                return (DYNAMIC_CAST<IntLiteralValue*> (p -> value)) ->
bytecode.h:                return (DYNAMIC_CAST<LongLiteralValue*> (p -> value)) ->
bytecode.h:                return (DYNAMIC_CAST<FloatLiteralValue*> (p -> value)) ->
bytecode.h:                return (DYNAMIC_CAST<DoubleLiteralValue*> (p -> value)) ->
bytecode.h:            expression -> AssignmentExpressionCast();
bytecode.h:        AstPreUnaryExpression* pre = expression -> PreUnaryExpressionCast();
bytecode.h:        AstPostUnaryExpression* post = expression -> PostUnaryExpressionCast();
bytecode.h:                              ? (assignment -> write_method
bytecode.h:                                 : assignment -> left_hand_side)
bytecode.h:                              ? (pre -> write_method
bytecode.h:                                 ? (AstExpression*) NULL : pre -> expression)
bytecode.h:                              ? (post -> write_method
bytecode.h:                                 ? (AstExpression*) NULL : post -> expression)
bytecode.h:        if (lhs && lhs -> CastExpressionCast())
bytecode.h:            lhs = ((AstCastExpression*) lhs) -> expression;
bytecode.h:        while (lhs && lhs -> ParenthesizedExpressionCast())
bytecode.h:            lhs = ((AstParenthesizedExpression*) lhs) -> expression;
bytecode.h:        Symbol* sym = lhs ? lhs -> symbol : (Symbol*) NULL;
bytecode.h:        // If the expression associated with the left-hand side is null,
bytecode.h:        // then we have an access method. Otherwise, a left-hand side is
bytecode.h:        // a FieldAccess or name, the left-hand side is resolved into a
bytecode.h:        VariableSymbol* var = (sym ? sym -> VariableCast()
bytecode.h:                : var -> owner -> MethodCast() ? LOCAL_VAR
bytecode.h:                : var -> ACC_STATIC() ? STATIC_VAR
bytecode.h:        u2 index = name_and_type_constant_pool_index ->
bytecode.h:            Image(name -> index, type_name -> index);
bytecode.h:            name_and_type_constant_pool_index ->
bytecode.h:                Image(name -> index, type_name -> index) = index;
bytecode.h:        Utf8LiteralValue* class_name = type -> fully_qualified_name;
bytecode.h:            variable -> ExternalIdentity() -> Utf8_literal;
bytecode.h:        Utf8LiteralValue* field_type_name = variable -> signature;
bytecode.h:        assert(variable -> owner -> TypeCast());
bytecode.h:        u2 index = fieldref_constant_pool_index ->
bytecode.h:            Image(class_name -> index, name_type_index);
bytecode.h:            fieldref_constant_pool_index ->
bytecode.h:                Image(class_name -> index, name_type_index) = index;
bytecode.h:        return RegisterFieldref(variable -> ContainingType(), variable);
bytecode.h:        CPInfo::ConstantPoolTag kind = type -> ACC_INTERFACE()
bytecode.h:        Utf8LiteralValue* class_name = type -> fully_qualified_name;
bytecode.h:            method -> ExternalIdentity() -> Utf8_literal;
bytecode.h:        Utf8LiteralValue* method_type = method -> signature;
bytecode.h:        u2 index = methodref_constant_pool_index ->
bytecode.h:            Image(class_name -> index, name_type_index);
bytecode.h:            methodref_constant_pool_index -> Image(class_name -> index,
bytecode.h:            return RegisterMethodref(method -> containing_type, method);
bytecode.h:        u2 index = (*double_constant_pool_index)[lit -> index];
bytecode.h:            (*double_constant_pool_index)[lit -> index] = index;
bytecode.h:            constant_pool.SetNext(new CPDoubleInfo(lit -> value.HighWord(),
bytecode.h:                                                   lit -> value.LowWord()));
bytecode.h:        u2 index = (*integer_constant_pool_index)[lit -> index];
bytecode.h:            (*integer_constant_pool_index)[lit -> index] = index;
bytecode.h:            constant_pool.SetNext(new CPIntegerInfo((u4) lit -> value));
bytecode.h:                ? (*integer_constant_pool_index)[lit -> index] : 0);
bytecode.h:        u2 index = (*long_constant_pool_index)[lit -> index];
bytecode.h:            (*long_constant_pool_index)[lit -> index] = index;
bytecode.h:            constant_pool.SetNext(new CPLongInfo(lit -> value.HighWord(),
bytecode.h:                                                 lit -> value.LowWord()));
bytecode.h:        u2 index = (*float_constant_pool_index)[lit -> index];
bytecode.h:            (*float_constant_pool_index)[lit -> index] = index;
bytecode.h:            constant_pool.SetNext(new CPFloatInfo(lit -> value.Word()));
bytecode.h:        u2 index = utf8_constant_pool_index[lit -> index];
bytecode.h:            utf8_constant_pool_index[lit -> index] = index;
bytecode.h:            constant_pool.SetNext(new CPUtf8Info(lit -> value,
bytecode.h:                                                 lit -> length));
bytecode.h:            if (lit -> length > 0xffff)
bytecode.h:        return RegisterUtf8(sym -> Utf8_literal);
bytecode.h:        u2 index = (*string_constant_pool_index)[lit -> index];
bytecode.h:            (*string_constant_pool_index)[lit -> index] = index;
bytecode.h:        Utf8LiteralValue* lit = type -> num_dimensions
bytecode.h:            ? type -> signature : type -> fully_qualified_name;
bytecode.h:        u2 index = class_constant_pool_index[lit -> index];
bytecode.h:            class_constant_pool_index[lit -> index] = index;
bytecode.h:            if (type -> IsNested())
bytecode.h:                AccessFlags flags = type -> Flags();
bytecode.h:                inner_classes_attribute ->
bytecode.h:                    AddInnerClass(index, type -> IsLocal() ? 0
bytecode.h:                                  : RegisterClass(type -> ContainingType()),
bytecode.h:                                  type -> Anonymous() ? 0
bytecode.h:                                  : RegisterName(type -> name_symbol), flags);
bytecode.h:        u2 type_index = RegisterClass(sym -> containing_type);
bytecode.h:            (sym -> name_symbol == control.block_init_name_symbol ||
bytecode.h:             sym -> name_symbol == control.clinit_name_symbol) ? 0
bytecode.h:            : RegisterNameAndType(sym -> ExternalIdentity() -> Utf8_literal,
bytecode.h:                                  sym -> signature);
bytecode.h:        return LoadArrayElement(expression -> Type());
bytecode.h:        // we must treat even-odd and odd-even pairs differently.
bytecode.h:        return (Opcode) (((opc + 1) ^ 1) - 1);
bytecode.h:        code_attribute -> AddCode(i & 0xff);
bytecode.h:        code_attribute -> AddCode((i >> 8) & 0xff);
bytecode.h:        code_attribute -> AddCode(i & 0xff);
bytecode.h:        code_attribute -> AddCode(u & 0xff);
bytecode.h:        code_attribute -> AddCode((u >> 8) & 0xff);
bytecode.h:        code_attribute -> AddCode(u & 0xff);
bytecode.h:        code_attribute -> AddCode((u >> 24));
bytecode.h:        code_attribute -> AddCode((u >> 16) & 0xff);
bytecode.h:        code_attribute -> AddCode((u >>  8) & 0xff);
bytecode.h:        code_attribute -> AddCode(u & 0xff);
Binary file bytecode.o matches
case.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
case.h:// NOTE that this class is hard-wired to work on an ASCII machine.
case.h:// make the array "lower" non-static. In such a case, each object
case.h:    // string. If the character is not found, return -1.
case.h:        return -1;
case.h:        return -1;
case.h:    // Compare two null-terminated character strings, s1 and s2
Binary file case.o matches
class.cpp:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $
class.cpp:    if (constant -> Large())
class.cpp:        if (entry && ! entry -> Check(*this))
class.cpp:            // non-printing ASCII
class.cpp:            if (bytes[i] <= 0x7f) // 1-byte (printing ASCII, if JIKES_DEBUG)
class.cpp:            else if (bytes[i] <= 0xdf) // 2-byte source
class.cpp:                u2 value = (bytes[i - 1] & 0x1f) << 6;
class.cpp:            else // 3-byte source
class.cpp:                u2 value = (bytes[i - 2] & 0x0f) << 12;
class.cpp:                value |= (bytes[i - 1] & 0x3f) << 6;
class.cpp:    while (count--)
class.cpp:        switch (attr -> Tag())
class.cpp:    assert(pool[descriptor_index] -> Tag() == CPInfo::CONSTANT_Utf8);
class.cpp:        ? attr_signature -> Signature(pool)
class.cpp:    return sig -> Bytes();
class.cpp:    assert(pool[descriptor_index] -> Tag() == CPInfo::CONSTANT_Utf8);
class.cpp:        ? attr_signature -> Signature(pool)
class.cpp:    return sig -> Length();
class.cpp:    while (count--)
class.cpp:        switch (attr -> Tag())
class.cpp:                buffer.MarkInvalid("annotation default on non-abstract or non-public method");
class.cpp:        buffer.MarkInvalid("no code for non-native, non-abstract method");
class.cpp:    assert(pool[descriptor_index] -> Tag() == CPInfo::CONSTANT_Utf8);
class.cpp:        ? attr_signature -> Signature(pool)
class.cpp:    return sig -> Bytes();
class.cpp:    assert(pool[descriptor_index] -> Tag() == CPInfo::CONSTANT_Utf8);
class.cpp:        ? attr_signature -> Signature(pool)
class.cpp:    return sig -> Length();
class.cpp:    switch (name -> Length())
class.cpp:        if (! strcmp(name -> Bytes(), StringConstant::U8S_Code))
class.cpp:        if (! strcmp(name -> Bytes(), StringConstant::U8S_StackMap))
class.cpp:        if (! strcmp(name -> Bytes(), StringConstant::U8S_Signature))
class.cpp:        if (! strcmp(name -> Bytes(), StringConstant::U8S_Synthetic))
class.cpp:        if (! strcmp(name -> Bytes(), StringConstant::U8S_Deprecated))
class.cpp:        if (! strcmp(name -> Bytes(), StringConstant::U8S_Exceptions))
class.cpp:        if (! strcmp(name -> Bytes(), StringConstant::U8S_SourceFile))
class.cpp:        if (! strcmp(name -> Bytes(), StringConstant::U8S_InnerClasses))
class.cpp:        if (! strcmp(name -> Bytes(), StringConstant::U8S_ConstantValue))
class.cpp:        if (! strcmp(name -> Bytes(), StringConstant::U8S_LineNumberTable))
class.cpp:        if (! strcmp(name -> Bytes(), StringConstant::U8S_EnclosingMethod))
class.cpp:        if (! strcmp(name -> Bytes(), StringConstant::U8S_AnnotationDefault))
class.cpp:        if (! strcmp(name -> Bytes(), StringConstant::U8S_LocalVariableTable))
class.cpp:        if (! strcmp(name -> Bytes(),
class.cpp:        if (! strcmp(name -> Bytes(),
class.cpp:        if (! strcmp(name -> Bytes(),
class.cpp:        if (! strcmp(name -> Bytes(),
class.cpp:        if (! strcmp(name -> Bytes(),
class.cpp:    if (buffer.Pool()[index] -> Tag() != CPInfo::CONSTANT_Utf8)
class.cpp:    if (! buffer.Pool()[constantvalue_index] -> Constant())
class.cpp:    unsigned remaining = attribute_length - 12;
class.cpp:    remaining -= code_length;
class.cpp:    remaining -= exception_table_length * 8;
class.cpp:    while (exception_table_length--)
class.cpp:            buffer.Pool()[entry.catch_type] -> Tag() != CPInfo::CONSTANT_Class)
class.cpp:    while (attributes_count--)
class.cpp:        remaining -= 6 + attr -> AttributeLength();
class.cpp:        switch (attr -> Tag())
class.cpp:        else if (constant_pool[exception_table[i].catch_type] -> Tag() ==
class.cpp:            constant_pool[exception_table[i].catch_type] ->
class.cpp:        attributes[j] -> Print(constant_pool, 2);
class.cpp:    while (count--)
class.cpp:        if (buffer.Pool()[index] -> Tag() != CPInfo::CONSTANT_Class)
class.cpp:    while (count--)
class.cpp:        if ((buffer.Pool()[entry.inner_class_info_index] -> Tag() !=
class.cpp:             (buffer.Pool()[entry.outer_class_info_index] -> Tag() !=
class.cpp:             (buffer.Pool()[entry.inner_name_index] -> Tag() !=
class.cpp:    if (buffer.Pool()[sourcefile_index] -> Tag() != CPInfo::CONSTANT_Utf8)
class.cpp:    while (count--)
class.cpp:    while (count--)
class.cpp:        if ((buffer.Pool()[entry.name_index] -> Tag() !=
class.cpp:            (buffer.Pool()[entry.descriptor_index] -> Tag() !=
class.cpp:    if (buffer.Pool()[signature_index] -> Tag() != CPInfo::CONSTANT_Utf8)
class.cpp:            buffer.Pool()[info] -> Tag() != CPInfo::CONSTANT_Class)
class.cpp:    while (count--)
class.cpp:    while (count--)
class.cpp:    unsigned remaining = attribute_length - 2; // -2 for frame_count
class.cpp:    while (count--)
class.cpp:        remaining -= frames[index] -> FrameSize();
class.cpp:        if (buffer.Pool()[index] -> Tag() != CPInfo::CONSTANT_Integer)
class.cpp:            buffer.MarkInvalid("bad int-like annotation constant");
class.cpp:        if (buffer.Pool()[index] -> Tag() != CPInfo::CONSTANT_Long)
class.cpp:        if (buffer.Pool()[index] -> Tag() != CPInfo::CONSTANT_Float)
class.cpp:        if (buffer.Pool()[index] -> Tag() != CPInfo::CONSTANT_Double)
class.cpp:        if (buffer.Pool()[index] -> Tag() != CPInfo::CONSTANT_String)
class.cpp:        if (buffer.Pool()[index] -> Tag() != CPInfo::CONSTANT_Class)
class.cpp:    if (buffer.Pool()[type_name_index] -> Tag() != CPInfo::CONSTANT_Class ||
class.cpp:        buffer.Pool()[const_name_index] -> Tag() != CPInfo::CONSTANT_Utf8)
class.cpp:    return 1 + attr_value -> Length(); // +1 tag
class.cpp:    attr_value -> Put(out);
class.cpp:    attr_value -> Print(pool);
class.cpp:    while (count--)
class.cpp:    if (buffer.Pool()[type_index] -> Tag() != CPInfo::CONSTANT_Utf8)
class.cpp:    while (i--)
class.cpp:        if (buffer.Pool()[index] -> Tag() != CPInfo::CONSTANT_Utf8)
class.cpp:    while (count--)
class.cpp:        length += value -> Length();
class.cpp:        while (count--)
class.cpp:            length += value -> Length();
class.cpp:    if (default_value -> Length() != attribute_length)
class.cpp:    if (buffer.Pool()[class_index] -> Tag() != CPInfo::CONSTANT_Class ||
class.cpp:         (buffer.Pool()[name_and_type_index] -> Tag() !=
class.cpp:        while (--count) // skip entry 0
class.cpp:            if (entry -> Large())
class.cpp:                count--; // skip next entry for eight-byte constants
class.cpp:    if (constant_pool[this_class] -> Tag() != CPInfo::CONSTANT_Class)
class.cpp:        constant_pool[super_class] -> Tag() != CPInfo::CONSTANT_Class)
class.cpp:    while (count--)
class.cpp:        if (constant_pool[inter] -> Tag() != CPInfo::CONSTANT_Class)
class.cpp:    while (count--)
class.cpp:    while (count--)
class.cpp:    while (count--)
class.cpp:        switch (attr -> Tag())
class.cpp:    Semantic* sem = unit_type -> semantic_environment -> sem;
class.cpp:    Control& control = sem -> control;
class.cpp:    const char* class_file_name = unit_type -> ClassName();
class.cpp:        constant_pool[i] -> Put(output_buffer);
class.cpp:        if (constant_pool[i] -> Large())
class.cpp:            i++; // skip the next entry for eight-byte constants
class.cpp:        fields[i] -> Put(output_buffer);
class.cpp:        methods[i] -> Put(output_buffer);
class.cpp:        attributes[i] -> Put(output_buffer);
class.cpp:        sem -> ReportSemError(SemanticError::CANNOT_WRITE_FILE,
class.cpp:                              unit_type -> declaration, name);
class.cpp:                                         str - signature, tok);
class.cpp:        signature--;
class.cpp:    return type -> GetArrayType(this, num_dimensions);
class.cpp:    if (! class_info -> Type())
class.cpp:        const char* str = class_info -> TypeName(constant_pool);
class.cpp:            class_info -> SetType(ProcessSignature(base_type, str, tok));
class.cpp:            u2 length = class_info -> TypeNameLength(constant_pool);
class.cpp:            class_info -> SetType(ReadTypeFromSignature(base_type, str,
class.cpp:    return class_info -> Type();
class.cpp:    TypeSymbol* inner_type = base_type -> FindTypeSymbol(name_symbol);
class.cpp:        int length = base_type -> ExternalNameLength() + 1 +
class.cpp:            name_symbol -> NameLength(); // +1 for $,... +1 for $
class.cpp:        wcscpy(external_name, base_type -> ExternalName());
class.cpp:        wcscat(external_name, name_symbol -> Name());
class.cpp:        inner_type = base_type -> InsertNestedTypeSymbol(name_symbol);
class.cpp:        inner_type -> outermost_type = base_type -> outermost_type;
class.cpp:        inner_type -> supertypes_closure = new SymbolSet;
class.cpp:        inner_type -> subtypes = new SymbolSet;
class.cpp:        inner_type -> SetExternalIdentity(external_name_symbol);
class.cpp:        inner_type -> SetOwner(base_type);
class.cpp:        inner_type -> SetSignature(control);
class.cpp:            Control::GetFile(control, base_type -> ContainingPackage(),
class.cpp:            inner_type -> file_symbol = file_symbol;
class.cpp:            inner_type -> SetLocation();
class.cpp:            inner_type -> SetSymbolTable(1);
class.cpp:            inner_type -> super = control.Object();
class.cpp:            inner_type -> MarkBad();
class.cpp:                           inner_type -> ContainingPackageName(),
class.cpp:                           inner_type -> ExternalName());
class.cpp:        if (type -> SourcePending())
class.cpp:            control.ProcessHeaders(type -> file_symbol);
class.cpp:        for (len = total_length - 1;
class.cpp:             len >= 0 && signature[len] != U_SLASH; len--)
class.cpp:            if (package -> directory.Length() == 0)
class.cpp:                               package -> PackageName());
class.cpp:            control.FindOrInsertName(name, total_length - (len + 1));
class.cpp:        type = package -> FindTypeSymbol(name_symbol);
class.cpp:            if (type -> SourcePending())
class.cpp:                control.ProcessHeaders(type -> file_symbol);
class.cpp:                file_symbol && file_symbol -> IsJava() &&
class.cpp:                ! file_symbol -> IsZip())
class.cpp:                                   base_type -> ContainingPackageName(),
class.cpp:                                   base_type -> ExternalName(),
class.cpp:                                   type -> ContainingPackageName(),
class.cpp:                                   type -> ExternalName());
class.cpp:    FileSymbol* file_symbol = type -> file_symbol;
class.cpp:                << file_symbol -> FileName()
class.cpp:    if (file_symbol -> IsZip())
class.cpp:        if (zipfile -> Buffer() == NULL)
class.cpp:            type -> SetSymbolTable(1);
class.cpp:                type -> super = (type == control.Throwable()
class.cpp:            type -> MarkBad();
class.cpp:                           file_symbol -> PathSym() -> Name(),
class.cpp:                           type -> ContainingPackageName(),
class.cpp:                           type -> ExternalName());
class.cpp:        else ProcessClassFile(type, zipfile -> Buffer(),
class.cpp:                              file_symbol -> uncompressed_size, tok);
class.cpp:            JikesAPI::getInstance() -> read(file_symbol -> FileName());
class.cpp:            type -> SetSymbolTable(1);
class.cpp:                type -> super = (type == control.Throwable()
class.cpp:            type -> MarkBad();
class.cpp:                           type -> ContainingPackageName(),
class.cpp:                           type -> ExternalName());
class.cpp:            unsigned size = classFile -> getBufferSize();
class.cpp:            ProcessClassFile(type, classFile -> getBuffer(), size, tok);
class.cpp:    assert(! type -> HeaderProcessed());
class.cpp:    if (! class_data -> Valid())
class.cpp:        const char* problem = class_data -> DescribeProblem();
class.cpp:                       type -> ExternalName(),
class.cpp:                       type -> file_symbol -> PathSym() -> Name(),
class.cpp:                       type -> ContainingPackageName(),
class.cpp:        type -> MarkBad();
class.cpp:    const ConstantPool& pool = class_data -> Pool();
class.cpp:    CPClassInfo* class_info = class_data -> ThisClass();
class.cpp:    if (strcmp(type -> fully_qualified_name -> value,
class.cpp:               class_info -> TypeName(pool)))
class.cpp:        wchar_t* str = new wchar_t[class_info -> TypeNameLength(pool) + 1];
class.cpp:        control.ConvertUtf8ToUnicode(str, class_info -> TypeName(pool),
class.cpp:                                     class_info -> TypeNameLength(pool));
class.cpp:                       type -> ExternalName(),
class.cpp:                       type -> file_symbol -> PathSym() -> Name(),
class.cpp:        type -> MarkBad();
class.cpp:    type -> MarkHeaderProcessed();
class.cpp:    type -> MarkConstructorMembersProcessed();
class.cpp:    type -> MarkMethodMembersProcessed();
class.cpp:    type -> MarkFieldMembersProcessed();
class.cpp:    type -> MarkLocalClassProcessingCompleted();
class.cpp:    type -> MarkSourceNoLongerPending();
class.cpp:    if (! type -> IsNested() &&
class.cpp:        type -> ContainingPackage() == control.UnnamedPackage())
class.cpp:            control.unnamed_package_types.Image(type -> Identity());
class.cpp:                           tok, type -> Name(), old_type -> FileLoc());
class.cpp:    // On systems such as NT and Win-95 that are not case-sensitive,
class.cpp://      assert(type_name_length - (n + 1) == type -> ExternalNameLength());
class.cpp://      for (i = 0; i < type -> ExternalNameLength(); i++)
class.cpp://          if (type_name[n + 1 + i] != type -> ExternalName()[i])
class.cpp://      if (i < type -> ExternalNameLength())
class.cpp://                         type -> ContainingPackageName(),
class.cpp://                         type -> ExternalName(), name);
class.cpp:    const InnerClassesAttribute* inner_classes = class_data -> InnerClasses();
class.cpp:    type -> SetSymbolTable(class_data -> FieldsCount() +
class.cpp:                           class_data -> MethodsCount() +
class.cpp:                            ? inner_classes -> InnerClassesLength() : 0));
class.cpp:    type -> SetFlags(class_data -> Flags());
class.cpp:    type -> ResetACC_SUPER();
class.cpp:    if (class_data -> Deprecated())
class.cpp:        type -> MarkDeprecated();
class.cpp:        for (i = inner_classes -> InnerClassesLength() - 1; i >= 0; i--)
class.cpp:            const CPClassInfo* inner = inner_classes -> Inner(i, pool);
class.cpp:            const CPClassInfo* outer = inner_classes -> Outer(i, pool);
class.cpp:                type -> SetFlags(inner_classes -> Flags(i));
class.cpp:                    type -> MarkAnonymous();
class.cpp:            else if (outer == class_info && inner_classes -> Name(i, pool) &&
class.cpp:                     inner_classes -> NameLength(i, pool))
class.cpp:                type -> AddNestedTypeSignature((inner_classes ->
class.cpp:                                               (inner_classes ->
class.cpp:        (control.option.unzip || ! type -> file_symbol -> IsZip()))
class.cpp:        type -> ProcessNestedTypeSignatures(this, tok);
class.cpp:    class_info = class_data -> SuperClass();
class.cpp:        type -> MarkBad();
class.cpp:        type -> super = GetType(type, class_info, pool, tok);
class.cpp:        if (type -> super -> ACC_INTERFACE() || type -> super -> IsArray() ||
class.cpp:            type -> super -> Bad())
class.cpp:            type -> MarkBad();
class.cpp:            type -> supertypes_closure -> AddElement(type -> super);
class.cpp:            type -> supertypes_closure -> Union(*type -> super ->
class.cpp:    for (i = class_data -> InterfacesCount() - 1; i >= 0; i--)
class.cpp:        class_info = class_data -> Interface(i);
class.cpp:        type -> AddInterface(interf);
class.cpp:        type -> supertypes_closure -> AddElement(interf);
class.cpp:        type -> supertypes_closure -> Union(*interf -> supertypes_closure);
class.cpp:        if (! interf -> ACC_INTERFACE())
class.cpp:            type -> MarkBad();
class.cpp:    for (i = class_data -> FieldsCount() - 1; i >= 0; i--)
class.cpp:        const FieldInfo* field = class_data -> Field(i);
class.cpp:        if (field -> ACC_SYNTHETIC())
class.cpp:            continue; // No point reading these - the user can't access them.
class.cpp:            control.ConvertUtf8ToUnicode(field -> Name(pool),
class.cpp:                                         field -> NameLength(pool));
class.cpp:        symbol -> SetOwner(type);
class.cpp:        symbol -> MarkComplete();
class.cpp:        symbol -> MarkInitialized();
class.cpp:        symbol -> SetFlags(field -> Flags());
class.cpp:        symbol -> SetSignatureString(field -> Signature(pool, control),
class.cpp:                                     field -> SignatureLength(pool, control));
class.cpp:        if (field -> Deprecated())
class.cpp:            symbol -> MarkDeprecated();
class.cpp:        const CPInfo* value = field -> ConstantValue(pool);
class.cpp:            switch (value -> Tag())
class.cpp:                symbol -> initial_value = control.int_pool.
class.cpp:                    FindOrInsert(((CPIntegerInfo*) value) -> Value());
class.cpp:                symbol -> initial_value = control.long_pool.
class.cpp:                    FindOrInsert(((CPLongInfo*) value) -> Value());
class.cpp:                symbol -> initial_value = control.float_pool.
class.cpp:                    FindOrInsert(((CPFloatInfo*) value) -> Value());
class.cpp:                symbol -> initial_value = control.double_pool.
class.cpp:                    FindOrInsert(((CPDoubleInfo*) value) -> Value());
class.cpp:                    symbol -> initial_value = control.Utf8_pool.
class.cpp:                        FindOrInsert(str_value -> Bytes(pool),
class.cpp:                                     str_value -> Length(pool));
class.cpp:        type -> InsertVariableSymbol(symbol);
class.cpp:            (control.option.unzip || ! type -> file_symbol -> IsZip()))
class.cpp:            symbol -> ProcessVariableSignature(this, tok);
class.cpp:    for (i = class_data -> MethodsCount() - 1; i >= 0; i--)
class.cpp:        const MethodInfo* method = class_data -> Method(i);
class.cpp:            control.ConvertUtf8ToUnicode(method -> Name(pool),
class.cpp:                                         method -> NameLength(pool));
class.cpp:        if (method -> ACC_SYNTHETIC() ||
class.cpp:            continue; // No point reading these - the user can't access them.
class.cpp:        symbol -> SetContainingType(type);
class.cpp:        symbol -> SetFlags(method -> Flags());
class.cpp:            FindOrInsert(method -> Signature(pool, control),
class.cpp:                         method -> SignatureLength(pool, control));
class.cpp:        symbol -> SetSignature(sig);
class.cpp:        if (method -> Deprecated())
class.cpp:            symbol -> MarkDeprecated();
class.cpp:        const ExceptionsAttribute* throws_clause = method -> Exceptions();
class.cpp:            for (int j = throws_clause -> NumberOfExceptions() - 1;
class.cpp:                 j >= 0; j--)
class.cpp:                    throws_clause -> Exception(j, pool);
class.cpp:                symbol ->
class.cpp:                    AddThrowsSignature(exception -> TypeName(pool),
class.cpp:                                       exception -> TypeNameLength(pool));
class.cpp:        type -> InsertMethodSymbol(symbol);
class.cpp:            (control.option.unzip || ! type -> file_symbol -> IsZip()))
class.cpp:            symbol -> ProcessMethodSignature(this, tok);
class.cpp:        (control.option.unzip || ! type -> file_symbol -> IsZip()))
class.cpp:        for (i = pool.Length() - 1; i > 0; i--)
class.cpp:            if (pool[i] -> Tag() == CPInfo::CONSTANT_Class)
class.cpp:            else if (pool[i] -> Tag() == CPInfo::CONSTANT_NameAndType)
class.cpp:                    ((CPNameAndTypeInfo*) pool[i]) -> Signature(pool);
class.cpp:    type -> CompressSpace();
class.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
class.h:    // If this UTF8 was valid, then Bytes returns a NULL-terminated string
class.h:    // NULL-terminated sequence, with no embedded NULLs.
class.h:        return constant_pool[name_index] -> Tag() == CONSTANT_Utf8;
class.h:        assert(constant_pool[name_index] -> Tag() == CONSTANT_Utf8);
class.h:        return ((const CPUtf8Info*) constant_pool[name_index]) -> Bytes();
class.h:        assert(constant_pool[name_index] -> Tag() == CONSTANT_Utf8);
class.h:        return ((const CPUtf8Info*) constant_pool[name_index]) -> Length();
class.h:        if (constant_pool[name_index] -> Tag() == CONSTANT_Utf8)
class.h:            constant_pool[name_index] -> Describe(constant_pool);
class.h:        if (constant_pool[name_index] -> Tag() == CONSTANT_Utf8)
class.h:            constant_pool[name_index] -> Describe(constant_pool);
class.h:        return constant_pool[class_index] -> Tag() == CONSTANT_Class &&
class.h:            (constant_pool[name_and_type_index] -> Tag() ==
class.h:        if (constant_pool[class_index] -> Tag() == CONSTANT_Class)
class.h:            constant_pool[class_index] -> Describe(constant_pool);
class.h:        if (constant_pool[name_and_type_index] -> Tag() ==
class.h:            constant_pool[name_and_type_index] -> Describe(constant_pool);
class.h:        if (constant_pool[class_index] -> Tag() == CONSTANT_Class)
class.h:            constant_pool[class_index] -> Describe(constant_pool);
class.h:        if (constant_pool[name_and_type_index] -> Tag() ==
class.h:            constant_pool[name_and_type_index] -> Describe(constant_pool);
class.h:        return constant_pool[string_index] -> Tag() == CONSTANT_Utf8;
class.h:        assert(constant_pool[string_index] -> Tag() == CONSTANT_Utf8);
class.h:        return ((const CPUtf8Info*) constant_pool[string_index]) -> Bytes();
class.h:        assert(constant_pool[string_index] -> Tag() == CONSTANT_Utf8);
class.h:        return ((const CPUtf8Info*) constant_pool[string_index]) -> Length();
class.h:        if (constant_pool[string_index] -> Tag() == CONSTANT_Utf8)
class.h:            constant_pool[string_index] -> Describe(constant_pool);
class.h:        if (constant_pool[string_index] -> Tag() == CONSTANT_Utf8)
class.h:            constant_pool[string_index] -> Describe(constant_pool);
class.h:        assert(constant_pool[descriptor_index] -> Tag() ==
class.h:        return ((const CPUtf8Info*) constant_pool[descriptor_index]) ->
class.h:        assert(constant_pool[descriptor_index] -> Tag() ==
class.h:        return ((const CPUtf8Info*) constant_pool[descriptor_index]) ->
class.h:        return constant_pool[name_index] -> Tag() == CONSTANT_Utf8 &&
class.h:            constant_pool[descriptor_index] -> Tag() == CONSTANT_Utf8;
class.h:        if (constant_pool[name_index] -> Tag() == CONSTANT_Utf8)
class.h:            constant_pool[name_index] -> Describe(constant_pool);
class.h:        if (constant_pool[descriptor_index] -> Tag() == CONSTANT_Utf8)
class.h:            constant_pool[descriptor_index] -> Describe(constant_pool);
class.h:        if (constant_pool[name_index] -> Tag() == CONSTANT_Utf8)
class.h:            constant_pool[name_index] -> Describe(constant_pool);
class.h:        if (constant_pool[descriptor_index] -> Tag() == CONSTANT_Utf8)
class.h:            constant_pool[descriptor_index] -> Describe(constant_pool);
class.h:        if (constant_pool[attribute_name_index] -> Tag() ==
class.h:            constant_pool[attribute_name_index] -> Describe(constant_pool);
class.h:// An unknown attribute - we are allowed to read them from existing .class
class.h:        assert(constant_pool[constantvalue_index] -> Constant());
class.h:        if (constant_pool[constantvalue_index] -> Constant())
class.h:            constant_pool[constantvalue_index] -> Describe(constant_pool);
class.h:        assert(constant_pool[exception_index_table[i]] -> Tag() ==
class.h:            if (constant_pool[exception_index_table[i]] -> Tag() ==
class.h:                constant_pool[exception_index_table[i]] ->
class.h:        assert(constant_pool[classes[i].inner_class_info_index] -> Tag() ==
class.h:               (constant_pool[classes[i].outer_class_info_index] -> Tag() ==
class.h:               (constant_pool[classes[i].inner_name_index] -> Tag() ==
class.h:                constant_pool[classes[i].inner_name_index]) -> Bytes();
class.h:               (constant_pool[classes[i].inner_name_index] -> Tag() ==
class.h:               constant_pool[classes[i].inner_name_index]) -> Length() : 0;
class.h:            if (constant_pool[classes[i].inner_class_info_index] -> Tag() ==
class.h:                constant_pool[classes[i].inner_class_info_index] ->
class.h:            else if (constant_pool[classes[i].outer_class_info_index] ->
class.h:                constant_pool[classes[i].outer_class_info_index] ->
class.h:            else if (constant_pool[classes[i].inner_name_index] -> Tag() ==
class.h:                constant_pool[classes[i].inner_name_index] ->
class.h:// Valid for classes, methods, and fields, this marks a compiler-generated
class.h:        assert(constant_pool[sourcefile_index] -> Tag() ==
class.h:        return ((CPUtf8Info*) constant_pool[sourcefile_index]) -> Bytes();
class.h:        assert(constant_pool[sourcefile_index] -> Tag() ==
class.h:        return ((CPUtf8Info*) constant_pool[sourcefile_index]) -> Length();
class.h:        if (constant_pool[sourcefile_index] -> Tag() == CPInfo::CONSTANT_Utf8)
class.h:            constant_pool[sourcefile_index] -> Describe(constant_pool);
class.h:        while(--i > 0 && line_number_table[i].start_pc > max_pc)
class.h:            entry.length = end - start;
class.h:            if (constant_pool[index] -> Tag() == CPInfo::CONSTANT_Utf8)
class.h:                constant_pool[index] -> Describe(constant_pool);
class.h:            if (constant_pool[index] -> Tag() == CPInfo::CONSTANT_Utf8)
class.h:                constant_pool[index] -> Describe(constant_pool);
class.h:        assert(constant_pool[signature_index] -> Tag() ==
class.h:        if (constant_pool[signature_index] -> Tag() == CPInfo::CONSTANT_Utf8)
class.h:            constant_pool[signature_index] -> Describe(constant_pool);
class.h:                    if (constant_pool[info] -> Tag() == CPInfo::CONSTANT_Class)
class.h:                        constant_pool[info] -> Describe(constant_pool);
class.h:        attribute_length += frame -> FrameSize();
class.h:            frames[i] -> Put(out);
class.h:            frames[i] -> Print(constant_pool);
class.h:// Valid only on non-abstract non-native methods, this is the method
class.h:        code.Reset(code.Length() - count);
class.h:        attribute_length -= count;
class.h:        attribute_length += 6 + attribute -> AttributeLength();
class.h:        switch (attribute -> Tag())
class.h:            attributes[i] -> Put(out);
class.h:        pool[index] -> Describe(pool);
class.h:            if (pool[index] -> Tag() == CPInfo::CONSTANT_Integer)
class.h:                i4 value = ((CPIntegerInfo*) pool[index]) -> Value();
class.h:            if (pool[index] -> Tag() == CPInfo::CONSTANT_Integer)
class.h:                i4 value = ((CPIntegerInfo*) pool[index]) -> Value();
class.h:            if (pool[index] -> Tag() == CPInfo::CONSTANT_Integer)
class.h:                i4 value = ((CPIntegerInfo*) pool[index]) -> Value();
class.h:                if (value < -128 || value > 127)
class.h:            if (pool[index] -> Tag() == CPInfo::CONSTANT_Integer)
class.h:                i4 value = ((CPIntegerInfo*) pool[index]) -> Value();
class.h:                if (value < -32768 || value > 32767)
class.h:            if (pool[index] -> Tag() != CPInfo::CONSTANT_Integer)
class.h:            if (pool[index] -> Tag() != CPInfo::CONSTANT_Long)
class.h:            if (pool[index] -> Tag() != CPInfo::CONSTANT_Float)
class.h:            if (pool[index] -> Tag() != CPInfo::CONSTANT_Double)
class.h:            if (pool[index] -> Tag() != CPInfo::CONSTANT_String)
class.h:            if (pool[index] -> Tag() != CPInfo::CONSTANT_Class)
class.h:            assert(false && "invalid constant-valued attribute");
class.h:        pool[type_name_index] -> Describe(pool);
class.h:        if (pool[type_name_index] -> Tag() != CPInfo::CONSTANT_Class)
class.h:        pool[const_name_index] -> Describe(pool);
class.h:        if (pool[type_name_index] -> Tag() != CPInfo::CONSTANT_Utf8)
class.h:        while (i--)
class.h:        len += value -> Length();
class.h:            values[i] -> Put(out);
class.h:            values[0] -> Print(pool);
class.h:            values[i] -> Print(pool);
class.h:        while (i--)
class.h:        while (i--)
class.h:            size += 2 + components[i].component_value -> Length();
class.h:        while (i--)
class.h:            components[i].component_value -> Put(out);
class.h:        pool[type_index] -> Describe(pool);
class.h:            pool[components[0].component_name_index] -> Describe(pool);
class.h:            components[0].component_value -> Print(pool);
class.h:            pool[components[i].component_name_index] -> Describe(pool);
class.h:            components[i].component_value -> Print(pool);
class.h:        while (i--)
class.h:        attribute_length += annotation -> Length();
class.h:            annotations[i] -> Put(out);
class.h:            annotations[i] -> Print(constant_pool);
class.h:        for (unsigned i = num_parameters; i--; )
class.h:            for (unsigned j = parameters[i].Length(); j--; )
class.h:        attribute_length += annotation -> Length();
class.h:                parameters[i][j] -> Put(out);
class.h:                parameters[i][j] -> Print(constant_pool);
class.h:                        value -> Length())
class.h:        default_value -> Put(out);
class.h:        default_value -> Print(constant_pool);
class.h:        if (constant_pool[class_index] -> Tag() == CPInfo::CONSTANT_Class &&
class.h:             (constant_pool[name_and_type_index] -> Tag() ==
class.h:            constant_pool[class_index] -> Describe(constant_pool);
class.h:                constant_pool[name_and_type_index] -> Describe(constant_pool);
class.h:        assert(constant_pool[name_index] -> Tag() == CPInfo::CONSTANT_Utf8);
class.h:        return ((const CPUtf8Info*) constant_pool[name_index]) -> Bytes();
class.h:        assert(constant_pool[name_index] -> Tag() == CPInfo::CONSTANT_Utf8);
class.h:        return ((const CPUtf8Info*) constant_pool[name_index]) -> Length();
class.h:        switch (attribute -> Tag())
class.h:        return attr_constantvalue ? attr_constantvalue -> Value(constant_pool)
class.h:            attributes[i] -> Put(out);
class.h:        if (constant_pool[name_index] -> Tag() == CPInfo::CONSTANT_Utf8)
class.h:            constant_pool[name_index] -> Describe(constant_pool);
class.h:        if (constant_pool[descriptor_index] -> Tag() == CPInfo::CONSTANT_Utf8)
class.h:            constant_pool[descriptor_index] -> Describe(constant_pool);
class.h:            attributes[i] -> Print(constant_pool);
class.h:        assert(constant_pool[name_index] -> Tag() == CPInfo::CONSTANT_Utf8);
class.h:        return ((const CPUtf8Info*) constant_pool[name_index]) -> Bytes();
class.h:        assert(constant_pool[name_index] -> Tag() == CPInfo::CONSTANT_Utf8);
class.h:        return ((const CPUtf8Info*) constant_pool[name_index]) -> Length();
class.h:        switch (attribute -> Tag())
class.h:            attributes[i] -> Put(out);
class.h:        if (constant_pool[name_index] -> Tag() == CPInfo::CONSTANT_Utf8)
class.h:            constant_pool[name_index] -> Describe(constant_pool);
class.h:        if (constant_pool[descriptor_index] -> Tag() == CPInfo::CONSTANT_Utf8)
class.h:            constant_pool[descriptor_index] -> Describe(constant_pool);
class.h:            attributes[i] -> Print(constant_pool);
class.h:    // cp_info constant_pool[constant_pool_count - 1]
class.h:        return constant_pool[this_class] -> Tag() == CPInfo::CONSTANT_Class
class.h:        return constant_pool[super_class] -> Tag() == CPInfo::CONSTANT_Class
class.h:        return constant_pool[interfaces[i]] -> Tag() == CPInfo::CONSTANT_Class
class.h:        switch (attribute -> Tag())
class.h:        return attr_sourcefile ? attr_sourcefile -> SourceFile(constant_pool)
class.h:            ? attr_sourcefile -> SourceFileLength(constant_pool) : 0;
class.h:            len = buffer_tail - buffer;
class.h:        for (i = 32; i; i -= 4)
class.h:            char c = (magic >> (i - 4)) & 0xf;
class.h:            Coutput << (char) (c < 10 ? c + '0' : c + 'a' - 10);
class.h:            constant_pool[i] -> Print(constant_pool);
class.h:        if (constant_pool[this_class] -> Tag() == CPInfo::CONSTANT_Class)
class.h:            constant_pool[this_class] -> Describe(constant_pool);
class.h:        else if (constant_pool[super_class] -> Tag() == CPInfo::CONSTANT_Class)
class.h:            constant_pool[super_class] -> Describe(constant_pool);
class.h:            if (constant_pool[interfaces[i]] -> Tag() ==
class.h:                constant_pool[interfaces[i]] -> Describe(constant_pool);
class.h:            fields[i] -> Print(constant_pool);
class.h:            methods[i] -> Print(constant_pool);
class.h:            attributes[i] -> Print(constant_pool);
Binary file class.o matches
code.cpp:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
code.cpp:// DO NOT MODIFY THIS FILE - it is generated using gencode.java.
code.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
code.h:// DO NOT MODIFY THIS FILE - it is generated using gencode.java.
code.h:    // with some self-explanatory functions defined on CODE.
code.h:        return (hi << 10) + lo + (0x10000 - (0xd800 << 10) - 0xdc00);
code.h:        return c - (c <= U_9 ? U_0 : c < U_a ? U_A - 10 : U_a - 10);
Binary file code.o matches
config.h:/* Define as nonzero to enable experimental `-source 1.5' features. */
config.h:/* defined if bool is a built-in C++ type */
config.h:/* Defined if Jikes supports -encoding for input files. */
config.h:/* Define to 1 if you have the `icu-uc' library (-licu-uc). */
config.h:/* define if the compiler supports Run-Time Type Identification */
config.h:/* A string to indicate the release of jikes: Version 1.19 - 1 Feb 2004 */
config.h:#define JIKES_VERSION_STRING "Version 1.22 - 3 October 2004"
config.h.in:/* Define as nonzero to enable experimental `-source 1.5' features. */
config.h.in:/* defined if bool is a built-in C++ type */
config.h.in:/* Defined if Jikes supports -encoding for input files. */
config.h.in:/* Define to 1 if you have the `icu-uc' library (-licu-uc). */
config.h.in:/* define if the compiler supports Run-Time Type Identification */
config.h.in:/* A string to indicate the release of jikes: Version 1.19 - 1 Feb 2004 */
control.cpp:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $
control.cpp:        scanner -> Scan(file_symbol);
control.cpp:        if (file_symbol -> lex_stream) // did we have a successful scan!
control.cpp:                parser -> PackageHeaderParse(file_symbol -> lex_stream,
control.cpp:            ast_pool -> Reset();
control.cpp:                    << file_symbol -> FileName();
control.cpp:        main_file_clone = input_files[0] -> Clone();
control.cpp:        FileSymbol* file_symbol = classpath[dot_classpath_index] ->
control.cpp:            RootDirectory() -> InsertFileSymbol(dot_name_symbol);
control.cpp:        file_symbol -> directory_symbol = classpath[dot_classpath_index] ->
control.cpp:        file_symbol -> SetJava();
control.cpp:        main_file_clone = file_symbol -> Clone();
control.cpp:    main_file_clone -> semantic = new Semantic(*this, main_file_clone);
control.cpp:    system_semantic = main_file_clone -> semantic;
control.cpp:    scanner -> SetUp(main_file_clone);
control.cpp:        system_semantic -> ReportSemError(SemanticError::NO_CURRENT_DIRECTORY,
control.cpp:        system_semantic ->
control.cpp:        system_semantic -> ReportSemError(SemanticError::CANNOT_OPEN_ZIP_FILE,
control.cpp:        system_semantic -> ReportSemError(SemanticError::IO_WARNING, BAD_TOKEN,
control.cpp:        system_semantic -> ReportSemError(SemanticError::IO_ERROR, BAD_TOKEN,
control.cpp:    if (lang_package -> directory.Length() == 0)
control.cpp:        system_semantic -> ReportSemError(SemanticError::PACKAGE_NOT_FOUND,
control.cpp:    // When the -d option is specified, create the relevant
control.cpp:                system_semantic -> ReportSemError(SemanticError::CANNOT_OPEN_DIRECTORY,
control.cpp:        system_semantic -> ReportSemError(SemanticError::BAD_INPUT_FILE,
control.cpp:        system_semantic -> ReportSemError(SemanticError::UNREADABLE_INPUT_FILE,
control.cpp:    if (system_semantic -> NumErrors() > 0)
control.cpp:        system_semantic -> PrintMessages();
control.cpp:        return_code = system_semantic -> return_code;
control.cpp:        system_semantic -> PrintMessages();
control.cpp:        system_semantic -> PrintMessages();
control.cpp:        if (system_semantic -> return_code > 0 ||
control.cpp:                system_semantic -> return_code = 0;
control.cpp:                    system_semantic ->
control.cpp:                    system_semantic ->
control.cpp:                    LexStream* lex_stream = file_symbol -> lex_stream;
control.cpp:                        AstPackageDeclaration* package_declaration = parser ->
control.cpp:                        ast_pool -> Reset();
control.cpp:                system_semantic -> PrintMessages();
control.cpp:                if (system_semantic -> return_code > 0 ||
control.cpp:                        char* java_name = file_symbol -> FileName();
control.cpp:                        for (i = 0; i < file_symbol -> types.Length(); i++)
control.cpp:                            TypeSymbol* type = file_symbol -> types[i];
control.cpp:                                    type -> SignatureString());
control.cpp:                            for (static_parent = (TypeSymbol*) type -> static_parents -> FirstElement();
control.cpp:                                 static_parent = (TypeSymbol*) type -> static_parents -> NextElement())
control.cpp:                                if (! type -> parents ->
control.cpp:                                            static_parent -> SignatureString());
control.cpp:                                    if (static_parent -> file_symbol &&
control.cpp:                                        static_parent -> file_symbol -> IsClass())
control.cpp:                            for (parent = (TypeSymbol*) type -> parents -> FirstElement();
control.cpp:                                 parent = (TypeSymbol*) type -> parents -> NextElement())
control.cpp:                                        parent -> SignatureString());
control.cpp:                                if (parent -> file_symbol &&
control.cpp:                                    parent -> file_symbol -> IsClass())
control.cpp:                        char* class_name = type -> file_symbol -> FileName();
control.cpp:                                type -> SignatureString());
control.cpp:                candidates -> Union(input_class_file_set);
control.cpp:                dependence_checker -> PartialOrder();
control.cpp:                dependence_checker -> OutputDependences();
control.cpp:        name_symbol = FindOrInsertName(package_name, length - start);
control.cpp:            package_symbol -> FindPackageSymbol(name_symbol);
control.cpp:                package_symbol -> InsertPackageSymbol(name_symbol);
control.cpp:    DirectorySymbol* directory_symbol = path_symbol -> RootDirectory();
control.cpp:                                                   end - start);
control.cpp:            directory_symbol -> FindDirectorySymbol(name_symbol);
control.cpp:        directory_symbol = system_table ->
control.cpp:            directory_symbol -> ReadDirectory();
control.cpp:            system_table -> InsertDirectorySymbol(status.st_dev,
control.cpp:                classpath[dot_classpath_index] -> RootDirectory();
control.cpp:                        if (directory_symbol -> Identity() == dot_name_symbol ||
control.cpp:                            directory_symbol -> Identity() == dot_dot_name_symbol)
control.cpp:                                directory_symbol -> FindDirectorySymbol(dot_dot_name_symbol);
control.cpp:                                    directory_symbol -> InsertDirectorySymbol(dot_dot_name_symbol,
control.cpp:                        else directory_symbol = directory_symbol -> owner -> DirectoryCast();
control.cpp:                            directory_symbol -> FindDirectorySymbol(name_symbol);
control.cpp:                                directory_symbol -> InsertDirectorySymbol(name_symbol,
control.cpp:                classpath[dot_classpath_index] -> RootDirectory())
control.cpp:                system_table -> InsertDirectorySymbol(status.st_dev,
control.cpp:                directory_symbol -> ReadDirectory();
control.cpp:        classpath[dot_classpath_index] -> RootDirectory();
control.cpp:                    name_length = length - start;
control.cpp:            directory_symbol -> FindDirectorySymbol(name_symbol);
control.cpp:                directory_symbol -> InsertDirectorySymbol(name_symbol,
control.cpp:                if (directory_symbol -> Identity() == dot_name_symbol ||
control.cpp:                    directory_symbol -> Identity() == dot_dot_name_symbol)
control.cpp:                        directory_symbol -> FindDirectorySymbol(dot_dot_name_symbol);
control.cpp:                            directory_symbol -> InsertDirectorySymbol(dot_dot_name_symbol,
control.cpp:                else directory_symbol = directory_symbol -> owner -> DirectoryCast();
control.cpp:                    directory_symbol -> FindDirectorySymbol(name_symbol);
control.cpp:                        directory_symbol -> InsertDirectorySymbol(name_symbol,
control.cpp:    directory_symbol -> ReadDirectory();
control.cpp:    // filenames should remain in arguments - constructing the Option should
control.cpp:                (! FileSymbol::IsJavaSuffix(&file_name[file_name_length - FileSymbol::java_suffix_length])))
control.cpp:                                              file_name_length - FileSymbol::java_suffix_length);
control.cpp:    int length = file_name_symbol -> Utf8NameLength() +
control.cpp:    strcpy(java_name, file_name_symbol -> Utf8Name());
control.cpp:    DirectoryEntry* entry = directory_symbol -> FindEntry(java_name, length);
control.cpp:        file_symbol = directory_symbol -> FindFileSymbol(file_name_symbol);
control.cpp:                directory_symbol -> InsertFileSymbol(file_name_symbol);
control.cpp:            file_symbol -> directory_symbol = directory_symbol;
control.cpp:            file_symbol -> SetJava();
control.cpp:        file_symbol -> mtime = entry -> Mtime();
control.cpp:    for (len = name_length - 1; len >= 0 && name[len] != U_SLASH; len--)
control.cpp:                                        name_length - (len + 1));
control.cpp:    for (len = name_length - 1;
control.cpp:         len--);
control.cpp:                                        name_length - (len + 1));
control.cpp:        else if (classpath[i] -> IsZip())
control.cpp:                    directory_symbol -> FindFileSymbol(file_name_symbol);
control.cpp:                if (file_symbol && file_symbol -> IsJava())
control.cpp:    if (name -> base_opt)
control.cpp:        package = FindOrInsertPackage(lex_stream, name -> base_opt);
control.cpp:            lex_stream -> NameSymbol(name -> identifier_token);
control.cpp:        PackageSymbol* subpackage = package -> FindPackageSymbol(name_symbol);
control.cpp:            subpackage = package -> InsertPackageSymbol(name_symbol);
control.cpp:            lex_stream -> NameSymbol(name -> identifier_token);
control.cpp:    if (file_symbol -> semantic)
control.cpp:                << file_symbol -> FileName()
control.cpp:    if (! file_symbol -> lex_stream)
control.cpp:         scanner -> Scan(file_symbol);
control.cpp:    else file_symbol -> lex_stream -> Reset();
control.cpp:    if (file_symbol -> lex_stream) // do we have a successful scan!
control.cpp:        if (! file_symbol -> compilation_unit)
control.cpp:            file_symbol -> compilation_unit =
control.cpp:                parser -> HeaderParse(file_symbol -> lex_stream);
control.cpp:        if (file_symbol -> compilation_unit)
control.cpp:            assert(! file_symbol -> semantic);
control.cpp:            if (! file_symbol -> package)
control.cpp:                                          file_symbol -> compilation_unit -> package_declaration_opt);
control.cpp:            file_symbol -> semantic = new Semantic(*this, file_symbol);
control.cpp:            semantic.Next() = file_symbol -> semantic;
control.cpp:            file_symbol -> semantic -> ProcessTypeNames();
control.cpp:                type -> ProcessTypeHeaders();
control.cpp:                type -> semantic_environment -> sem ->
control.cpp:            type -> ProcessMembers();
control.cpp:    for (unsigned j = 0; j < type -> NumAnonymousTypes(); j++)
control.cpp:        CollectTypes(type -> AnonymousType(j), types);
control.cpp:    if (type -> local)
control.cpp:        for (TypeSymbol* local_type = (TypeSymbol*) type -> local -> FirstElement();
control.cpp:             local_type = (TypeSymbol*) type -> local -> NextElement())
control.cpp:    if (type -> non_local)
control.cpp:        for (TypeSymbol* non_local_type = (TypeSymbol*) type -> non_local -> FirstElement();
control.cpp:             non_local_type = (TypeSymbol*) type -> non_local -> NextElement())
control.cpp:    Semantic* sem = type -> semantic_environment -> sem;
control.cpp:    if (type -> declaration &&
control.cpp:        ! sem -> compilation_unit -> BadCompilationUnitCast())
control.cpp:        if (! type -> file_symbol -> IsZip())
control.cpp:            int length = type -> Utf8NameLength() +
control.cpp:            strcpy(classfile_name, type -> Utf8Name());
control.cpp:                type -> file_symbol -> OutputDirectory();
control.cpp:                directory -> FindCaseInsensitiveEntry(classfile_name, length);
control.cpp:            // case-sensitive test) to the name of the type, issue an
control.cpp:            if (entry && strcmp(classfile_name, entry -> name) != 0)
control.cpp:                wchar_t* entry_name = new wchar_t[entry -> length + 1];
control.cpp:                    entry_name[i] = entry -> name[i];
control.cpp:                entry_name[entry -> length] = U_NULL;
control.cpp:                sem -> ReportSemError(SemanticError::FILE_FILE_CONFLICT,
control.cpp:                                      type -> declaration -> identifier_token,
control.cpp:                                      type -> Name(), entry_name,
control.cpp:                                      directory -> Name());
control.cpp:        if (! parser -> InitializerParse(sem -> lex_stream,
control.cpp:                                         type -> declaration))
control.cpp:            sem -> compilation_unit -> MarkBad();
control.cpp:            type -> CompleteSymbolTable();
control.cpp:            if (! parser -> BodyParse(sem -> lex_stream, type -> declaration))
control.cpp:                sem -> compilation_unit -> MarkBad();
control.cpp:            else type -> ProcessExecutableBodies();
control.cpp:        if (sem -> NumErrors() == 0 &&
control.cpp:            sem -> lex_stream -> NumBadTokens() == 0 &&
control.cpp:            ! sem -> compilation_unit -> BadCompilationUnitCast())
control.cpp:                for (unsigned k = 0; k < types -> Length(); k++)
control.cpp:                    type -> file_symbol -> SetFileNameLiteral(this);
control.cpp:                    code -> GenerateCode();
control.cpp:                if (sem -> NumErrors() == 0)
control.cpp:                    for (unsigned k = 0; k < types -> Length(); k++)
control.cpp:                        delete type -> semantic_environment;
control.cpp:                        type -> semantic_environment = NULL;
control.cpp:                        type -> declaration -> semantic_environment = NULL;
control.cpp:    sem -> types_to_be_processed.RemoveElement(type);
control.cpp:    if (sem -> types_to_be_processed.Size() == 0)
control.cpp:            CleanUp(sem -> source_file_symbol);
control.cpp:    if (sem -> NumErrors() != 0 ||
control.cpp:        sem -> lex_stream -> NumBadTokens() != 0 ||
control.cpp:        sem -> compilation_unit -> BadCompilationUnitCast())
control.cpp:         i < sem -> compilation_unit -> NumImportDeclarations(); ++i)
control.cpp:            sem -> compilation_unit -> ImportDeclaration(i);
control.cpp:        Symbol* symbol = import_declaration -> name -> symbol;
control.cpp:        if (import_declaration -> star_token_opt)
control.cpp:            PackageSymbol* package = symbol -> PackageCast();
control.cpp:                ! sem -> referenced_package_imports.IsElement(package))
control.cpp:                sem -> ReportSemError(SemanticError::UNUSED_PACKAGE_IMPORT,
control.cpp:                                      package -> PackageName());
control.cpp:            TypeSymbol* import_type = symbol -> TypeCast();
control.cpp:                ! sem -> referenced_type_imports.IsElement(import_type))
control.cpp:                sem -> ReportSemError(SemanticError::UNUSED_TYPE_IMPORT,
control.cpp:                                      import_type -> ContainingPackage() -> PackageName(),
control.cpp:                                      import_type -> ExternalName());
control.cpp:    file_symbol -> package = (package_declaration
control.cpp:                              ? FindOrInsertPackage(file_symbol -> lex_stream,
control.cpp:                                                    package_declaration -> name)
control.cpp:    for (unsigned i = 0; i < file_symbol -> lex_stream -> NumTypes(); i++)
control.cpp:        TokenIndex identifier_token = file_symbol -> lex_stream ->
control.cpp:            Next(file_symbol -> lex_stream -> Type(i));
control.cpp:        if (file_symbol -> lex_stream -> Kind(identifier_token) ==
control.cpp:                file_symbol -> lex_stream -> NameSymbol(identifier_token);
control.cpp:            if (! file_symbol -> package -> FindTypeSymbol(name_symbol))
control.cpp:                TypeSymbol* type = file_symbol -> package ->
control.cpp:                type -> file_symbol = file_symbol;
control.cpp:                type -> outermost_type = type;
control.cpp:                type -> supertypes_closure = new SymbolSet;
control.cpp:                type -> subtypes = new SymbolSet;
control.cpp:                type -> SetOwner(file_symbol -> package);
control.cpp:                type -> SetSignature(*this);
control.cpp:                type -> MarkSourcePending();
control.cpp:                    unnamed_package_types.Image(type -> Identity()) == NULL)
control.cpp:    Semantic* sem = file_symbol -> semantic;
control.cpp:            sem -> lex_stream -> Reset(); // rewind input and ...
control.cpp:            sem -> lex_stream -> Dump();  // dump it!
control.cpp:            sem -> compilation_unit -> Print(*sem -> lex_stream);
control.cpp:                sem -> compilation_unit -> debug_unparse = true;
control.cpp:            sem -> compilation_unit -> Unparse(sem -> lex_stream,
control.cpp:        sem -> PrintMessages();
control.cpp:        if (sem -> return_code > 0)
control.cpp:        file_symbol -> CleanUp();
control.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
control.h:        if (! name_symbol -> Utf8_literal)
control.h:            name_symbol -> Utf8_literal =
control.h:                ConvertUnicodeToUtf8(name_symbol -> Name());
Binary file control.o matches
cscope.out:cscope 15 $HOME/sandbox/jikes/jikes-1.22/src               0000802132
cscope.out: & -cc=
cscope.out:710 --
cscope.out: -> LeftToken(); }
cscope.out: -> RightToken(); }
cscope.out: ? block_emt-> 
cscope.out: ? defed_vb-> 
cscope.out: ? ba_-> 
cscope.out: -> 
cscope.out: -> LeftToken(); }
cscope.out: -> 
cscope.out: -> IdentifierToken(); }
cscope.out: ? bounds_-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ? ba_-> 
cscope.out: -> LeftToken();
cscope.out: ?y_gumts_-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> RightToken(); }
cscope.out: ? memb_vue_-> 
cscope.out: -> 
cscope.out: -> 
cscope.out:(0) -> LeftToken(); }
cscope.out:(- 1-> 
cscope.out: ? modifrs_-> 
cscope.out: ? impt_dei-> 
cscope.out: ?y_dei-> 
cscope.out: -> 
cscope.out:(0-> 
cscope.out:(0-> 
cscope.out:(- 1-> 
cscope.out:() - 1) ->
cscope.out: -> 
cscope.out: -> 
cscope.out: ? in_vb-> 
cscope.out: ? css_vb-> 
cscope.out: ? mhod-> 
cscope.out: ? cru-> 
cscope.out: ? stic_liz-> 
cscope.out: ? in_liz-> 
cscope.out: ? i_as-> 
cscope.out: ? i_um-> 
cscope.out: ? i_r-> 
cscope.out: ? i_ni-> 
cscope.out: ?my_dei-> 
cscope.out: ? bound-> 
cscope.out:(NumBounds(- 1-> 
cscope.out: ?am-> 
cscope.out: ? i-> 
cscope.out: ? modifrs_-> 
cscope.out: -> 
cscope.out: ? vb_liz-> 
cscope.out: ? bcks_-> 
cscope.out: ? bcks_-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ? vb_de-> 
cscope.out: ? modifrs_-> 
cscope.out: -> 
cscope.out: ? modifrs_-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ? fm_m-> 
cscope.out: ? bcks_-> 
cscope.out: ? bcks_-> 
cscope.out: ?hrow-> 
cscope.out: ? modifrs_-> 
cscope.out: ?y_ms_-> 
cscope.out: -> 
cscope.out: ? mhod_body_-> 
cscope.out: ? modifrs_-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ?rgumt-> 
cscope.out: ? shadow_gumt-> 
cscope.out: ?y_gumts_-> 
cscope.out: ? ba_-> 
cscope.out: ?y_gumts_-> 
cscope.out: ?hrow-> 
cscope.out: ? modifrs_-> 
cscope.out: ?y_ms_-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ? i-> 
cscope.out: ?num_ct-> 
cscope.out: ? modifrs_-> 
cscope.out: -> 
cscope.out: ? modifrs_-> 
cscope.out: ? css_body_-> 
cscope.out: ?rgumts_-> 
cscope.out: ? i-> 
cscope.out: ? modifrs_-> 
cscope.out: -> 
cscope.out: ? modifrs_-> 
cscope.out: - 1;
cscope.out: -> 
cscope.out: ? vb_de-> 
cscope.out: ? modifrs_-> 
cscope.out: -> 
cscope.out:() - 1) ->
cscope.out: -> LeftToken(); }
cscope.out: -> 
cscope.out: -> 
cscope.out: ? f_emt_-> 
cscope.out: -> 
cscope.out: -> LeftToken(); }
cscope.out: -> 
cscope.out: ? swch_b-> 
cscope.out:(0-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ? f__emt-> 
cscope.out: ? f_upde_emt-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ? cch_au-> 
cscope.out: ? fly_au_-> 
cscope.out:(- 1-> 
cscope.out: -> LeftToken(); }
cscope.out: ? ba_-> 
cscope.out: ? ba_-> 
cscope.out: ? ba_-> 
cscope.out: ? css_body_-> 
cscope.out: -> 
cscope.out: ? dim_ex-> 
cscope.out: ? bcks_-> 
cscope.out: -> 
cscope.out: ? bcks_-> 
cscope.out:(- 1-> 
cscope.out: -> LeftToken(); }
cscope.out: ? ba_-> 
cscope.out: -> 
cscope.out: -> LeftToken(); }
cscope.out: -> LeftToken(); }
cscope.out: -> RightToken(); }
cscope.out: -> RightToken(); }
cscope.out: -> LeftToken(); }
cscope.out: -> 
cscope.out: -> LeftToken(); }
cscope.out: -> RightToken(); }
cscope.out: -> LeftToken(); }
cscope.out: -> 
cscope.out: -> LeftToken(); }
cscope.out: -> RightToken(); }
cscope.out: - 8);
cscope.out: - 10);
cscope.out: - 12);
cscope.out:) - 1) / (Cell);
cscope.out:[base_index - 1];
cscope.out: - 1] = 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: && css_body -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: - 1])));
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:--;
cscope.out: - 1];
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:)) ->
cscope.out: -> 
cscope.out:)) ->
cscope.out: -> 
cscope.out:)) ->
cscope.out: -> 
cscope.out:)) ->
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:)) ->
cscope.out: -> 
cscope.out:)) ->
cscope.out: -> 
cscope.out:)) ->
cscope.out: -> 
cscope.out:)) ->
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: &&h-> 
cscope.out:-> 
cscope.out: &&h-> 
cscope.out:-> 
cscope.out: ?h-> 
cscope.out: ? sym -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ->
cscope.out: -> 
cscope.out: -> index);
cscope.out: ->
cscope.out: -> 
cscope.out: -> index) = index;
cscope.out: -> 
cscope.out: -> 
cscope.out:(-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ->
cscope.out: -> 
cscope.out: ->
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:(-> 
cscope.out: -> 
cscope.out: ->
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: :y -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ->
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:(-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: + 1) ^ 1) - 1);
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:]-> 
cscope.out:] -> 
cscope.out:]-> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:]-> 
cscope.out:] -> 
cscope.out:]-> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:]) ->
cscope.out:] -> 
cscope.out:]) ->
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:]] -> 
cscope.out:]] -> 
cscope.out:]] ->
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:]-> 
cscope.out:] -> 
cscope.out:]-> 
cscope.out:] -> 
cscope.out:] ->
cscope.out:] ->
cscope.out:] ->
cscope.out:] -> 
cscope.out:] ->
cscope.out:] -> 
cscope.out:]-> 
cscope.out:] -> 
cscope.out:]-> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:1254 --
cscope.out: - 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out: -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:(- 
cscope.out: -
cscope.out: -> 
cscope.out: -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:]-> 
cscope.out:] -> 
cscope.out:]-> 
cscope.out:] -> 
cscope.out:]-> 
cscope.out: < -128 || value > 127)
cscope.out:] -> 
cscope.out:]-> 
cscope.out: < -32768 || value > 32767)
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out: && "invalid constant-valuedttribute");
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:--)
cscope.out: -> 
cscope.out:] -> 
cscope.out:[0] -> 
cscope.out:] -> 
cscope.out:--)
cscope.out:--)
cscope.out: -> 
cscope.out:--)
cscope.out: -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out: -> 
cscope.out:] -> 
cscope.out: -> 
cscope.out:--)
cscope.out: -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:; i--; )
cscope.out:(); j--; )
cscope.out: -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:]-> 
cscope.out:] -> 
cscope.out:]-> 
cscope.out: -> 
cscope.out: ?r_ctvu-> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:]-> 
cscope.out:] -> 
cscope.out:]-> 
cscope.out: -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:]] -> 
cscope.out: -> 
cscope.out: ?r_sourf-> 
cscope.out: -> 
cscope.out: - 
cscope.out: = 32; i; i -= 4)
cscope.out: - 4)) & 0xf;
cscope.out: + 'a' - 10);
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:]] -> 
cscope.out:]] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out: + (0x10000 - (0xd800 << 10) - 0xdc00);
cscope.out: - (<
cscope.out: - 10 : U_a - 10);
cscope.out: "Vsi 1.22 - 3 Oob 2004"
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: = -1, 
cscope.out:.Length() - 1); }
cscope.out:.Lgth(- 1] : 
cscope.out: = -1 };
cscope.out: + 1 - 
cscope.out:- 
cscope.out:-() const;
cscope.out:-(c IEEE
cscope.out: + (-
cscope.out:-=(c 
cscope.out: = *thi- 
cscope.out:--({  *
cscope.out: -= 1; }
cscope.out:--()
cscope.out: -= 1;
cscope.out:() - Sign()
cscope.out:) ? -1 : *this > op;
cscope.out: - 32,
cscope.out: + 1 - 
cscope.out:)- 
cscope.out: | -(
cscope.out:-() const;
cscope.out:-(c IEEEdoub 
cscope.out: + (-
cscope.out:-=(c 
cscope.out: = *thi- 
cscope.out:--({  *
cscope.out: -= 1; }
cscope.out:--()
cscope.out: -= 1;
cscope.out:() - Sign()
cscope.out:) ? -1 : *this > op;
cscope.out: - 1]); }
cscope.out:-(c 
cscope.out: -> 
cscope.out:--; }
cscope.out:[0]- (
cscope.out:{  -
cscope.out:-(c 
cscope.out:-() const;
cscope.out:-=(c 
cscope.out:--();
cscope.out:--();
cscope.out:67 --
cscope.out: = (hash_vu<< 5- hash_vu+ *
cscope.out:78 --
cscope.out: = (hash_vu<< 5- hash_vu+ *
cscope.out: -> 
cscope.out: ? Utf8_l -> 
cscope.out: ? Utf8_l -> 
cscope.out:(-> 
cscope.out: - 1)];
cscope.out: + (i - 1)]; }
cscope.out:]- 
cscope.out:]- 
cscope.out:]- 
cscope.out: = 3; i >= 0; i--)
cscope.out: - 10 + 
cscope.out: -> fill(c); }
cscope.out: -> 
cscope.out: -> 
cscope.out:() - 1);
cscope.out:.Length() - 1] : 0;
cscope.out: - 1)
cscope.out: - 1)
cscope.out:.Length() - 1); }
cscope.out:(- 1] : 
cscope.out:() - 1; i >= 0; i--)
cscope.out:] -> 
cscope.out:() - 1; i >= 0; i--)
cscope.out:] -> 
cscope.out:() - 1; i >= 0; i--)
cscope.out:] -> 
cscope.out:() - 1);
cscope.out:.Lgth(- 1] : 
cscope.out: - 1);
cscope.out: - 1);
cscope.out:(- 1] : 
cscope.out:() - 1];
cscope.out:() - 1);
cscope.out:() - 1];
cscope.out:--;
cscope.out: - 1];
cscope.out: - 1];
cscope.out: - 1];
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: &&his_vb -> 
cscope.out: &&his_mhod -> 
cscope.out:() - 1);
cscope.out:() - 1];
cscope.out: ->ex_stream),
cscope.out: -> compilation_unit),
cscope.out: -> directory_symbol),
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:(), -> 
cscope.out: -> 
cscope.out: ? -> 
cscope.out:(-> 
cscope.out:(&& ThisMhod(-> 
cscope.out:(&& ThisVb(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out: -> 
cscope.out:(), -> 
cscope.out: ->* 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ->* 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> Identity(); }
cscope.out: ? ci -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:() - 1;
cscope.out: -> 
cscope.out: -> 
cscope.out: = -1;
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> symbol;
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:(-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> Identity())
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:(-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: - 1/ cl_siz* (
cscope.out: - 1/ cl_siz* (
cscope.out: - 1/ 
cscope.out:; i >= 0; i--)
cscope.out: - 1/ cl_siz* (
cscope.out: - 1) / cell_size;
cscope.out: - 1) / cell_size;
cscope.out: - 1) / cell_size;
cscope.out: - 1/ 
cscope.out:) 1 << (i % cell_size)) - (CELL) 1
cscope.out:663 --
cscope.out: - 1/ 
cscope.out: >= 0; i--)
cscope.out: - 1/ 
cscope.out: >= 0; i--)
cscope.out:-(c 
cscope.out:-
cscope.out:-=(c 
cscope.out: - 1/ 
cscope.out: >= 0; i--)
cscope.out: - 1) / cell_size;
cscope.out: - 1) / cell_size;
cscope.out: - 1/ 
cscope.out: - 1) / cell_size - 1)
cscope.out:--] = 
cscope.out:)) - (CELL) 1
cscope.out:772 - (
cscope.out:-(c 
cscope.out:-
cscope.out:-=(c 
cscope.out: -
cscope.out: -
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:];mt;mem-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: = -1;
cscope.out: - 
cscope.out: - 
cscope.out: - 
cscope.out: - 
cscope.out:) -1;
cscope.out: - 1;
cscope.out:.Length() - 1;
cscope.out: <= 0 ? 0 : i - 1; }
cscope.out:() - 1);
cscope.out:(? NumToks(- 1 : i].
cscope.out:() - 1) + 1 : 0;
cscope.out: - 1) < Line(i);
cscope.out: + 1] - 1;
cscope.out:(--
cscope.out:(- 
cscope.out: -> Name(); }
cscope.out: -> NameLength(); }
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> Name(); }
cscope.out: -> NameLength(); }
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ?r-> 
cscope.out: ?r-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:-> 
cscope.out:() -> IsZip(); }
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> Name(); }
cscope.out: -> NameLength(); }
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:() -> IsZip(); }
cscope.out:(-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> Name(); }
cscope.out: -> NameLength(); }
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:-> 
cscope.out: -> Name(); }
cscope.out: -> NameLength(); }
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ? fe_loti -> 
cscope.out: ? fm_m-> 
cscope.out: -> 
cscope.out: ?hrow-> 
cscope.out: -> 
cscope.out: ?hrows_sigtu-> 
cscope.out: -> 
cscope.out: ?x_me_symb -> 
cscope.out: -> 
cscope.out: ?x_me_symb -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: &&x_me_symb -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ? css_l-> 
cscope.out: -> 
cscope.out: ?eed_ty-> 
cscope.out: -> 
cscope.out: ? i-> 
cscope.out: -> 
cscope.out: ?nymous_ty-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> Name(); }
cscope.out: -> NameLength(); }
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ?x_me_symb -> 
cscope.out: -> 
cscope.out: ?x_me_symb -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: &&x_me_symb -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ? mhod -> 
cscope.out:-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:-> 
cscope.out:-> 
cscope.out: && su-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ?ype -> base_type :ype;
cscope.out: ->um_dimensions &&
cscope.out: -> 
cscope.out: ->um_dimensions &&
cscope.out: -> 
cscope.out: -> 
cscope.out: ? fe_loti -> 
cscope.out: -> 
cscope.out: - 1);
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:(-> 
cscope.out: -> 
cscope.out:-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ?ay -> 
cscope.out: -> 
cscope.out: -> Name(); }
cscope.out: -> NameLength(); }
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ? fe_loti -> 
cscope.out: ?x_me_symb -> 
cscope.out: -> 
cscope.out: ?x_me_symb -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: &&x_me_symb -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:(-1)
cscope.out: -> 
cscope.out:(|| ow-> 
cscope.out: -> 
cscope.out: ? mhod_ow-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ? mhod_ow-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> Name(); }
cscope.out: -> NameLength(); }
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ?nymous_symb_po -> 
cscope.out: -> 
cscope.out: ?y_symb_po -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ? mhod_symb_po -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ? vb_symb_po -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ? oth_symb_po -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:(-> 
cscope.out: -> 
cscope.out: ?ab -> 
cscope.out: -> 
cscope.out: ?ab -> 
cscope.out: -> 
cscope.out: ?ab -> 
cscope.out: -> 
cscope.out: ?ab -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:; symb = symb -> 
cscope.out: -> 
cscope.out:(&& symb -> 
cscope.out:(-> 
cscope.out: -> 
cscope.out:; symb = symb -> 
cscope.out: -> 
cscope.out:(&& symb -> 
cscope.out: ?ab -> 
cscope.out:(-> 
cscope.out: -> 
cscope.out:; symb = symb -> 
cscope.out: -> 
cscope.out:(&& symb -> 
cscope.out: ?ab -> 
cscope.out:(-> 
cscope.out: -> 
cscope.out:; symb = symb -> 
cscope.out: -> 
cscope.out:(&& symb -> 
cscope.out: ?ab -> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: = symb, symb = symb -> 
cscope.out: -> 
cscope.out: ->ext;
cscope.out:() - 1;
cscope.out: -> 
cscope.out:-> 
cscope.out: ->ool_index;
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:; symb = symb -> 
cscope.out: -> 
cscope.out:(&& symb -> 
cscope.out: ?ab -> 
cscope.out: ?ab -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:; cdidndid-> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ->ext_method;
cscope.out: -> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out: -> 
cscope.out:; symb = symb -> 
cscope.out: -> 
cscope.out:(&& symb -> 
cscope.out: ?ab -> 
cscope.out: ?ab -> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out:(-> 
cscope.out: -> 
cscope.out:; symb = symb -> 
cscope.out: -> 
cscope.out:(&& symb -> 
cscope.out: ?ab -> 
cscope.out: ?ab -> 
cscope.out: -> 
cscope.out:; symb = symb -> 
cscope.out: -> 
cscope.out:(&& symb -> 
cscope.out:(-> 
cscope.out: ? ci -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ? ci -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ? ci -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:] -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:] -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out:] -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: ->
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out: -> 
cscope.out:() - 1; i >= 0; i--)
cscope.out: -> 
cscope.out:-> 
cscope.out: -> 
cscope.out:-> 
cscope.out:-
cscope.out:-,
cscope.out:-
cscope.out:-
cscope.out:-
cscope.out:-
cscope.out:-
cscope.out:-
cscope.out:-
cscope.out:-
cscope.out:-DISTANCE=3 
cscope.out:-
cscope.out:-
cscope.out:-
cscope.out:-
cscope.out:-
cscope.out:-
cscope.out:-
cscope.out:-Redu 
cscope.out: > 255. 16-
cscope.out:[0]- (
cscope.out:{  -
cscope.out: - 
cscope.out:()]- 
cscope.out: =0 ? -1 : (- 1>> 
cscope.out:- 1; k > 
cscope.out:; k--)
cscope.out: -
cscope.out: -> 
cscope.out:--;
cscope.out: - 1];
cscope.out: - 1];
cscope.out: - 4);
cscope.out: - 8);
cscope.out:)-> 
cscope.out:-> 
cscope.out: - 1>> Tue<T>::
cscope.out: - 
cscope.out:517 --
cscope.out:(-> 
cscope.out: - 1>> bufr.
cscope.out: -> 
cscope.out: -> 
cscope.out: - size);
cscope.out:-=);}
cscope.out:((d)->
cscope.out: ((d)->
cscope.out:(((*(d+ (d)->
cscope.out:- &(d)->
cscope.out:( (d)->
cscope.out: > 1 ?  (d)->d_name : \
cscope.out: (-128)
cscope.out: (-32767-1)
cscope.out: (-2147483647-1)
cscope.out: (-
cscope.out:(9223372036854775807)-1)
cscope.out: (-128)
cscope.out: (-32767-1)
cscope.out: (-2147483647-1)
cscope.out: (-
cscope.out:(9223372036854775807)-1)
cscope.out: (-128)
cscope.out: (-9223372036854775807L-1)
cscope.out: (-9223372036854775807L-1)
cscope.out: (-2147483647-1)
cscope.out: (-2147483647-1)
cscope.out: (-
cscope.out:(9223372036854775807)-1)
cscope.out: (-9223372036854775807L-1)
cscope.out: (-2147483647-1)
cscope.out: (-
cscope.out:(9223372036854775807)-1)
cscope.out: (-9223372036854775807L-1)
cscope.out: (-2147483647-1)
cscope.out: (-2147483647-1)
cscope.out: =-1L && 
cscope.out: -1
cscope.out: -1
cscope.out: -1
cscope.out: -1
cscope.out: -1
cscope.out: -1
cscope.out: -1
cscope.out: -1
cscope.out: -1
cscope.out: -1
cscope.out:[48 -  (
cscope.out:68 -  (
cscope.out:-  (
cscope.out:((buf)->
cscope.out: - (buf)->_mode)
cscope.out:((buf)->
cscope.out: - (buf)->_mode)
cscope.out:((buf)->
cscope.out: - (buf)->_mode)
cscope.out: (-2147483647- 1l)
cscope.out: - 0) >= 500) && \
cscope.out: && (_XOPEN_SOURCE - 0) < 500
cscope.out: - 0) >= 199309L
cscope.out: - 0) >= 199506L
cscope.out: - 0) >= 200112L
cscope.out: - 0) >= 500
cscope.out: - 0) >= 600
cscope.out:((t)->
cscope.out:((t)->
cscope.out:->
cscope.out:)->
cscope.out:)->
cscope.out:)->
cscope.out:- 1% (8 *  ())))
cscope.out:(((sig- 1/ (8 *  ()))
cscope.out:60 --
cscope.out:->
cscope.out:65 --
cscope.out:->
cscope.out:->
cscope.out:[--
cscope.out: && --
cscope.out:->
cscope.out:84 --
cscope.out:->
cscope.out:->__val[__cnt] \
cscope.out:->
cscope.out:93 --
cscope.out:->
cscope.out:->__val[__cnt] \
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:), "1" (__- 1 + (c *
cscope.out: - 1 + (*
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out: - 1;
cscope.out: - 1), "1" (__n),
cscope.out: - 1;
cscope.out: - 1;
cscope.out: - 1;
cscope.out: - 1;
cscope.out: - 1;
cscope.out: - 1- 
cscope.out: - 1- 
cscope.out: - 1- 
cscope.out: - 1- 
cscope.out:+ 1- (size_t)(c *)(__x=1)
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out:->
cscope.out: - 1;
cscope.out: - 
cscope.out:814 - ((
cscope.out:819 - ((
cscope.out:826 - ((
cscope.out:832 - ((
cscope.out:843 - 
cscope.out:))[1] - 
cscope.out:))[2] - 
cscope.out:855 - 
cscope.out:[0] - ((
cscope.out:869 - ((
cscope.out:[2] - ((
cscope.out:879 - ((
cscope.out:[-1] = '\0';
cscope.out: - 1] = '\0'; \
cscope.out: - 1); \
cscope.out: < -128 || __> 255 ? __: (
cscope.out: >-128 && __< 256 ? (*
cscope.out: >-128 && __< 256 ? (*
cscope.out:)->
cscope.out:)->
cscope.out:)->
decl.cpp:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $
decl.cpp:    if (! compilation_unit -> package_declaration_opt)
decl.cpp:        compilation_unit -> package_declaration_opt;
decl.cpp:             *package = subpackage -> owner;
decl.cpp:         package; subpackage = package, package = package -> owner)
decl.cpp:            Control::GetFile(control, package, subpackage -> Identity());
decl.cpp:            char* file_name = file_symbol -> FileName();
decl.cpp:            int length = file_symbol -> FileNameLength();
decl.cpp:                           compilation_unit -> package_declaration_opt -> name,
decl.cpp:                           package -> PackageName(), subpackage -> Name(),
decl.cpp:    // TODO: Warn about package annotations outside of package-info.java.
decl.cpp:    compilation_unit = source_file_symbol -> compilation_unit;
decl.cpp:        if (compilation_unit -> EmptyCompilationUnitCast())
decl.cpp:             i < compilation_unit -> NumTypeDeclarations(); i++)
decl.cpp:                compilation_unit -> TypeDeclaration(i);
decl.cpp:            if (type_declaration -> EmptyDeclarationCast())
decl.cpp:    if (compilation_unit -> BadCompilationUnitCast())
decl.cpp:        for (unsigned i = 0; i < lex_stream -> NumTypes(); i++)
decl.cpp:                lex_stream -> Next(lex_stream -> Type(i));
decl.cpp:                lex_stream -> NameSymbol(identifier_token);
decl.cpp:                TypeSymbol* type = this_package -> FindTypeSymbol(name_symbol);
decl.cpp:                type -> MarkBad();
decl.cpp:                type -> MarkSourceNoLongerPending();
decl.cpp:                type -> supertypes_closure = new SymbolSet;
decl.cpp:                type -> subtypes = new SymbolSet;
decl.cpp:                type -> semantic_environment =
decl.cpp:                    type -> super = control.no_type;
decl.cpp:                if (! type -> FindMethodSymbol(control.init_name_symbol))
decl.cpp:                source_file_symbol -> types.Next() = type;
decl.cpp:    for (unsigned k = 0; k < compilation_unit -> NumTypeDeclarations(); k++)
decl.cpp:        AstDeclaredType* declaration = compilation_unit -> TypeDeclaration(k);
decl.cpp:        if (! declaration -> EmptyDeclarationCast())
decl.cpp:            identifier_token = declaration -> class_body -> identifier_token;
decl.cpp:                lex_stream -> NameSymbol(identifier_token);
decl.cpp:            if (name_symbol -> IsBadStyleForClass())
decl.cpp:                               identifier_token, name_symbol -> Name());
decl.cpp:            type = this_package -> FindTypeSymbol(name_symbol);
decl.cpp:            if (! type -> SourcePending())
decl.cpp:                               identifier_token, name_symbol -> Name(),
decl.cpp:                               type -> FileLoc());
decl.cpp:                if (type -> ContainingPackage() == control.UnnamedPackage())
decl.cpp:                                       identifier_token, name_symbol -> Name(),
decl.cpp:                                       old_type -> FileLoc());
decl.cpp:                type -> MarkSourceNoLongerPending();
decl.cpp:                type -> semantic_environment =
decl.cpp:                type -> declaration = declaration -> class_body;
decl.cpp:                type -> SetFlags(ProcessTopLevelTypeModifiers(declaration));
decl.cpp:                type -> SetSymbolTable(declaration -> class_body ->
decl.cpp:                type -> SetLocation();
decl.cpp:                if (lex_stream -> IsDeprecated(declaration -> LeftToken()))
decl.cpp:                    type -> MarkDeprecated();
decl.cpp:                source_file_symbol -> types.Next() = type;
decl.cpp:                declaration -> class_body -> semantic_environment =
decl.cpp:                    type -> semantic_environment;
decl.cpp:                CheckNestedMembers(type, declaration -> class_body);
decl.cpp:                lex_stream -> NameSymbol(identifier_token);
decl.cpp:            for (unsigned i = 0; i < this_package -> directory.Length(); i++)
decl.cpp:                // subpackages require a named top-level package. In other
decl.cpp:                if ((this_package -> directory[i] ->
decl.cpp:                    char* file_name = type -> file_symbol -> FileName();
decl.cpp:                    int length = type -> file_symbol -> FileNameLength();
decl.cpp:                                   this_package -> PackageName(),
decl.cpp:                                   name_symbol -> Name(), error_name);
decl.cpp:            if (type -> Identity() != source_file_symbol -> Identity())
decl.cpp:                    Control::GetJavaFile(package, type -> Identity());
decl.cpp:                                   this_package -> PackageName(),
decl.cpp:                                   source_file_symbol -> Name(),
decl.cpp:                                   package -> PackageName(), type -> Name());
decl.cpp:        if (type && type -> ACC_PUBLIC())
decl.cpp:                if (source_file_symbol -> Identity() !=
decl.cpp:                    public_type -> Identity())
decl.cpp:                                   type -> declaration -> identifier_token,
decl.cpp:                                   public_type -> Name());
decl.cpp:                               type -> declaration -> identifier_token,
decl.cpp:                               type -> Name(),
decl.cpp:                               public_type -> Name());
decl.cpp:    for (i = 0; i < class_body -> NumNestedClasses(); i++)
decl.cpp:        AstClassDeclaration* decl = class_body -> NestedClass(i);
decl.cpp:    for (i = 0; i < class_body -> NumNestedEnums(); i++)
decl.cpp:        AstEnumDeclaration* decl = class_body -> NestedEnum(i);
decl.cpp:    for (i = 0; i < class_body -> NumNestedInterfaces(); i++)
decl.cpp:        AstInterfaceDeclaration* decl = class_body -> NestedInterface(i);
decl.cpp:    for (i = 0; i < class_body -> NumNestedAnnotations(); i++)
decl.cpp:        AstAnnotationDeclaration* decl = class_body -> NestedAnnotation(i);
decl.cpp:    for (i = 0; i < class_body -> NumEmptyDeclarations(); i++)
decl.cpp:                           class_body -> EmptyDeclaration(i));
decl.cpp:    TypeSymbol* type = type_shadow_symbol -> type_symbol;
decl.cpp:        if (type_shadow_symbol -> NumConflicts())
decl.cpp:            type = type_shadow_symbol -> Conflict(0);
decl.cpp:    for ( ; i < type_shadow_symbol -> NumConflicts(); i++)
decl.cpp:                       identifier_token, type -> Name(),
decl.cpp:                       type -> owner -> TypeCast() -> ContainingPackageName(),
decl.cpp:                       type -> owner -> TypeCast() -> ExternalName(),
decl.cpp:                       type_shadow_symbol -> Conflict(i) -> owner -> TypeCast() -> ContainingPackageName(),
decl.cpp:                       type_shadow_symbol -> Conflict(i) -> owner -> TypeCast() -> ExternalName());
decl.cpp:    NameSymbol* name_symbol = lex_stream -> NameSymbol(identifier_token);
decl.cpp:    if (env -> symbol_table.Size())
decl.cpp:        for (int i = env -> symbol_table.Size(); --i >= 0; )
decl.cpp:            old_type = env -> symbol_table[i] -> FindTypeSymbol(name_symbol);
decl.cpp:    else old_type = env -> Type() -> FindTypeSymbol(name_symbol);
decl.cpp:                       identifier_token, name_symbol -> Name(),
decl.cpp:                       old_type -> FileLoc());
decl.cpp:        for (; env; env = env -> previous)
decl.cpp:            if (env -> Type() -> Identity() == name_symbol)
decl.cpp:                               identifier_token, name_symbol -> Name(),
decl.cpp:                               env -> Type() -> FileLoc());
decl.cpp:    AstClassBody* class_body = declaration -> class_body;
decl.cpp:        lex_stream -> NameSymbol(class_body -> identifier_token);
decl.cpp:    TypeSymbol* outermost_type = containing_type -> outermost_type;
decl.cpp:    CheckNestedTypeDuplication(containing_type -> semantic_environment,
decl.cpp:                               class_body -> identifier_token);
decl.cpp:    int length = containing_type -> ExternalNameLength() + 1 +
decl.cpp:        name_symbol -> NameLength(); // +1 for $,... +1 for $
decl.cpp:    wcscpy(external_name, containing_type -> ExternalName());
decl.cpp:    wcscat(external_name, name_symbol -> Name());
decl.cpp:        containing_type -> InsertNestedTypeSymbol(name_symbol);
decl.cpp:    inner_type -> outermost_type = outermost_type;
decl.cpp:    inner_type -> supertypes_closure = new SymbolSet;
decl.cpp:    inner_type -> subtypes = new SymbolSet;
decl.cpp:    inner_type -> SetExternalIdentity(control.FindOrInsertName(external_name,
decl.cpp:    inner_type -> semantic_environment =
decl.cpp:                                containing_type -> semantic_environment);
decl.cpp:    inner_type -> declaration = declaration -> class_body;
decl.cpp:    inner_type -> file_symbol = source_file_symbol;
decl.cpp:    inner_type -> SetFlags(ProcessNestedTypeModifiers(containing_type,
decl.cpp:    inner_type -> SetOwner(containing_type);
decl.cpp:    inner_type -> SetSymbolTable(class_body -> NumClassBodyDeclarations() + 3);
decl.cpp:    inner_type -> SetLocation();
decl.cpp:    inner_type -> SetSignature(control);
decl.cpp:    if (lex_stream -> IsDeprecated(declaration -> LeftToken()))
decl.cpp:        inner_type -> MarkDeprecated();
decl.cpp:    // If not a top-level type, then add pointer to enclosing type.
decl.cpp:    if (! inner_type -> ACC_STATIC())
decl.cpp:        inner_type -> InsertThis0();
decl.cpp:    else if (containing_type -> IsInner())
decl.cpp:                       class_body -> identifier_token, name_symbol -> Name(),
decl.cpp:                       containing_type -> Name(),
decl.cpp:                       containing_type -> FileLoc());
decl.cpp:        inner_type -> ResetACC_STATIC();
decl.cpp:    if (inner_type -> IsLocal())
decl.cpp:        if (! outermost_type -> local)
decl.cpp:            outermost_type -> local = new SymbolSet;
decl.cpp:        outermost_type -> local -> AddElement(inner_type);
decl.cpp:        if (! outermost_type -> non_local)
decl.cpp:            outermost_type -> non_local = new SymbolSet;
decl.cpp:        outermost_type -> non_local -> AddElement(inner_type);
decl.cpp:    if (name_symbol -> IsBadStyleForClass())
decl.cpp:                       class_body -> identifier_token, name_symbol -> Name());
decl.cpp:    declaration -> class_body -> semantic_environment =
decl.cpp:        inner_type -> semantic_environment;
decl.cpp:    for (unsigned i = 0; i < compilation_unit -> NumImportDeclarations(); i++)
decl.cpp:            compilation_unit -> ImportDeclaration(i);
decl.cpp:        if (import_declaration -> static_token_opt)
decl.cpp:                               import_declaration -> static_token_opt);
decl.cpp:        if (import_declaration -> star_token_opt)
decl.cpp:        declaration -> class_body -> semantic_environment -> Type();
decl.cpp:    assert(! type -> HeaderProcessed() || type -> Bad());
decl.cpp:    type -> MarkHeaderProcessed();
decl.cpp:    if (type -> Bad())
decl.cpp:    // with recursion or non-existant classes.
decl.cpp:    if (this_package == control.LangPackage() && ! type -> IsNested())
decl.cpp:        if (type -> Identity() == control.Object_name_symbol)
decl.cpp:            if (declaration -> super_opt || declaration -> NumInterfaces())
decl.cpp:                               declaration -> LeftToken(),
decl.cpp:                               declaration -> class_body -> left_brace_token - 1);
decl.cpp:            if (declaration -> type_parameters_opt)
decl.cpp:                               declaration -> LeftToken(),
decl.cpp:                               declaration -> class_body -> left_brace_token - 1,
decl.cpp:                               type -> ContainingPackageName(),
decl.cpp:                               type -> ExternalName());
decl.cpp:            type -> MarkHeaderProcessed();
decl.cpp:        else if (type -> Identity() == control.Enum_name_symbol)
decl.cpp:            type -> MarkEnum();
decl.cpp:    if (declaration -> type_parameters_opt)
decl.cpp:        ProcessTypeParameters(type, declaration -> type_parameters_opt);
decl.cpp:    if (declaration -> super_opt)
decl.cpp:        ProcessType(declaration -> super_opt);
decl.cpp:        TypeSymbol* super_type = declaration -> super_opt -> symbol;
decl.cpp:        assert(! super_type -> SourcePending());
decl.cpp:        if (! super_type -> HeaderProcessed())
decl.cpp:            super_type -> ProcessTypeHeaders();
decl.cpp:            super_type -> IsDeprecated() && ! type -> IsDeprecated())
decl.cpp:                           declaration -> super_opt,
decl.cpp:                           super_type -> ContainingPackageName(),
decl.cpp:                           super_type -> ExternalName());
decl.cpp:        if (super_type -> IsEnum())
decl.cpp:                           declaration -> super_opt,
decl.cpp:                           super_type -> ContainingPackageName(),
decl.cpp:                           super_type -> ExternalName());
decl.cpp:        else if (super_type -> ACC_INTERFACE())
decl.cpp:                           declaration -> super_opt,
decl.cpp:                           super_type -> ContainingPackageName(),
decl.cpp:                           super_type -> ExternalName());
decl.cpp:        else if (super_type -> ACC_FINAL())
decl.cpp:                           declaration -> super_opt,
decl.cpp:                           super_type -> ContainingPackageName(),
decl.cpp:                           super_type -> ExternalName());
decl.cpp:        else if (super_type -> Bad())
decl.cpp:            super_type -> subtypes -> AddElement(type);
decl.cpp:            type -> super = super_type;
decl.cpp:                type -> supertypes_closure -> AddElement(super_type);
decl.cpp:                type -> supertypes_closure -> Union(*super_type ->
decl.cpp:                if (super_type -> owner -> TypeCast())
decl.cpp:                    super_type = super_type -> ContainingType();
decl.cpp:    if (! type -> super)
decl.cpp:        type -> super = control.Object();
decl.cpp:        type -> supertypes_closure -> AddElement(control.Object());
decl.cpp:        control.Object() -> subtypes -> AddElement(type);
decl.cpp:    AddDependence(type, type -> super);
decl.cpp:    for (unsigned i = 0; i < declaration -> NumInterfaces(); i++)
decl.cpp:        ProcessSuperinterface(type, declaration -> Interface(i));
decl.cpp:    if (type -> supertypes_closure -> IsElement(type))
decl.cpp:        type -> super = control.Object();
decl.cpp:        type -> ResetInterfaces();
decl.cpp:        type -> MarkCircular();
decl.cpp:                       declaration -> class_body -> identifier_token,
decl.cpp:                       declaration -> class_body -> left_brace_token - 1,
decl.cpp:                       type -> ContainingPackageName(),
decl.cpp:                       type -> ExternalName());
decl.cpp:    else if (declaration -> type_parameters_opt &&
decl.cpp:             type -> IsSubclass(control.Throwable()))
decl.cpp:                       declaration -> LeftToken(),
decl.cpp:                       declaration -> class_body -> left_brace_token - 1,
decl.cpp:                       type -> ContainingPackageName(),
decl.cpp:                       type -> ExternalName());
decl.cpp:        declaration -> class_body -> semantic_environment -> Type();
decl.cpp:    assert(! type -> HeaderProcessed() || type -> Bad());
decl.cpp:    type -> MarkHeaderProcessed();
decl.cpp:                       declaration -> enum_token);
decl.cpp:        type -> super = control.Object();
decl.cpp:        type -> MarkBad();
decl.cpp:    if (type -> Bad())
decl.cpp:    type -> super = control.Enum();
decl.cpp:    type -> supertypes_closure -> AddElement(control.Enum());
decl.cpp:    type -> MarkEnum(); // Since ACC_ENUM is only for enum constants.
decl.cpp:    control.Enum() -> subtypes -> AddElement(type);
decl.cpp:    AddDependence(type, type -> super);
decl.cpp:    for (unsigned i = 0; i < declaration -> NumInterfaces(); i++)
decl.cpp:        ProcessSuperinterface(type, declaration -> Interface(i));
decl.cpp:    assert(! type -> supertypes_closure -> IsElement(type));
decl.cpp:        declaration -> class_body -> semantic_environment -> Type();
decl.cpp:    assert(! type -> HeaderProcessed() || type -> Bad());
decl.cpp:    type -> MarkHeaderProcessed();
decl.cpp:    if (declaration -> type_parameters_opt)
decl.cpp:        ProcessTypeParameters(type, declaration -> type_parameters_opt);
decl.cpp:    type -> super = control.Object();
decl.cpp:    for (unsigned k = 0; k < declaration -> NumInterfaces(); k++)
decl.cpp:        ProcessSuperinterface(type, declaration -> Interface(k));
decl.cpp:    if (type -> supertypes_closure -> IsElement(type))
decl.cpp:        type -> ResetInterfaces();
decl.cpp:        type -> MarkCircular();
decl.cpp:                       declaration -> class_body -> identifier_token,
decl.cpp:                       declaration -> class_body -> left_brace_token - 1,
decl.cpp:                       type -> ContainingPackageName(),
decl.cpp:                       type -> ExternalName());
decl.cpp:        declaration -> class_body -> semantic_environment -> Type();
decl.cpp:    assert(! type -> HeaderProcessed() || type -> Bad());
decl.cpp:    type -> MarkHeaderProcessed();
decl.cpp:                       declaration -> interface_token - 1,
decl.cpp:                       declaration -> interface_token);
decl.cpp:        type -> MarkBad();
decl.cpp:    type -> super = control.Object();
decl.cpp:    type -> AddInterface(control.Annotation());
decl.cpp:    TypeSymbol* interf = name -> symbol;
decl.cpp:    assert(! interf -> SourcePending());
decl.cpp:    if (! interf -> HeaderProcessed())
decl.cpp:        interf -> ProcessTypeHeaders();
decl.cpp:        interf -> IsDeprecated() && ! base_type -> IsDeprecated())
decl.cpp:                       interf -> ContainingPackageName(),
decl.cpp:                       interf -> ExternalName());
decl.cpp:    if (! interf -> ACC_INTERFACE())
decl.cpp:        if (! interf -> Bad())
decl.cpp:                           interf -> ContainingPackageName(),
decl.cpp:                           interf -> ExternalName());
decl.cpp:        name -> symbol = NULL;
decl.cpp:        for (unsigned k = 0; k < base_type -> NumInterfaces(); k++)
decl.cpp:            if (base_type -> Interface(k) == interf)
decl.cpp:                               interf -> ContainingPackageName(),
decl.cpp:                               interf -> ExternalName(),
decl.cpp:                               base_type -> ExternalName());
decl.cpp:                name -> symbol = NULL;
decl.cpp:        name -> symbol = interf; // save type name in ast.
decl.cpp:        base_type -> AddInterface(interf);
decl.cpp:        interf -> subtypes -> AddElement(base_type);
decl.cpp:            base_type -> supertypes_closure -> AddElement(interf);
decl.cpp:            base_type -> supertypes_closure -> Union(*interf ->
decl.cpp:            if (interf -> owner -> TypeCast())
decl.cpp:                interf = interf -> ContainingType();
decl.cpp:// owner, so anon_type must be non-null only in that case.
decl.cpp:    assert(! body -> owner ^ ! anon_type);
decl.cpp:    SemanticEnvironment* sem = anon_type ? anon_type -> semantic_environment
decl.cpp:        : body -> semantic_environment;
decl.cpp:    TypeSymbol* type = anon_type ? anon_type : sem -> Type();
decl.cpp:    if (type -> HeaderProcessed())
decl.cpp:        anon_type -> MarkHeaderProcessed();
decl.cpp:    else if (body -> owner -> ClassDeclarationCast())
decl.cpp:        ProcessTypeHeader((AstClassDeclaration*) body -> owner);
decl.cpp:    else if (body -> owner -> EnumDeclarationCast())
decl.cpp:        ProcessTypeHeader((AstEnumDeclaration*) body -> owner);
decl.cpp:    else if (body -> owner -> InterfaceDeclarationCast())
decl.cpp:        ProcessTypeHeader((AstInterfaceDeclaration*) body -> owner);
decl.cpp:        assert(body -> owner -> AnnotationDeclarationCast());
decl.cpp:        ProcessTypeHeader((AstAnnotationDeclaration*) body -> owner);
decl.cpp:    for (i = 0; i < body -> NumNestedClasses(); i++)
decl.cpp:        AstClassDeclaration* nested_class = body -> NestedClass(i);
decl.cpp:        type -> AddNestedType(ProcessTypeHeaders(nested_class -> class_body));
decl.cpp:    for (i = 0; i < body -> NumNestedEnums(); i++)
decl.cpp:        AstEnumDeclaration* nested_enum = body -> NestedEnum(i);
decl.cpp:        type -> AddNestedType(ProcessTypeHeaders(nested_enum -> class_body));
decl.cpp:    for (i = 0; i < body -> NumNestedInterfaces(); i++)
decl.cpp:        AstInterfaceDeclaration* nested = body -> NestedInterface(i);
decl.cpp:        type -> AddNestedType(ProcessTypeHeaders(nested -> class_body));
decl.cpp:    for (i = 0; i < body -> NumNestedAnnotations(); i++)
decl.cpp:        AstAnnotationDeclaration* nested = body -> NestedAnnotation(i);
decl.cpp:        type -> AddNestedType(ProcessTypeHeaders(nested -> class_body));
decl.cpp:                   type -> ContainingPackageName(),
decl.cpp:                   type -> ExternalName(), type -> AccessString());
decl.cpp:    if (type == control.null_type || type -> Bad() || type -> Primitive())
decl.cpp:    NameSymbol* name_symbol = lex_stream -> NameSymbol(identifier_token);
decl.cpp:    if (! type -> expanded_type_table)
decl.cpp:        type -> expanded_type_table -> FindTypeShadowSymbol(name_symbol);
decl.cpp:    if (type -> Bad())
decl.cpp:    if (name -> base_opt && ! name -> base_opt -> symbol)
decl.cpp:        type = MustFindNestedType(type, name -> base_opt);
decl.cpp:    TypeSymbol* inner_type = FindNestedType(type, name -> identifier_token);
decl.cpp:            lex_stream -> NameSymbol(name -> identifier_token);
decl.cpp:        for (TypeSymbol* super_type = type -> super;
decl.cpp:             super_type && ! super_type -> Bad();
decl.cpp:             super_type = super_type -> super)
decl.cpp:            assert(super_type -> expanded_type_table);
decl.cpp:            TypeShadowSymbol* type_shadow_symbol = super_type ->
decl.cpp:                expanded_type_table -> FindTypeShadowSymbol(name_symbol);
decl.cpp:                                              name -> identifier_token);
decl.cpp:        else inner_type = GetBadNestedType(type, name -> identifier_token);
decl.cpp:    return inner_type -> Bad() ? control.no_type : inner_type;
decl.cpp:    assert(this_type -> HeaderProcessed());
decl.cpp:    if (class_body -> NumConstructors())
decl.cpp:        for (unsigned i = 0; i < class_body -> NumConstructors(); i++)
decl.cpp:            ProcessConstructorDeclaration(class_body -> Constructor(i));
decl.cpp:    else if (! this_type -> Anonymous() && ! this_type -> ACC_INTERFACE())
decl.cpp:    this_type -> MarkConstructorMembersProcessed();
decl.cpp:    assert(ThisType() -> HeaderProcessed());
decl.cpp:    for (unsigned i = 0; i < class_body -> NumMethods(); i++)
decl.cpp:        ProcessMethodDeclaration(class_body -> Method(i));
decl.cpp:    ThisType() -> MarkMethodMembersProcessed();
decl.cpp:    assert(ThisType() -> HeaderProcessed());
decl.cpp:    for (i = 0; i < class_body -> NumInstanceVariables(); i++)
decl.cpp:        ProcessFieldDeclaration(class_body -> InstanceVariable(i));
decl.cpp:    for (i = 0; i < class_body -> NumClassVariables(); i++)
decl.cpp:        ProcessFieldDeclaration(class_body -> ClassVariable(i));
decl.cpp:    ThisType() -> MarkFieldMembersProcessed();
decl.cpp:    assert(this_type -> HeaderProcessed());
decl.cpp:    // Does it have any non-default constructors?
decl.cpp:    for (unsigned i = 0; i < class_body -> NumConstructors(); ++i)
decl.cpp:            class_body -> Constructor(i);
decl.cpp:        if (! constructor_declaration -> IsValid())
decl.cpp:        MethodSymbol* constructor = constructor_declaration ->
decl.cpp:        if (constructor -> ACC_PRIVATE())
decl.cpp:        if (class_body -> default_constructor == NULL ||
decl.cpp:            constructor != class_body -> default_constructor -> constructor_symbol)
decl.cpp:    for (unsigned i = 0; i < class_body -> NumMethods(); ++i)
decl.cpp:        AstMethodDeclaration* method_declaration = class_body -> Method(i);
decl.cpp:        if (! method_declaration -> IsValid())
decl.cpp:        MethodSymbol* method = method_declaration -> method_symbol;
decl.cpp:        if (! method -> ACC_STATIC())
decl.cpp:        if (! this_type -> ACC_INTERFACE() && ! method -> ACC_ABSTRACT())
decl.cpp:            if (method -> name_symbol == control.equals_name_symbol &&
decl.cpp:                method -> Type() == control.boolean_type &&
decl.cpp:                method -> NumFormalParameters() == 1 &&
decl.cpp:                has_correct_equals_method = (method -> FormalParameter(0) ->
decl.cpp:            if (method -> name_symbol == control.hashCode_name_symbol &&
decl.cpp:                method -> Type() == control.int_type &&
decl.cpp:                method -> NumFormalParameters() == 0)
decl.cpp:                       equals_method -> method_declarator -> identifier_token,
decl.cpp:                       this_type -> Name());
decl.cpp:                       equals_method -> method_declarator -> identifier_token,
decl.cpp:                       this_type -> Name());
decl.cpp:                       hashCode_method -> method_declarator -> identifier_token,
decl.cpp:                       this_type -> Name());
decl.cpp:    bool is_non_empty_class = (class_body -> NumClassVariables() > 0 ||
decl.cpp:                               class_body -> NumInstanceVariables() > 0 ||
decl.cpp:                               class_body -> NumMethods() > 0);
decl.cpp:    bool has_instance_members = (class_body -> NumInstanceVariables() > 0 ||
decl.cpp:        ! this_type -> ACC_INTERFACE() &&
decl.cpp:        ! this_type -> ACC_ABSTRACT() &&
decl.cpp:        ! this_type -> Anonymous() &&
decl.cpp:        this_type -> super == control.Object())
decl.cpp:                       class_body -> identifier_token,
decl.cpp:                       this_type -> Name());
decl.cpp:    if (this_type -> ACC_INTERFACE() &&
decl.cpp:        this_type -> super == control.Object() &&
decl.cpp:        class_body -> NumMethods() == 0)
decl.cpp:        int field_count = class_body -> NumClassVariables() +
decl.cpp:                          class_body -> NumInstanceVariables();
decl.cpp:                           class_body -> identifier_token,
decl.cpp:                           this_type -> Name());
decl.cpp:    if (! this_type -> Implements(control.Serializable()))
decl.cpp:    if (this_type -> IsInner())
decl.cpp:                       class_body -> identifier_token);
decl.cpp:    for (unsigned i = 0; i < class_body -> NumClassVariables(); ++i)
decl.cpp:        AstFieldDeclaration* fd = class_body -> ClassVariable(i);
decl.cpp:        for (unsigned j = 0; j < fd -> NumVariableDeclarators(); ++j)
decl.cpp:            AstVariableDeclarator* vd = fd -> VariableDeclarator(j);
decl.cpp:            NameSymbol* name_symbol = lex_stream -> NameSymbol(vd ->
decl.cpp:                variable_declarator_name -> identifier_token);
decl.cpp:                       class_body -> identifier_token);
decl.cpp:    state_stack.Push(class_body -> semantic_environment);
decl.cpp:    assert(! this_type -> ConstructorMembersProcessed() || this_type -> Bad());
decl.cpp:    assert(! this_type -> MethodMembersProcessed() || this_type -> Bad());
decl.cpp:    assert(! this_type -> FieldMembersProcessed() || this_type -> Bad());
decl.cpp:    delete this_type -> innertypes_closure; // save some space !!!
decl.cpp:    this_type -> innertypes_closure = NULL;
decl.cpp:    if (this_type -> IsInner())
decl.cpp:        for (i = 0; i < class_body -> NumStaticInitializers(); i++)
decl.cpp:                           class_body -> StaticInitializer(i),
decl.cpp:                           this_type -> Name(), this_type -> FileLoc());
decl.cpp:    for (i = 0; i < this_type -> NumNestedTypes(); i++)
decl.cpp:        TypeSymbol* inner_type = this_type -> NestedType(i);
decl.cpp:        ProcessMembers(inner_type -> declaration);
decl.cpp:    if (compilation_unit -> BadCompilationUnitCast())
decl.cpp:    state_stack.Push(class_body -> semantic_environment);
decl.cpp:    TokenIndex identifier = class_body -> identifier_token;
decl.cpp:    assert(this_type -> ConstructorMembersProcessed());
decl.cpp:    assert(this_type -> MethodMembersProcessed());
decl.cpp:    assert(this_type -> FieldMembersProcessed());
decl.cpp:    if (! this_type -> expanded_method_table)
decl.cpp:    if (this_type -> super && ! this_type -> Bad())
decl.cpp:        if (! this_type -> ACC_ABSTRACT())
decl.cpp:                this_type -> expanded_method_table;
decl.cpp:                 i < expanded_table -> symbol_pool.Length(); i++)
decl.cpp:                    expanded_table -> symbol_pool[i] -> method_symbol;
decl.cpp:                if (method -> ACC_ABSTRACT())
decl.cpp:                    TypeSymbol* containing_type = method -> containing_type;
decl.cpp:                        if (! method -> IsTyped())
decl.cpp:                            method -> ProcessMethodSignature(this, identifier);
decl.cpp:                                       identifier, method -> Header(),
decl.cpp:                                       containing_type -> ContainingPackageName(),
decl.cpp:                                       containing_type -> ExternalName(),
decl.cpp:                                       this_type -> ContainingPackageName(),
decl.cpp:                                       this_type -> ExternalName());
decl.cpp:        PackageSymbol* package = this_type -> ContainingPackage();
decl.cpp:        for (TypeSymbol* super_type = this_type -> super;
decl.cpp:             super_type && super_type -> ACC_ABSTRACT();
decl.cpp:             super_type = super_type -> super)
decl.cpp:            if (super_type -> ContainingPackage() == package)
decl.cpp:            package = super_type -> ContainingPackage();
decl.cpp:                super_type -> expanded_method_table;
decl.cpp:                 i < super_expanded_table -> symbol_pool.Length(); i++)
decl.cpp:                    super_expanded_table -> symbol_pool[i] -> method_symbol;
decl.cpp:                // non-default methods were inherited.
decl.cpp:                if (! method -> ACC_ABSTRACT() || method -> ACC_PUBLIC() ||
decl.cpp:                    method -> ACC_PROTECTED())
decl.cpp:                TypeSymbol* containing_type = method -> containing_type;
decl.cpp:                if (! method -> IsTyped())
decl.cpp:                    method -> ProcessMethodSignature(this, identifier);
decl.cpp:                     intermediate = intermediate -> super)
decl.cpp:                    MethodShadowSymbol* shadow = intermediate ->
decl.cpp:                        expanded_method_table ->
decl.cpp:                    if (intermediate -> ContainingPackage() != package)
decl.cpp:                        if ((shadow -> method_symbol -> ACC_PUBLIC() ||
decl.cpp:                             shadow -> method_symbol -> ACC_PROTECTED()) &&
decl.cpp:                            (shadow -> method_symbol -> Type() !=
decl.cpp:                             method -> Type()))
decl.cpp:                            if (method_clash == shadow -> method_symbol)
decl.cpp:                            else method_clash = shadow -> method_symbol;
decl.cpp:                    else if (shadow -> method_symbol -> containing_type ==
decl.cpp:                    ! this_type -> ACC_ABSTRACT())
decl.cpp:                    ReportSemError((this_type -> Anonymous()
decl.cpp:                                   identifier, method -> Header(),
decl.cpp:                                   containing_type -> ContainingPackageName(),
decl.cpp:                                   containing_type -> ExternalName(),
decl.cpp:                                   this_type -> ContainingPackageName(),
decl.cpp:                                   this_type -> ExternalName());
decl.cpp:                    TypeSymbol* base_type = method_clash -> containing_type;
decl.cpp:                                   this_type -> ContainingPackageName(),
decl.cpp:                                   this_type -> ExternalName(),
decl.cpp:                                   method_clash -> Header(),
decl.cpp:                                   base_type -> ContainingPackageName(),
decl.cpp:                                   base_type -> ExternalName(),
decl.cpp:                                   method -> Header(),
decl.cpp:                                   containing_type -> ContainingPackageName(),
decl.cpp:                                   containing_type -> ExternalName());
decl.cpp:    for (unsigned l = 0; l < this_type -> NumNestedTypes(); l++)
decl.cpp:        TypeSymbol* inner_type = this_type -> NestedType(l);
decl.cpp:        CompleteSymbolTable(inner_type -> declaration);
decl.cpp:    for (unsigned i = 0; i < compilation_unit -> NumTypeDeclarations(); i++)
decl.cpp:            compilation_unit -> TypeDeclaration(i);
decl.cpp:        if (type_declaration -> class_body &&
decl.cpp:            type_declaration -> class_body -> semantic_environment)
decl.cpp:            CleanUpType(type_declaration -> class_body ->
decl.cpp:                        semantic_environment -> Type());
decl.cpp:    type -> DeleteAnonymousTypes();
decl.cpp:    for (unsigned i = 0; i < type -> NumNestedTypes(); i++)
decl.cpp:        CleanUpType(type -> NestedType(i));
decl.cpp:    type -> CompressSpace(); // space optimization
decl.cpp:    for (unsigned j = 0; j < type -> NumMethodSymbols(); j++)
decl.cpp:        type -> MethodSym(j) -> CleanUp();
decl.cpp:    delete type -> local;
decl.cpp:    type -> local = NULL;
decl.cpp:    delete type -> non_local;
decl.cpp:    type -> non_local = NULL;
decl.cpp:    delete type -> semantic_environment;
decl.cpp:    type -> semantic_environment = NULL;
decl.cpp:    type -> declaration = NULL;
decl.cpp:    if (file_symbol && file_symbol -> IsJava())
decl.cpp:        if (! file_symbol -> semantic)
decl.cpp:        type = package -> FindTypeSymbol(name_symbol);
decl.cpp:            type = package -> InsertOuterTypeSymbol(name_symbol);
decl.cpp:            type -> MarkBad();
decl.cpp:            type -> outermost_type = type;
decl.cpp:            type -> supertypes_closure = new SymbolSet;
decl.cpp:            type -> subtypes = new SymbolSet;
decl.cpp:            type -> semantic_environment =
decl.cpp:                type -> super = (type == control.Throwable()
decl.cpp:            type -> SetOwner(package);
decl.cpp:            type -> SetSignature(control);
decl.cpp:            type -> file_symbol = file_symbol;
decl.cpp:            file_symbol -> types.Next() = type;
decl.cpp:                           type -> ContainingPackageName(),
decl.cpp:                           type -> ExternalName());
decl.cpp:        else if (file_symbol -> semantic -> NumErrors())
decl.cpp:                           name_symbol -> Name());
decl.cpp:        type = package -> InsertOuterTypeSymbol(name_symbol);
decl.cpp:        type -> outermost_type = type;
decl.cpp:        type -> supertypes_closure = new SymbolSet;
decl.cpp:        type -> subtypes = new SymbolSet;
decl.cpp:        type -> SetOwner(package);
decl.cpp:        type -> SetSignature(control);
decl.cpp:        type -> file_symbol = file_symbol;
decl.cpp:        type -> SetLocation();
decl.cpp:        file_symbol -> package = package;
decl.cpp:        file_symbol -> types.Next() = type;
decl.cpp:        assert (! type -> IsNested());
decl.cpp:        PackageSymbol* subpackage = package -> FindPackageSymbol(name_symbol);
decl.cpp:            subpackage = package -> InsertPackageSymbol(name_symbol);
decl.cpp:        if (subpackage -> directory.Length())
decl.cpp:            if (package -> directory.Length())
decl.cpp:                               subpackage -> PackageName());
decl.cpp:            type = package -> InsertOuterTypeSymbol(name_symbol);
decl.cpp:            type -> outermost_type = type;
decl.cpp:            type -> SetOwner(package);
decl.cpp:            type -> SetSignature(control);
decl.cpp:            type -> MarkBad();
decl.cpp:                           type -> ContainingPackageName(),
decl.cpp:                           type -> ExternalName());
decl.cpp:    NameSymbol* name_symbol = lex_stream -> NameSymbol(identifier_token);
decl.cpp:    TypeSymbol* outermost_type = type -> outermost_type;
decl.cpp:    if (! outermost_type -> non_local)
decl.cpp:        outermost_type -> non_local = new SymbolSet;
decl.cpp:    if (! outermost_type -> local)
decl.cpp:        outermost_type -> local = new SymbolSet;
decl.cpp:    int length = type -> ExternalNameLength() + 1 +
decl.cpp:        name_symbol -> NameLength(); // +1 for $,... +1 for $
decl.cpp:    wcscpy(external_name, type -> ExternalName());
decl.cpp:    wcscat(external_name, name_symbol -> Name());
decl.cpp:    TypeSymbol* inner_type = type -> InsertNestedTypeSymbol(name_symbol);
decl.cpp:    inner_type -> MarkBad();
decl.cpp:    inner_type -> outermost_type = type -> outermost_type;
decl.cpp:    inner_type -> supertypes_closure = new SymbolSet;
decl.cpp:    inner_type -> subtypes = new SymbolSet;
decl.cpp:    inner_type -> SetExternalIdentity(control.FindOrInsertName(external_name,
decl.cpp:    inner_type -> super = control.Object();
decl.cpp:    inner_type -> SetOwner(type);
decl.cpp:    if (! type -> Bad())
decl.cpp:                       inner_type -> ContainingPackageName(),
decl.cpp:                       inner_type -> ExternalName());
decl.cpp:    if (name -> base_opt)
decl.cpp:        ProcessImportQualifiedName(name -> base_opt);
decl.cpp:        Symbol* symbol = name -> base_opt -> symbol;
decl.cpp:        TypeSymbol* type = symbol -> TypeCast();
decl.cpp:            lex_stream -> NameSymbol(name -> identifier_token);
decl.cpp:            if (type -> Bad()) // Avoid chain-reaction errors.
decl.cpp:                name -> symbol = control.no_type;
decl.cpp:            if (! type -> expanded_type_table)
decl.cpp:                ComputeTypesClosure(type, name -> identifier_token);
decl.cpp:            TypeShadowSymbol* type_shadow_symbol = type ->
decl.cpp:                expanded_type_table -> FindTypeShadowSymbol(name_symbol);
decl.cpp:            // inherited and hence non-canonical). But we do need an extra
decl.cpp:                inner_type = type_shadow_symbol -> type_symbol;
decl.cpp:            else if (type != inner_type -> owner)
decl.cpp:                               name, name_symbol -> Name(),
decl.cpp:                               inner_type -> ContainingPackageName(),
decl.cpp:                               inner_type -> ExternalName());
decl.cpp:            else if (inner_type -> ACC_PRIVATE() ||
decl.cpp:                     (! inner_type -> ACC_PUBLIC() &&
decl.cpp:                      inner_type -> ContainingPackage() != this_package))
decl.cpp:            name -> symbol = inner_type;
decl.cpp:            PackageSymbol* package = symbol -> PackageCast();
decl.cpp:            type = package -> FindTypeSymbol(name_symbol);
decl.cpp:                                    name -> identifier_token);
decl.cpp:            else if (type -> SourcePending())
decl.cpp:                control.ProcessHeaders(type -> file_symbol);
decl.cpp:                if (! type -> ACC_PUBLIC() &&
decl.cpp:                    type -> ContainingPackage() != this_package)
decl.cpp:                name -> symbol = type;
decl.cpp:                    package -> FindPackageSymbol(name_symbol);
decl.cpp:                    subpackage = package -> InsertPackageSymbol(name_symbol);
decl.cpp:                name -> symbol = subpackage;
decl.cpp:        // all sorts (top-level or inner) can be imported by either kind of
decl.cpp:                                              name -> identifier_token);
decl.cpp:                           name -> identifier_token,
decl.cpp:                           lex_stream -> NameString(name -> identifier_token));
decl.cpp:            name -> symbol = control.no_type;
decl.cpp:                lex_stream -> NameSymbol(name -> identifier_token);
decl.cpp:            name -> symbol = package;
decl.cpp:// Processes a package-or-type name. If an accessible type exists, it is
decl.cpp:// The result is stored in name->symbol.
decl.cpp:    if (name -> base_opt)
decl.cpp:        ProcessPackageOrType(name -> base_opt);
decl.cpp:        Symbol* symbol = name -> base_opt -> symbol;
decl.cpp:        TypeSymbol* type = symbol -> TypeCast();
decl.cpp:            name -> symbol = MustFindNestedType(type, name);
decl.cpp:            PackageSymbol* package = symbol -> PackageCast();
decl.cpp:                lex_stream -> NameSymbol(name -> identifier_token);
decl.cpp:            type = package -> FindTypeSymbol(name_symbol);
decl.cpp:                                    name -> identifier_token);
decl.cpp:            else if (type -> SourcePending())
decl.cpp:                control.ProcessHeaders(type -> file_symbol);
decl.cpp:                name -> symbol = type;
decl.cpp:                    lex_stream -> NameSymbol(name -> identifier_token);
decl.cpp:                    package -> FindPackageSymbol(name_symbol);
decl.cpp:                    subpackage = package -> InsertPackageSymbol(name_symbol);
decl.cpp:                name -> symbol = subpackage;
decl.cpp:                if (subpackage -> directory.Length() == 0)
decl.cpp:                                   name -> identifier_token,
decl.cpp:                                   subpackage -> PackageName());
decl.cpp:        TypeSymbol* type = FindType(name -> identifier_token);
decl.cpp:            name -> symbol = type;
decl.cpp:                lex_stream -> NameSymbol(name -> identifier_token);
decl.cpp:            if (package -> directory.Length() == 0)
decl.cpp:                    NameSymbol* name_symbol = lex_stream ->
decl.cpp:                        NameSymbol(name -> identifier_token);
decl.cpp:                    for (TypeSymbol* super_type = ThisType() -> super;
decl.cpp:                         super_type; super_type = super_type -> super)
decl.cpp:                        assert(super_type -> expanded_type_table);
decl.cpp:                            super_type -> expanded_type_table ->
decl.cpp:                            type = type_shadow_symbol -> type_symbol;
decl.cpp:                    name -> symbol = type;
decl.cpp:                                   name -> identifier_token,
decl.cpp:                                   package -> PackageName());
decl.cpp:                    name -> symbol = package;
decl.cpp:            else name -> symbol = package;
decl.cpp:    ProcessImportQualifiedName(import_declaration -> name);
decl.cpp:    Symbol* symbol = import_declaration -> name -> symbol;
decl.cpp:    PackageSymbol* package = symbol -> PackageCast();
decl.cpp:    if (package && package -> directory.Length() == 0)
decl.cpp:                       import_declaration -> name,
decl.cpp:                       package -> PackageName());
decl.cpp:    // Two or more type-import-on-demand may name the same package; the effect
decl.cpp:    TypeSymbol* type = symbol -> TypeCast();
decl.cpp:        type -> IsDeprecated() && type -> file_symbol != source_file_symbol)
decl.cpp:                       import_declaration -> name,
decl.cpp:                       type -> ContainingPackageName(),
decl.cpp:                       type -> ExternalName());
decl.cpp:    NameSymbol* name_symbol = lex_stream -> NameSymbol(identifier_token);
decl.cpp:    TypeSymbol* type = package -> FindTypeSymbol(name_symbol);
decl.cpp:        if (type -> SourcePending())
decl.cpp:            control.ProcessHeaders(type -> file_symbol);
decl.cpp:    ProcessImportQualifiedName(import_declaration -> name);
decl.cpp:    Symbol* symbol = import_declaration -> name -> symbol;
decl.cpp:    PackageSymbol* package = symbol -> PackageCast();
decl.cpp:    TypeSymbol* type = symbol -> TypeCast();
decl.cpp:    // we can give a better message than "expected '.'". If a non-type is
decl.cpp:    // imported, we create a place-holder type so that the use of the
decl.cpp:                       import_declaration -> name,
decl.cpp:                       package -> PackageName());
decl.cpp:        NameSymbol* name_symbol = lex_stream ->
decl.cpp:            NameSymbol(import_declaration -> name -> RightToken());
decl.cpp:        type = package -> InsertOuterTypeSymbol(name_symbol);
decl.cpp:        type -> MarkBad();
decl.cpp:        type -> super = control.no_type;
decl.cpp:        type -> outermost_type = control.no_type;
decl.cpp:    // If two single-type-import declarations in the same compilation unit
decl.cpp:    // attempt to import types with the same simple name, then a compile-time
decl.cpp:    for (k = 0; k < compilation_unit -> NumTypeDeclarations(); k++)
decl.cpp:        AstDeclaredType* declaration = compilation_unit -> TypeDeclaration(k);
decl.cpp:        if (declaration -> class_body &&
decl.cpp:            declaration -> class_body -> semantic_environment)
decl.cpp:                declaration -> class_body -> semantic_environment -> Type();
decl.cpp:            if (old_type -> Identity() == type -> Identity())
decl.cpp:    if (k < compilation_unit -> NumTypeDeclarations())
decl.cpp:        AstName* name = import_declaration -> name;
decl.cpp:        package = name -> base_opt
decl.cpp:            ? name -> base_opt -> symbol -> PackageCast()
decl.cpp:                           lex_stream -> NameString(name -> identifier_token),
decl.cpp:                           old_type -> FileLoc());
decl.cpp:                           lex_stream -> NameString(name -> identifier_token),
decl.cpp:                           old_type -> FileLoc());
decl.cpp:        for (i = 0; i < compilation_unit -> NumImportDeclarations(); i++)
decl.cpp:                compilation_unit -> ImportDeclaration(i) -> name -> Type();
decl.cpp:            if (compilation_unit -> ImportDeclaration(i) == import_declaration ||
decl.cpp:                (other_type && other_type -> Identity() == type -> Identity()))
decl.cpp:        assert(i < compilation_unit -> NumImportDeclarations());
decl.cpp:        if (compilation_unit -> ImportDeclaration(i) == import_declaration)
decl.cpp:            import_declaration -> name -> symbol = type;
decl.cpp:            AstName* name = compilation_unit -> ImportDeclaration(i) -> name;
decl.cpp:            FileLocation file_location(lex_stream, name -> identifier_token);
decl.cpp:                           lex_stream -> NameString(name -> identifier_token),
decl.cpp:    if (control.option.deprecation && type -> IsDeprecated() &&
decl.cpp:        type -> file_symbol != source_file_symbol)
decl.cpp:                       import_declaration -> name,
decl.cpp:                       type -> ContainingPackageName(),
decl.cpp:                       type -> ExternalName());
decl.cpp:    AccessFlags access_flags = this_type -> ACC_INTERFACE()
decl.cpp:    // JLS2 8.1.2 - Inner classes may not have static fields unless they are
decl.cpp:    // initializer, we check that it is indeed a compile-time constant
decl.cpp:    if (this_type -> IsInner() && access_flags.ACC_STATIC())
decl.cpp:            assert(field_declaration -> modifiers_opt &&
decl.cpp:                   field_declaration -> modifiers_opt -> static_token_opt);
decl.cpp:                           field_declaration -> modifiers_opt -> static_token_opt,
decl.cpp:                           this_type -> Name(),
decl.cpp:                           this_type -> FileLoc());
decl.cpp:        lex_stream -> IsDeprecated(field_declaration -> LeftToken());
decl.cpp:    bool deprecated_type = this_type -> IsDeprecated();
decl.cpp:        this_type -> MarkDeprecated();
decl.cpp:    ProcessType(field_declaration -> type);
decl.cpp:    TypeSymbol* field_type = field_declaration -> type -> symbol;
decl.cpp:        this_type -> ResetDeprecated();
decl.cpp:         i < field_declaration -> NumVariableDeclarators(); i++)
decl.cpp:            field_declaration -> VariableDeclarator(i);
decl.cpp:            variable_declarator -> variable_declarator_name;
decl.cpp:            lex_stream -> NameSymbol(name -> identifier_token);
decl.cpp:        if (this_type -> FindVariableSymbol(name_symbol))
decl.cpp:                           name -> identifier_token, name_symbol -> Name(),
decl.cpp:                           this_type -> Name(),
decl.cpp:                           this_type -> FindVariableSymbol(name_symbol) -> FileLoc());
decl.cpp:                this_type -> InsertVariableSymbol(name_symbol);
decl.cpp:                field_type -> num_dimensions + name -> NumBrackets();
decl.cpp:            variable -> SetType(field_type -> GetArrayType(this, dims));
decl.cpp:            variable -> SetFlags(access_flags);
decl.cpp:            variable -> SetOwner(this_type);
decl.cpp:            variable -> declarator = variable_declarator;
decl.cpp:                (dims || ! variable_declarator -> variable_initializer_opt ||
decl.cpp:                 (! field_type -> Primitive() &&
decl.cpp:                               name -> identifier_token, name_symbol -> Name(),
decl.cpp:                               this_type -> Name(), this_type -> FileLoc());
decl.cpp:            variable_declarator -> symbol = variable;
decl.cpp:            variable -> SetLocation();
decl.cpp:                variable -> MarkDeprecated();
decl.cpp:    TypeSymbol* field_type = field_declaration -> type -> symbol;
decl.cpp:    NameSymbol* name_symbol = lex_stream ->
decl.cpp:        NameSymbol(name -> identifier_token);
decl.cpp:        field_type -> IsArray())
decl.cpp:        // FIXME: shouldn't warn if it's a zero-length array.
decl.cpp:                       name, name_symbol -> Name());
decl.cpp:        bool is_serializable = this_type -> Implements(control.Serializable());
decl.cpp:        name_symbol -> IsBadStyleForConstantField())
decl.cpp:                       name -> identifier_token, name_symbol -> Name());
decl.cpp:             name_symbol -> IsBadStyleForField())
decl.cpp:                       name -> identifier_token, name_symbol -> Name());
decl.cpp:    if (this_type -> ACC_STRICTFP())
decl.cpp:    if (constructor_declaration -> type_parameters_opt)
decl.cpp:                       constructor_declaration -> type_parameters_opt);
decl.cpp:        constructor_declaration -> constructor_declarator;
decl.cpp:        lex_stream -> NameString(constructor_declarator -> identifier_token);
decl.cpp:    if (this_type -> Anonymous())
decl.cpp:    else if (lex_stream -> NameSymbol(constructor_declarator -> identifier_token) != this_type -> Identity())
decl.cpp:        if (Spell::Index(constructor_name, this_type -> Name()) >= 5)
decl.cpp:                           constructor_declarator -> identifier_token,
decl.cpp:                           constructor_name, this_type -> Name());
decl.cpp:            constructor_name = this_type -> Name(); // correct the name
decl.cpp:                           constructor_declarator -> identifier_token,
decl.cpp:                           constructor_name, this_type -> Name());
decl.cpp:    // margin for one-liners.
decl.cpp:        new BlockSymbol(constructor_declarator -> NumFormalParameters() + 3);
decl.cpp:    block_symbol -> max_variable_index = 1;
decl.cpp:        ? lex_stream -> NameSymbol(constructor_declarator -> identifier_token)
decl.cpp:    MethodSymbol* constructor = this_type -> FindMethodSymbol(name_symbol);
decl.cpp:    if (constructor && this_type -> FindOverloadMethod(constructor,
decl.cpp:                       constructor_declarator, this_type -> Name(),
decl.cpp:                       constructor -> FileLoc());
decl.cpp:    constructor = this_type -> InsertMethodSymbol(name_symbol);
decl.cpp:    constructor -> SetType(ctor_type);
decl.cpp:    constructor -> SetFlags(access_flags);
decl.cpp:    constructor -> SetContainingType(this_type);
decl.cpp:    constructor -> SetBlockSymbol(block_symbol);
decl.cpp:    constructor -> declaration = constructor_declaration;
decl.cpp:    constructor -> SetLocation();
decl.cpp:    if (this_type -> EnclosingType())
decl.cpp:            block_symbol -> InsertVariableSymbol(control.this_name_symbol);
decl.cpp:        this0_variable -> SetType(this_type -> ContainingType());
decl.cpp:        this0_variable -> SetOwner(constructor);
decl.cpp:        this0_variable -> SetLocalVariableIndex(block_symbol ->
decl.cpp:        this0_variable -> MarkComplete();
decl.cpp:        this0_variable -> SetACC_SYNTHETIC();
decl.cpp:         i < constructor_declarator -> NumFormalParameters(); i++)
decl.cpp:            constructor_declarator -> FormalParameter(i) -> formal_declarator;
decl.cpp:        VariableSymbol* symbol = formal_declarator -> symbol;
decl.cpp:        symbol -> SetOwner(constructor);
decl.cpp:        symbol -> SetLocalVariableIndex(block_symbol -> max_variable_index++);
decl.cpp:        symbol -> MarkComplete();
decl.cpp:        if (control.IsDoubleWordType(symbol -> Type()))
decl.cpp:            block_symbol -> max_variable_index++;
decl.cpp:        symbol -> declarator = formal_declarator;
decl.cpp:        symbol -> SetLocation();
decl.cpp:        constructor -> AddFormalParameter(symbol);
decl.cpp:    constructor -> SetSignature(control);
decl.cpp:    for (unsigned k = 0; k < constructor_declaration -> NumThrows(); k++)
decl.cpp:        AstTypeName* throw_expr = constructor_declaration -> Throw(k);
decl.cpp:        constructor -> AddThrows(throw_expr -> symbol);
decl.cpp:    constructor_declaration -> constructor_symbol = constructor;
decl.cpp:    if (lex_stream -> IsDeprecated(constructor_declaration -> LeftToken()))
decl.cpp:        constructor -> MarkDeprecated();
decl.cpp:    assert(! type -> ACC_INTERFACE());
decl.cpp:        type -> InsertMethodSymbol(control.init_name_symbol);
decl.cpp:    block_symbol -> max_variable_index = 1; // All types need a spot for "this"
decl.cpp:    constructor -> SetType(type);
decl.cpp:    constructor -> SetContainingType(type);
decl.cpp:    constructor -> SetBlockSymbol(block_symbol);
decl.cpp:    if (type -> ACC_PUBLIC())
decl.cpp:        constructor -> SetACC_PUBLIC();
decl.cpp:    else if (type -> ACC_PROTECTED())
decl.cpp:        constructor -> SetACC_PROTECTED();
decl.cpp:    else if (type -> ACC_PRIVATE())
decl.cpp:        constructor -> SetACC_PRIVATE();
decl.cpp:    if (type -> ACC_STRICTFP())
decl.cpp:        constructor -> SetACC_STRICTFP();
decl.cpp:    if (type -> EnclosingType())
decl.cpp:            block_symbol -> InsertVariableSymbol(control.this_name_symbol);
decl.cpp:        this0_variable -> SetType(type -> ContainingType());
decl.cpp:        this0_variable -> SetOwner(constructor);
decl.cpp:        this0_variable -> SetLocalVariableIndex(block_symbol ->
decl.cpp:        this0_variable -> MarkComplete();
decl.cpp:        this0_variable -> SetACC_SYNTHETIC();
decl.cpp:    constructor -> SetSignature(control);
decl.cpp:    AstClassBody* class_body = type -> declaration;
decl.cpp:        TokenIndex left_loc = class_body -> identifier_token;
decl.cpp:        TokenIndex right_loc = class_body -> left_brace_token - 1;
decl.cpp:            compilation_unit -> ast_pool -> GenMethodDeclarator();
decl.cpp:        method_declarator -> identifier_token = left_loc;
decl.cpp:        method_declarator -> left_parenthesis_token = left_loc;
decl.cpp:        method_declarator -> right_parenthesis_token = right_loc;
decl.cpp:            super_call = compilation_unit -> ast_pool -> GenSuperCall();
decl.cpp:            super_call -> super_token = left_loc;
decl.cpp:            super_call -> arguments = compilation_unit -> ast_pool ->
decl.cpp:            super_call -> semicolon_token = right_loc;
decl.cpp:            compilation_unit -> ast_pool -> GenReturnStatement();
decl.cpp:        return_statement -> return_token = left_loc;
decl.cpp:        return_statement -> semicolon_token = left_loc;
decl.cpp:        return_statement -> is_reachable = true;
decl.cpp:            compilation_unit -> ast_pool -> GenMethodBody();
decl.cpp:        constructor_block -> block_symbol = new BlockSymbol(0);
decl.cpp:        constructor_block -> left_brace_token  = left_loc;
decl.cpp:        constructor_block -> right_brace_token = right_loc;
decl.cpp:        constructor_block -> AllocateStatements(1);
decl.cpp:        constructor_block -> AddStatement(return_statement);
decl.cpp:        constructor_block -> explicit_constructor_opt = super_call;
decl.cpp:            compilation_unit -> ast_pool -> GenConstructorDeclaration();
decl.cpp:        constructor_declaration -> constructor_declarator = method_declarator;
decl.cpp:        constructor_declaration -> constructor_body = constructor_block;
decl.cpp:        constructor_declaration -> constructor_symbol = constructor;
decl.cpp:        constructor -> declaration = constructor_declaration;
decl.cpp:        class_body -> default_constructor = constructor_declaration;
decl.cpp:// of which is necessarily abstract. If one is non-abstract, it must
decl.cpp:    assert(! hidden_method -> ACC_PRIVATE());
decl.cpp:        (method -> containing_type -> ACC_INTERFACE() &&
decl.cpp:         method -> containing_type != base_type &&
decl.cpp:         hidden_method -> containing_type == control.Object()))
decl.cpp:    if (method -> containing_type == base_type && ThisType() == base_type)
decl.cpp:            (AstMethodDeclaration*) method -> declaration;
decl.cpp:            method_declaration -> method_declarator;
decl.cpp:        left_tok = method_declarator -> LeftToken();
decl.cpp:        right_tok = method_declarator -> RightToken();
decl.cpp:        left_tok = ThisType() -> declaration -> identifier_token;
decl.cpp:        right_tok = ThisType() -> declaration -> left_brace_token - 1;
decl.cpp:    if (hidden_method -> Type() != method -> Type())
decl.cpp:        // support Object->Object covariance (and not primitive->primitive,
decl.cpp:        // void->primitive, or void->Object). When loading from .java files,
decl.cpp:        if (hidden_method -> Type() -> IsSubtype(control.Object()) &&
decl.cpp:            method -> Type() -> IsSubtype(hidden_method -> Type()))
decl.cpp:            // even for -source 1.4!
decl.cpp:                ! hidden_method -> containing_type ->
decl.cpp:                  file_symbol -> IsClassOnly())
decl.cpp:                               left_tok, right_tok, method -> Header(),
decl.cpp:                               hidden_method -> Header());
decl.cpp:        else if (method -> containing_type == base_type)
decl.cpp:            if (base_type -> ACC_INTERFACE() &&
decl.cpp:                hidden_method -> containing_type == control.Object())
decl.cpp:                if (hidden_method -> ACC_PUBLIC())
decl.cpp:                                   left_tok, right_tok, method -> Header(),
decl.cpp:                                   hidden_method -> Header());
decl.cpp:                    base_type -> MarkBad();
decl.cpp:                                   base_type -> ContainingPackageName(),
decl.cpp:                                   base_type -> ExternalName(),
decl.cpp:                                   method -> Header(),
decl.cpp:                                   hidden_method -> Header());
decl.cpp:                               left_tok, right_tok, method -> Header(),
decl.cpp:                               hidden_method -> Header(),
decl.cpp:                               hidden_method -> containing_type -> ContainingPackageName(),
decl.cpp:                               hidden_method -> containing_type -> ExternalName());
decl.cpp:                base_type -> MarkBad();
decl.cpp:                           left_tok, right_tok, base_type -> ExternalName(),
decl.cpp:                           method -> Header(),
decl.cpp:                           method -> containing_type -> ContainingPackageName(),
decl.cpp:                           method -> containing_type -> ExternalName(),
decl.cpp:                           hidden_method -> Header(),
decl.cpp:                           hidden_method -> containing_type -> ContainingPackageName(),
decl.cpp:                           hidden_method -> containing_type -> ExternalName());
decl.cpp:            base_type -> MarkBad();
decl.cpp:    if (method -> containing_type == base_type &&
decl.cpp:        (hidden_method -> ACC_FINAL() ||
decl.cpp:         hidden_method -> containing_type -> ACC_FINAL()))
decl.cpp:        if (base_type -> ACC_INTERFACE())
decl.cpp:                           left_tok, right_tok, method -> Header(),
decl.cpp:                           hidden_method -> Header());
decl.cpp:                           left_tok, right_tok, method -> Header(),
decl.cpp:                           hidden_method -> Header(),
decl.cpp:                           hidden_method -> containing_type -> ContainingPackageName(),
decl.cpp:                           hidden_method -> containing_type -> ExternalName());
decl.cpp:        base_type -> MarkBad();
decl.cpp:        hidden_method -> IsDeprecated() &&
decl.cpp:        ! method -> containing_type -> file_symbol -> IsClassOnly())
decl.cpp:                       left_tok, right_tok, method -> Header(),
decl.cpp:                       hidden_method -> containing_type -> ContainingPackageName(),
decl.cpp:                       hidden_method -> containing_type -> ExternalName());
decl.cpp:    if (method -> ACC_STATIC() != hidden_method -> ACC_STATIC())
decl.cpp:        if (method -> containing_type == base_type)
decl.cpp:            ReportSemError((method -> ACC_STATIC()
decl.cpp:                           left_tok, right_tok, method -> Header(),
decl.cpp:                           hidden_method -> Header(),
decl.cpp:                           hidden_method -> containing_type -> ContainingPackageName(),
decl.cpp:                           hidden_method -> containing_type -> ExternalName());
decl.cpp:            assert(method -> ACC_STATIC());
decl.cpp:                           left_tok, right_tok, base_type -> ExternalName(),
decl.cpp:                           method -> Header(),
decl.cpp:                           method -> containing_type -> ContainingPackageName(),
decl.cpp:                           method -> containing_type -> ExternalName(),
decl.cpp:                           hidden_method -> Header(),
decl.cpp:                           hidden_method -> containing_type -> ContainingPackageName(),
decl.cpp:                           hidden_method -> containing_type -> ExternalName());
decl.cpp:        base_type -> MarkBad();
decl.cpp:    if (hidden_method -> ACC_PUBLIC())
decl.cpp:        if (! method -> ACC_PUBLIC())
decl.cpp:            if (method -> containing_type == base_type)
decl.cpp:                               left_tok, right_tok, method -> Header(),
decl.cpp:                               method -> AccessString(),
decl.cpp:                               hidden_method -> Header(),
decl.cpp:                               hidden_method -> containing_type -> ContainingPackageName(),
decl.cpp:                               hidden_method -> containing_type -> ExternalName());
decl.cpp:                base_type -> MarkBad();
decl.cpp:            else if (! method -> ACC_ABSTRACT())
decl.cpp:                               base_type -> ExternalName(),
decl.cpp:                               method -> Header(),
decl.cpp:                               method -> AccessString(),
decl.cpp:                               method -> containing_type -> ContainingPackageName(),
decl.cpp:                               method -> containing_type -> ExternalName(),
decl.cpp:                               hidden_method -> Header(),
decl.cpp:                               hidden_method -> containing_type -> ContainingPackageName(),
decl.cpp:                               hidden_method -> containing_type -> ExternalName());
decl.cpp:                base_type -> MarkBad();
decl.cpp:    else if (hidden_method -> ACC_PROTECTED())
decl.cpp:        if (! method -> ACC_PROTECTED() &&
decl.cpp:            ! method -> ACC_PUBLIC())
decl.cpp:                           left_tok, right_tok, method -> Header(),
decl.cpp:                           method -> AccessString(),
decl.cpp:                           hidden_method -> Header(),
decl.cpp:                           hidden_method -> containing_type -> ContainingPackageName(),
decl.cpp:                           hidden_method -> containing_type -> ExternalName());
decl.cpp:            base_type -> MarkBad();
decl.cpp:    else if (method -> ACC_PRIVATE())
decl.cpp:                       left_tok, right_tok, method -> Header(),
decl.cpp:                       hidden_method -> Header(),
decl.cpp:                       hidden_method -> containing_type -> ContainingPackageName(),
decl.cpp:                       hidden_method -> containing_type -> ExternalName());
decl.cpp:        base_type -> MarkBad();
decl.cpp:    if (method -> containing_type != base_type && method -> ACC_ABSTRACT())
decl.cpp:    method -> ProcessMethodThrows(this, left_tok);
decl.cpp:    hidden_method -> ProcessMethodThrows(this, left_tok);
decl.cpp:    for (int i = method -> NumThrows() - 1; i >= 0; i--)
decl.cpp:        TypeSymbol* exception = method -> Throws(i);
decl.cpp:        for (k = hidden_method -> NumThrows() - 1; k >= 0; k--)
decl.cpp:            if (exception -> IsSubclass(hidden_method -> Throws(k)))
decl.cpp:            if (method -> containing_type == base_type)
decl.cpp:                if (base_type -> ACC_INTERFACE() &&
decl.cpp:                    hidden_method -> containing_type == control.Object())
decl.cpp:                    if (hidden_method -> ACC_PUBLIC())
decl.cpp:                                       exception -> Name(),
decl.cpp:                                       method -> Header());
decl.cpp:                        base_type -> MarkBad();
decl.cpp:                                   exception -> Name(),
decl.cpp:                                   hidden_method -> Header(),
decl.cpp:                                   hidden_method -> containing_type -> ContainingPackageName(),
decl.cpp:                                   hidden_method -> containing_type -> ExternalName());
decl.cpp:                    base_type -> MarkBad();
decl.cpp:                               base_type -> ExternalName(),
decl.cpp:                               exception -> Name(), method -> Header(),
decl.cpp:                               method -> containing_type -> ContainingPackageName(),
decl.cpp:                               method -> containing_type -> ExternalName(),
decl.cpp:                               hidden_method -> Header(),
decl.cpp:                               hidden_method -> containing_type -> ContainingPackageName(),
decl.cpp:                               hidden_method -> containing_type -> ExternalName());
decl.cpp:                base_type -> MarkBad();
decl.cpp:    if (super_type -> Bad())
decl.cpp:        base_type -> MarkBad();
decl.cpp:        *(base_type -> expanded_type_table);
decl.cpp:        *(super_type -> expanded_type_table);
decl.cpp:        TypeSymbol* type = type_shadow_symbol -> type_symbol;
decl.cpp:        if (type -> ACC_PUBLIC() ||
decl.cpp:            type -> ACC_PROTECTED() ||
decl.cpp:            (! type -> ACC_PRIVATE() &&
decl.cpp:             super_type -> ContainingPackage() == base_type -> ContainingPackage()))
decl.cpp:                base_expanded_table.FindTypeShadowSymbol(type -> Identity());
decl.cpp:            if (! shadow || shadow -> type_symbol -> owner != base_type)
decl.cpp:                else shadow -> AddConflict(type);
decl.cpp:                assert(type -> owner != super_type ||
decl.cpp:                       type_shadow_symbol -> NumConflicts() == 0);
decl.cpp:                     j < type_shadow_symbol -> NumConflicts(); j++)
decl.cpp:                    shadow -> AddConflict(type_shadow_symbol -> Conflict(j));
decl.cpp:        else if (! type -> ACC_PRIVATE() &&
decl.cpp:                 type_shadow_symbol -> NumConflicts())
decl.cpp:            assert(type -> owner != super_type);
decl.cpp:                base_expanded_table.FindTypeShadowSymbol(type -> Identity());
decl.cpp:                assert(shadow -> type_symbol -> owner == base_type);
decl.cpp:                    InsertTypeShadowSymbol(type_shadow_symbol -> Conflict(0));
decl.cpp:                     k < type_shadow_symbol -> NumConflicts(); k++)
decl.cpp:                    shadow -> AddConflict(type_shadow_symbol -> Conflict(k));
decl.cpp:    if (super_type -> Bad())
decl.cpp:        base_type -> MarkBad();
decl.cpp:        *(base_type -> expanded_field_table);
decl.cpp:        *(super_type -> expanded_field_table);
decl.cpp:        VariableSymbol* variable = variable_shadow_symbol -> variable_symbol;
decl.cpp:        if (variable -> ACC_PUBLIC() ||
decl.cpp:            variable -> ACC_PROTECTED() ||
decl.cpp:            (! variable -> ACC_PRIVATE() &&
decl.cpp:             super_type -> ContainingPackage() == base_type -> ContainingPackage()))
decl.cpp:                FindVariableShadowSymbol(variable -> Identity());
decl.cpp:            if (! shadow || shadow -> variable_symbol -> owner != base_type)
decl.cpp:                else shadow -> AddConflict(variable);
decl.cpp:                assert(variable -> owner != super_type ||
decl.cpp:                       variable_shadow_symbol -> NumConflicts() == 0);
decl.cpp:                     j < variable_shadow_symbol -> NumConflicts(); j++)
decl.cpp:                    shadow -> AddConflict(variable_shadow_symbol ->
decl.cpp:        else if (! variable -> ACC_PRIVATE() &&
decl.cpp:                 ! variable -> ACC_SYNTHETIC() &&
decl.cpp:                 variable_shadow_symbol -> NumConflicts())
decl.cpp:            assert(variable -> owner != super_type);
decl.cpp:                FindVariableShadowSymbol(variable -> Identity());
decl.cpp:                assert(shadow -> variable_symbol -> owner == base_type);
decl.cpp:                    InsertVariableShadowSymbol(variable_shadow_symbol ->
decl.cpp:                     k < variable_shadow_symbol -> NumConflicts(); k++)
decl.cpp:                    shadow -> AddConflict(variable_shadow_symbol ->
decl.cpp:    if (super_type -> Bad())
decl.cpp:        base_type -> MarkBad();
decl.cpp:        base_type -> expanded_method_table;
decl.cpp:        super_type -> expanded_method_table;
decl.cpp:    PackageSymbol* base_package = base_type -> ContainingPackage();
decl.cpp:    for (i = 0; i < super_expanded_table -> symbol_pool.Length(); i++)
decl.cpp:            super_expanded_table -> symbol_pool[i];
decl.cpp:        MethodSymbol* method = method_shadow_symbol -> method_symbol;
decl.cpp:        if ((base_type -> ACC_INTERFACE() &&
decl.cpp:             super_type -> ACC_INTERFACE() &&
decl.cpp:             method -> containing_type == control.Object()) ||
decl.cpp:            method -> ACC_SYNTHETIC())
decl.cpp:        if (method -> ACC_PUBLIC() || method -> ACC_PROTECTED() ||
decl.cpp:            (! method -> ACC_PRIVATE() &&
decl.cpp:             super_type -> ContainingPackage() == base_package))
decl.cpp:            MethodShadowSymbol* shadow = base_expanded_table ->
decl.cpp:                CheckMethodOverride(shadow -> method_symbol, method,
decl.cpp:                     m < method_shadow_symbol -> NumConflicts(); m++)
decl.cpp:                    CheckMethodOverride(shadow -> method_symbol,
decl.cpp:                                        method_shadow_symbol -> Conflict(m),
decl.cpp:                shadow -> method_symbol -> containing_type != base_type)
decl.cpp:                    shadow = base_expanded_table -> Overload(method);
decl.cpp:                else shadow -> AddConflict(method);
decl.cpp:                assert(method -> containing_type != super_type ||
decl.cpp:                       method_shadow_symbol -> NumConflicts() == 0);
decl.cpp:                     j < method_shadow_symbol -> NumConflicts(); j++)
decl.cpp:                    shadow -> AddConflict(method_shadow_symbol -> Conflict(j));
decl.cpp:        else if (! method -> ACC_PRIVATE())
decl.cpp:            MethodShadowSymbol* shadow = base_expanded_table ->
decl.cpp:            if (method_shadow_symbol -> NumConflicts())
decl.cpp:                assert(method -> containing_type != super_type);
decl.cpp:                    assert(shadow -> method_symbol -> containing_type == base_type);
decl.cpp:                         k < method_shadow_symbol -> NumConflicts(); k++)
decl.cpp:                        CheckMethodOverride(shadow -> method_symbol,
decl.cpp:                                            method_shadow_symbol -> Conflict(k),
decl.cpp:                    shadow = base_expanded_table ->
decl.cpp:                        Overload(method_shadow_symbol -> Conflict(0));
decl.cpp:                         l < method_shadow_symbol -> NumConflicts(); l++)
decl.cpp:                        shadow -> AddConflict(method_shadow_symbol ->
decl.cpp:                assert(shadow -> method_symbol -> containing_type ==
decl.cpp:                        (AstMethodDeclaration*) shadow -> method_symbol -> declaration;
decl.cpp:                        method_declaration -> method_declarator;
decl.cpp:                    left_tok = method_declarator -> LeftToken();
decl.cpp:                    right_tok = method_declarator -> RightToken();
decl.cpp:                    left_tok = ThisType() -> declaration -> identifier_token;
decl.cpp:                        ThisType() -> declaration -> right_brace_token - 1;
decl.cpp:                if (! method -> IsTyped())
decl.cpp:                    method -> ProcessMethodSignature(this, tok);
decl.cpp:                if (! method -> ACC_ABSTRACT() ||
decl.cpp:                    method -> Type() == shadow -> method_symbol -> Type() ||
decl.cpp:                    (! shadow -> method_symbol -> ACC_PUBLIC() &&
decl.cpp:                     ! shadow -> method_symbol -> ACC_PROTECTED()))
decl.cpp:                                   left_tok, right_tok, method -> Header(),
decl.cpp:                                   base_type -> ContainingPackageName(),
decl.cpp:                                   base_type -> ExternalName(),
decl.cpp:                                   super_type -> ContainingPackageName(),
decl.cpp:                                   super_type -> ExternalName());
decl.cpp:    // reentered the package, the non-inherited default methods were
decl.cpp:    // is non-inherited only if a class C is in the package, it's subclass
decl.cpp:    while (super_type -> super)
decl.cpp:        super_type = super_type -> super;
decl.cpp:        if (prev -> ContainingPackage() == base_package ||
decl.cpp:            super_type -> ContainingPackage() != base_package)
decl.cpp:        super_expanded_table = super_type -> expanded_method_table;
decl.cpp:        for (i = 0; i < super_expanded_table -> symbol_pool.Length(); i++)
decl.cpp:                super_expanded_table -> symbol_pool[i];
decl.cpp:            MethodSymbol* method = method_shadow_symbol -> method_symbol;
decl.cpp:            if (! method -> ACC_PUBLIC() && ! method -> ACC_PROTECTED() &&
decl.cpp:                ! method -> ACC_PRIVATE() && ! method -> ACC_SYNTHETIC() &&
decl.cpp:                method_shadow_symbol -> NumConflicts() == 0)
decl.cpp:                // found a non-inherited package scope method
decl.cpp:                MethodShadowSymbol* shadow = base_expanded_table ->
decl.cpp:                    shadow -> method_symbol -> containing_type == base_type)
decl.cpp:                    CheckMethodOverride(shadow -> method_symbol, method,
decl.cpp:    if (! type -> HeaderProcessed())
decl.cpp:        type -> ProcessTypeHeaders();
decl.cpp:    type -> expanded_type_table = new ExpandedTypeTable();
decl.cpp:    TypeSymbol* super_class = type -> super;
decl.cpp:        if (! super_class -> expanded_type_table)
decl.cpp:    for (unsigned j = 0; j < type -> NumInterfaces(); j++)
decl.cpp:        TypeSymbol* interf = type -> Interface(j);
decl.cpp:        if (! interf -> expanded_type_table)
decl.cpp:    if (! type -> NestedTypesProcessed())
decl.cpp:        type -> ProcessNestedTypeSignatures(this, tok);
decl.cpp:    for (unsigned i = 0; i < type -> NumTypeSymbols(); i++)
decl.cpp:        if (! type -> TypeSym(i) -> Bad())
decl.cpp:            type -> expanded_type_table ->
decl.cpp:                InsertTypeShadowSymbol(type -> TypeSym(i));
decl.cpp:    for (unsigned k = 0; k < type -> NumInterfaces(); k++)
decl.cpp:        AddInheritedTypes(type, type -> Interface(k));
decl.cpp:    type -> expanded_type_table -> CompressSpace();
decl.cpp:    type -> expanded_field_table = new ExpandedFieldTable();
decl.cpp:    TypeSymbol* super_class = type -> super;
decl.cpp:        if (! super_class -> expanded_field_table)
decl.cpp:    for (unsigned j = 0; j < type -> NumInterfaces(); j++)
decl.cpp:        TypeSymbol* interf = type -> Interface(j);
decl.cpp:        if (! interf -> expanded_field_table)
decl.cpp:    assert(type -> FieldMembersProcessed());
decl.cpp:    for (unsigned i = 0; i < type -> NumVariableSymbols(); i++)
decl.cpp:        VariableSymbol* variable = type -> VariableSym(i);
decl.cpp:        type -> expanded_field_table -> InsertVariableShadowSymbol(variable);
decl.cpp:    for (unsigned k = 0; k < type -> NumInterfaces(); k++)
decl.cpp:        AddInheritedFields(type, type -> Interface(k));
decl.cpp:    type -> expanded_field_table -> CompressSpace();
decl.cpp:    type -> expanded_method_table = new ExpandedMethodTable();
decl.cpp:    TypeSymbol* super_class = type -> super;
decl.cpp:        if (! super_class -> expanded_method_table)
decl.cpp:    for (unsigned j = 0; j < type -> NumInterfaces(); j++)
decl.cpp:        TypeSymbol* interf = type -> Interface(j);
decl.cpp:        if (! interf -> expanded_method_table)
decl.cpp:    assert(type -> MethodMembersProcessed());
decl.cpp:    for (unsigned i = 0; i < type -> NumMethodSymbols(); i++)
decl.cpp:        MethodSymbol* method = type -> MethodSym(i);
decl.cpp:        if (*(method -> Name()) != U_LESS)
decl.cpp:            type -> expanded_method_table -> Overload(method);
decl.cpp:    if (super_class && ! type -> ACC_INTERFACE())
decl.cpp:    for (unsigned k = 0; k < type -> NumInterfaces(); k++)
decl.cpp:        AddInheritedMethods(type, type -> Interface(k), tok);
decl.cpp:    if (type -> ACC_INTERFACE()) // the super class is Object
decl.cpp:    type -> expanded_method_table -> CompressSpace();
decl.cpp:    for (unsigned i = 0; i < method_declarator -> NumFormalParameters(); i++)
decl.cpp:            method_declarator -> FormalParameter(i);
decl.cpp:        ProcessType(parameter -> type);
decl.cpp:        TypeSymbol* parm_type = parameter -> type -> symbol;
decl.cpp:            parameter -> formal_declarator -> variable_declarator_name;
decl.cpp:            lex_stream -> NameSymbol(name -> identifier_token);
decl.cpp:        VariableSymbol* symbol = block -> FindVariableSymbol(name_symbol);
decl.cpp:                           name -> identifier_token, name_symbol -> Name());
decl.cpp:        else symbol = block -> InsertVariableSymbol(name_symbol);
decl.cpp:        unsigned dims = parm_type -> num_dimensions + name -> NumBrackets();
decl.cpp:        if (parameter -> ellipsis_token_opt)
decl.cpp:            assert(i == method_declarator -> NumFormalParameters() - 1);
decl.cpp:                               parameter -> ellipsis_token_opt);
decl.cpp:        symbol -> SetType(parm_type -> GetArrayType(this, dims));
decl.cpp:        symbol -> SetFlags(access_flags);
decl.cpp:        symbol -> MarkComplete();
decl.cpp:        symbol -> MarkInitialized();
decl.cpp:        parameter -> formal_declarator -> symbol = symbol;
decl.cpp:    AccessFlags access_flags = this_type -> ACC_INTERFACE()
decl.cpp:    if (access_flags.ACC_PRIVATE() || this_type -> ACC_FINAL())
decl.cpp:    if (this_type -> ACC_STRICTFP())
decl.cpp:    if (method_declaration -> type_parameters_opt)
decl.cpp:                       method_declaration -> type_parameters_opt);
decl.cpp:    if (access_flags.ACC_STATIC() && this_type -> IsInner())
decl.cpp:        assert(method_declaration -> modifiers_opt &&
decl.cpp:               method_declaration -> modifiers_opt -> static_token_opt);
decl.cpp:                       method_declaration -> modifiers_opt -> static_token_opt,
decl.cpp:                       lex_stream -> NameString(method_declaration -> method_declarator -> identifier_token),
decl.cpp:                       this_type -> Name(),
decl.cpp:                       this_type -> FileLoc());
decl.cpp:        lex_stream -> IsDeprecated(method_declaration -> LeftToken());
decl.cpp:    bool deprecated_type = this_type -> IsDeprecated();
decl.cpp:        this_type -> MarkDeprecated();
decl.cpp:    ProcessType(method_declaration -> type);
decl.cpp:    TypeSymbol* method_type = method_declaration -> type -> symbol;
decl.cpp:        method_declaration -> method_declarator;
decl.cpp:    if (method_declarator -> NumBrackets())
decl.cpp:                           method_declaration -> type -> LeftToken(),
decl.cpp:                           method_declarator -> RightToken());
decl.cpp:        lex_stream -> NameSymbol(method_declarator -> identifier_token);
decl.cpp:    if (name_symbol == this_type -> Identity())
decl.cpp:                       method_declaration -> type -> LeftToken(),
decl.cpp:                       method_declarator -> identifier_token,
decl.cpp:                       name_symbol -> Name());
decl.cpp:    if (name_symbol -> IsBadStyleForMethod())
decl.cpp:                       method_declarator -> identifier_token,
decl.cpp:                       name_symbol -> Name());
decl.cpp:    // margin for one-liners.
decl.cpp:        new BlockSymbol(method_declarator -> NumFormalParameters());
decl.cpp:    block_symbol -> max_variable_index = (access_flags.ACC_STATIC() ? 0 : 1);
decl.cpp:        this_type -> ResetDeprecated();
decl.cpp:    MethodSymbol* method = this_type -> FindMethodSymbol(name_symbol);
decl.cpp:    if (method && this_type -> FindOverloadMethod(method, method_declarator))
decl.cpp:                       method_declarator, name_symbol -> Name(),
decl.cpp:                       this_type -> Name(), method -> FileLoc());
decl.cpp:    method = this_type -> InsertMethodSymbol(name_symbol);
decl.cpp:        method_type -> num_dimensions + method_declarator -> NumBrackets();
decl.cpp:    method -> SetType(method_type -> GetArrayType(this, dims));
decl.cpp:    method -> SetFlags(access_flags);
decl.cpp:    method -> SetContainingType(this_type);
decl.cpp:    method -> SetBlockSymbol(block_symbol);
decl.cpp:    method -> declaration = method_declaration;
decl.cpp:    method -> SetLocation();
decl.cpp:    for (unsigned i = 0; i < method_declarator -> NumFormalParameters(); i++)
decl.cpp:            method_declarator -> FormalParameter(i) -> formal_declarator;
decl.cpp:        VariableSymbol* symbol = formal_declarator -> symbol;
decl.cpp:        symbol -> SetOwner(method);
decl.cpp:        symbol -> SetLocalVariableIndex(block_symbol -> max_variable_index++);
decl.cpp:        symbol -> MarkComplete();
decl.cpp:        if (control.IsDoubleWordType(symbol -> Type()))
decl.cpp:            block_symbol -> max_variable_index++;
decl.cpp:        symbol -> declarator = formal_declarator;
decl.cpp:        symbol -> SetLocation();
decl.cpp:        method -> AddFormalParameter(symbol);
decl.cpp:    method -> SetSignature(control);
decl.cpp:    for (unsigned k = 0; k < method_declaration -> NumThrows(); k++)
decl.cpp:        AstTypeName* throw_expr = method_declaration -> Throw(k);
decl.cpp:        method -> AddThrows(throw_expr -> symbol);
decl.cpp:    method_declaration -> method_symbol = method;
decl.cpp:    if (method -> ACC_ABSTRACT() && ! this_type -> ACC_ABSTRACT())
decl.cpp:                       method_declaration -> LeftToken(),
decl.cpp:                       method_declarator -> identifier_token,
decl.cpp:                       name_symbol -> Name(),
decl.cpp:                       this_type -> Name());
decl.cpp:        method -> MarkDeprecated();
decl.cpp:    switch (primitive_type -> kind)
decl.cpp:// Search the import-on-demand locations for a type with the given name. This
decl.cpp:// was found is non-canonical. If no type is found, NULL is returned.
decl.cpp:    // pre-filtered duplicate import-on-demands, as well as adding java.lang.*.
decl.cpp:            import_on_demand_packages[i] -> PackageCast();
decl.cpp:            possible_type = import_package -> FindTypeSymbol(name_symbol);
decl.cpp:            else if (possible_type -> SourcePending())
decl.cpp:                control.ProcessHeaders(possible_type -> file_symbol);
decl.cpp:            if (! import_type -> expanded_type_table)
decl.cpp:            TypeShadowSymbol* type_shadow_symbol = import_type ->
decl.cpp:                expanded_type_table -> FindTypeShadowSymbol(name_symbol);
decl.cpp:                // inherited types from interfaces (and hence non-canonical).
decl.cpp:                possible_type = (type_shadow_symbol -> NumConflicts()
decl.cpp:                                 ? type_shadow_symbol -> Conflict(0)
decl.cpp:                                 : type_shadow_symbol -> type_symbol);
decl.cpp:                if (! possible_type -> ACC_PRIVATE() &&
decl.cpp:                    import_type == possible_type -> owner)
decl.cpp:                    import_package = import_type -> ContainingPackage();
decl.cpp:                (possible_type -> ACC_PUBLIC() ||
decl.cpp:                               identifier_token, name_symbol -> Name(),
decl.cpp:                               location -> PackageName(),
decl.cpp:                               import_package -> PackageName());
decl.cpp:                if (type -> ACC_PUBLIC() || import_package == this_package)
decl.cpp:    if (type && ! location && ! type -> ACC_PRIVATE() &&
decl.cpp:        (type -> ACC_PUBLIC() || type -> ContainingPackage() == this_package))
decl.cpp:                       identifier_token, type -> Name(),
decl.cpp:                       type -> ContainingPackageName(),
decl.cpp:                       type -> ExternalName());
decl.cpp:// process. Note that inaccessible types are skipped - if the caller wishes
decl.cpp:    NameSymbol* name_symbol = lex_stream -> NameSymbol(identifier_token);
decl.cpp:    for ( ; env; env = env -> previous)
decl.cpp:        type = env -> symbol_table.FindTypeSymbol(name_symbol);
decl.cpp:        type = env -> Type();
decl.cpp:        if (! type -> expanded_type_table)
decl.cpp:            type -> expanded_type_table -> FindTypeShadowSymbol(name_symbol);
decl.cpp:        // A static type cannot access a non-static member type of an enclosing
decl.cpp:        if (this_type -> ACC_STATIC() && ! type -> ACC_STATIC() &&
decl.cpp:            ! this_type -> IsSubclass(type -> ContainingType()))
decl.cpp:                           this_type -> ContainingPackageName(),
decl.cpp:                           this_type -> ExternalName(),
decl.cpp:                           type -> ContainingPackageName(),
decl.cpp:                           type -> ExternalName(),
decl.cpp:                           env -> Type() -> ContainingPackageName(),
decl.cpp:                           env -> Type() -> ExternalName());
decl.cpp:        if (type -> owner -> TypeCast() && type -> owner != env -> Type())
decl.cpp:            TypeSymbol* supertype = (TypeSymbol*) type -> owner;
decl.cpp:            for ( ; env; env = env -> previous)
decl.cpp:                // First, check the enclosing type name - this is a caution,
decl.cpp:                if (name_symbol == env -> Type() -> Identity() &&
decl.cpp:                    env -> Type() != type)
decl.cpp:                                   lex_stream -> NameString(identifier_token),
decl.cpp:                                   type -> ContainingPackageName(),
decl.cpp:                                   type -> ExternalName(),
decl.cpp:                                   env -> Type() -> ContainingPackageName(),
decl.cpp:                                   env -> Type() -> ExternalName());
decl.cpp:                if (env -> previous && control.option.pedantic)
decl.cpp:                    SemanticEnvironment* env2 = env -> previous;
decl.cpp:                        env2 -> symbol_table.FindTypeSymbol(name_symbol);
decl.cpp:                        assert(outer_type -> owner -> MethodCast());
decl.cpp:                                       lex_stream -> NameString(identifier_token),
decl.cpp:                                       supertype -> ContainingPackageName(),
decl.cpp:                                       supertype -> ExternalName(),
decl.cpp:                                       ((MethodSymbol*) outer_type -> owner) -> Name());
decl.cpp:                    if (! env2 -> Type() -> expanded_type_table)
decl.cpp:                        ComputeTypesClosure(env2 -> Type(), identifier_token);
decl.cpp:                        env2 -> Type() -> expanded_type_table ->
decl.cpp:                        outer_type -> owner == env2 -> Type())
decl.cpp:                                       lex_stream -> NameString(identifier_token),
decl.cpp:                                       supertype -> ContainingPackageName(),
decl.cpp:                                       supertype -> ExternalName(),
decl.cpp:                                       env2 -> Type() -> ContainingPackageName(),
decl.cpp:                                       env2 -> Type() -> ExternalName());
decl.cpp:    // as a class or interface or imported by a single-type-import declaration.
decl.cpp:        if (name_symbol == type -> Identity())
decl.cpp:    // for an accessible import-on-demand.
decl.cpp:    TypeSymbol* imported_type = (! type || type -> Bad()
decl.cpp:        FileSymbol* file_symbol = type -> file_symbol;
decl.cpp:        if (file_symbol && type -> Identity() != file_symbol -> Identity() &&
decl.cpp:            file_symbol != this -> source_file_symbol)
decl.cpp:                           identifier_token, type -> Name(),
decl.cpp:                           file_symbol -> Name());
decl.cpp:    assert(! name -> base_opt);
decl.cpp:        lex_stream -> NameSymbol(name -> identifier_token);
decl.cpp:        for (TypeSymbol* super_type = ThisType() -> super;
decl.cpp:             super_type; super_type = super_type -> super)
decl.cpp:            assert(super_type -> expanded_type_table);
decl.cpp:            TypeShadowSymbol* type_shadow_symbol = super_type ->
decl.cpp:                expanded_type_table -> FindTypeShadowSymbol(name_symbol);
decl.cpp:                return type_shadow_symbol -> type_symbol;
decl.cpp:    return ImportType(name -> identifier_token, name_symbol);
decl.cpp:        lex_stream -> NameSymbol(name -> identifier_token);
decl.cpp:    if (! name -> base_opt)
decl.cpp:        type = FindType(name -> identifier_token);
decl.cpp:                    lex_stream -> NameSymbol(name -> identifier_token);
decl.cpp:                                name -> identifier_token);
decl.cpp:        ProcessPackageOrType(name -> base_opt);
decl.cpp:        Symbol* symbol = name -> base_opt -> symbol;
decl.cpp:        type = symbol -> TypeCast();
decl.cpp:            PackageSymbol* package = symbol -> PackageCast();
decl.cpp:            type = package -> FindTypeSymbol(name_symbol);
decl.cpp:                                name -> identifier_token);
decl.cpp:            else if (type -> SourcePending())
decl.cpp:                control.ProcessHeaders(type -> file_symbol);
decl.cpp:        if (control.option.deprecation && type -> IsDeprecated() &&
decl.cpp:                           type -> ContainingPackageName(),
decl.cpp:                           type -> ExternalName());
decl.cpp:    if (type -> Anonymous() && ! type -> Bad())
decl.cpp:                       type -> ContainingPackageName(),
decl.cpp:                       type -> ExternalName());
decl.cpp:    if (type -> ACC_SYNTHETIC() && ! type -> Bad())
decl.cpp:                       type -> ContainingPackageName(),
decl.cpp:                       type -> ExternalName());
decl.cpp:    return type -> Bad() ? control.no_type : type;
decl.cpp:    if (type_expr -> symbol)
decl.cpp:    AstArrayType* array_type = type_expr -> ArrayTypeCast();
decl.cpp:    AstType* actual_type = array_type ? array_type -> type : type_expr;
decl.cpp:    AstTypeName* name = actual_type -> TypeNameCast();
decl.cpp:    AstPrimitiveType* primitive_type = actual_type -> PrimitiveTypeCast();
decl.cpp:    AstWildcard* wildcard_type = actual_type -> WildcardCast();
decl.cpp:        type_expr -> symbol = control.no_type;
decl.cpp:        if (name -> base_opt)
decl.cpp:            ProcessType(name -> base_opt);
decl.cpp:            type = MustFindNestedType(name -> base_opt -> symbol,
decl.cpp:                                      name -> name);
decl.cpp:        else type = MustFindType(name -> name);
decl.cpp:        if (name -> type_arguments_opt)
decl.cpp:                           name -> type_arguments_opt,
decl.cpp:                           type -> ContainingPackageName(),
decl.cpp:                           type -> ExternalName());
decl.cpp:    if (type -> Bad() && NumErrors() == error_count)
decl.cpp:                           lex_stream -> NameString(type_expr ->
decl.cpp:                           lex_stream -> NameString(type_expr ->
decl.cpp:        type = type -> GetArrayType(this, array_type -> NumBrackets());
decl.cpp:    type_expr -> symbol = type;
decl.cpp:        (AstMethodDeclaration*) init_method -> declaration;
decl.cpp:    assert(declaration -> method_body_opt);
decl.cpp:         i < field_declaration -> NumVariableDeclarators(); i++)
decl.cpp:            field_declaration -> VariableDeclarator(i);
decl.cpp:        VariableSymbol* variable = variable_declarator -> symbol;
decl.cpp:            if (variable_declarator -> variable_initializer_opt)
decl.cpp:                variable_declarator -> pending = true;
decl.cpp:                    if (! variable -> initial_value)
decl.cpp:                        declaration -> method_body_opt ->
decl.cpp:                else if (variable -> ACC_FINAL())
decl.cpp:                    DefinitelyAssignedVariables() ->
decl.cpp:                        AssignElement(variable -> LocalVariableIndex());
decl.cpp:                variable_declarator -> pending = false;
decl.cpp:            variable -> MarkComplete();
decl.cpp:        (AstMethodDeclaration*) init_method -> declaration;
decl.cpp:    LocalBlockStack().Push(declaration -> method_body_opt);
decl.cpp:    LocalSymbolTable().Push(init_method -> block_symbol -> Table());
decl.cpp:    initializer -> block -> is_reachable = true;
decl.cpp:    if (initializer -> block -> explicit_constructor_opt)
decl.cpp:            initializer -> block -> explicit_constructor_opt;
decl.cpp:    ProcessBlock(initializer -> block);
decl.cpp:    DefiniteBlockInitializer(initializer -> block, LocalBlockStack().max_size);
decl.cpp:    declaration -> method_body_opt -> AddStatement(initializer -> block);
decl.cpp:    if (init_method -> block_symbol -> max_variable_index <
decl.cpp:        init_method -> block_symbol -> max_variable_index =
decl.cpp:    if (! initializer -> block -> can_complete_normally)
decl.cpp:    if (this_type -> static_initializer_method)
decl.cpp:        return this_type -> static_initializer_method;
decl.cpp:    StoragePool* ast_pool = compilation_unit -> ast_pool;
decl.cpp:    TokenIndex loc = this_type -> declaration -> identifier_token;
decl.cpp:    block_symbol -> max_variable_index = 0;
decl.cpp:    AstMethodBody* block = ast_pool -> GenMethodBody();
decl.cpp:    block -> left_brace_token = loc;
decl.cpp:    block -> right_brace_token = loc;
decl.cpp:    block -> block_symbol = block_symbol;
decl.cpp:    block -> AllocateStatements(estimate);
decl.cpp:    AstType* return_type = ast_pool -> GenPrimitiveType(Ast::VOID_TYPE, loc);
decl.cpp:    return_type -> symbol = control.void_type;
decl.cpp:    AstMethodDeclaration* declaration = ast_pool -> GenMethodDeclaration();
decl.cpp:        this_type -> InsertMethodSymbol(control.clinit_name_symbol);
decl.cpp:    declaration -> type = return_type;
decl.cpp:    declaration -> method_symbol = init_method;
decl.cpp:    declaration -> method_body_opt = block;
decl.cpp:    init_method -> SetType(control.void_type);
decl.cpp:    init_method -> SetFlags(AccessFlags::ACCESS_PRIVATE |
decl.cpp:    if (this_type -> ACC_STRICTFP())
decl.cpp:        init_method -> SetACC_STRICTFP();
decl.cpp:    init_method -> SetContainingType(this_type);
decl.cpp:    init_method -> SetBlockSymbol(block_symbol);
decl.cpp:    init_method -> SetSignature(control);
decl.cpp:    init_method -> declaration = declaration;
decl.cpp:    this_type -> static_initializer_method = init_method;
decl.cpp:    if (class_body -> NumStaticInitializers() == 0 &&
decl.cpp:        class_body -> NumClassVariables() == 0)
decl.cpp:    unsigned estimate = class_body -> NumStaticInitializers();
decl.cpp:    for (unsigned i = 0; i < class_body -> NumClassVariables(); ++i)
decl.cpp:        estimate += class_body -> ClassVariable(i) -> NumVariableDeclarators();
decl.cpp:    while (j < class_body -> NumClassVariables() &&
decl.cpp:           k < class_body -> NumStaticInitializers())
decl.cpp:        if (class_body -> ClassVariable(j) -> semicolon_token <
decl.cpp:            class_body -> StaticInitializer(k) -> block -> right_brace_token)
decl.cpp:            InitializeVariable(class_body -> ClassVariable(j++), init_method);
decl.cpp:            ProcessInitializer(class_body -> StaticInitializer(k++),
decl.cpp:    while (j < class_body -> NumClassVariables())
decl.cpp:        InitializeVariable(class_body -> ClassVariable(j++), init_method);
decl.cpp:    while (k < class_body -> NumStaticInitializers())
decl.cpp:        ProcessInitializer(class_body -> StaticInitializer(k++),
decl.cpp:    // classes, we have already reported that a non-constant static
decl.cpp:    // field is illegal, so we only need an error here for top-level
decl.cpp:    for (unsigned l = 0; l < FinalFields() -> Length(); l++)
decl.cpp:        if (final_var -> ACC_STATIC() &&
decl.cpp:            ! DefinitelyAssignedVariables() -> da_set[l])
decl.cpp:            if (! this_type -> IsInner())
decl.cpp:                               final_var -> declarator, final_var -> Name());
decl.cpp:            DefinitelyAssignedVariables() -> AssignElement(l);
decl.cpp:    if (this_type -> static_initializer_method)
decl.cpp:        MethodSymbol* init_method = this_type -> static_initializer_method;
decl.cpp:        init_method -> max_block_depth = LocalBlockStack().max_size;
decl.cpp:        init_method -> block_symbol -> CompressSpace(); // space optimization
decl.cpp:    if (class_body -> NumInstanceInitializers() == 0 &&
decl.cpp:        class_body -> NumInstanceVariables() == 0)
decl.cpp:    StoragePool* ast_pool = compilation_unit -> ast_pool;
decl.cpp:    TokenIndex loc = this_type -> declaration -> identifier_token;
decl.cpp:    block_symbol -> max_variable_index = 1;
decl.cpp:    AstMethodBody* block = ast_pool -> GenMethodBody();
decl.cpp:    block -> left_brace_token = loc;
decl.cpp:    block -> right_brace_token = loc;
decl.cpp:    block -> block_symbol = block_symbol;
decl.cpp:    AstType* return_type = ast_pool -> GenPrimitiveType(Ast::VOID_TYPE, loc);
decl.cpp:    return_type -> symbol = control.void_type;
decl.cpp:    AstMethodDeclaration* declaration = ast_pool -> GenMethodDeclaration();
decl.cpp:        this_type -> InsertMethodSymbol(control.block_init_name_symbol);
decl.cpp:    declaration -> type = return_type;
decl.cpp:    declaration -> method_symbol = init_method;
decl.cpp:    declaration -> method_body_opt = block;
decl.cpp:    init_method -> SetType(control.void_type);
decl.cpp:    init_method -> SetFlags(AccessFlags::ACCESS_PRIVATE |
decl.cpp:    if (this_type -> ACC_STRICTFP())
decl.cpp:        init_method -> SetACC_STRICTFP();
decl.cpp:    init_method -> SetContainingType(this_type);
decl.cpp:    init_method -> SetBlockSymbol(block_symbol);
decl.cpp:    init_method -> SetSignature(control);
decl.cpp:    init_method -> declaration = declaration;
decl.cpp:    assert(this_type -> instance_initializer_method == NULL);
decl.cpp:    this_type -> instance_initializer_method = init_method;
decl.cpp:    for (unsigned i = 0; i < FinalFields() -> Length(); i++)
decl.cpp:        if (variable_symbol -> ACC_STATIC())
decl.cpp:            DefinitelyAssignedVariables() -> AssignElement(i);
decl.cpp:            BlankFinals() -> RemoveElement(i);
decl.cpp:            DefinitelyAssignedVariables() -> ReclaimElement(i);
decl.cpp:    unsigned estimate = class_body -> NumInstanceInitializers();
decl.cpp:    for (unsigned i = 0; i < class_body -> NumInstanceVariables(); ++i)
decl.cpp:        estimate += class_body -> InstanceVariable(i) ->
decl.cpp:    block -> AllocateStatements(estimate);
decl.cpp:    while (j < class_body -> NumInstanceVariables() &&
decl.cpp:           k < class_body -> NumInstanceInitializers())
decl.cpp:        if (class_body -> InstanceVariable(j) -> semicolon_token <
decl.cpp:            class_body -> InstanceInitializer(k) -> block -> right_brace_token)
decl.cpp:            InitializeVariable(class_body -> InstanceVariable(j++),
decl.cpp:            ProcessInitializer(class_body -> InstanceInitializer(k++),
decl.cpp:    while (j < class_body -> NumInstanceVariables())
decl.cpp:        InitializeVariable(class_body -> InstanceVariable(j++), init_method);
decl.cpp:    while (k < class_body -> NumInstanceInitializers())
decl.cpp:        ProcessInitializer(class_body -> InstanceInitializer(k++),
decl.cpp:    init_method -> max_block_depth = LocalBlockStack().max_size;
decl.cpp:    init_method -> block_symbol -> CompressSpace(); // space optimization
Binary file decl.o matches
definite.cpp:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $
definite.cpp:// It is a compile-time error if a local variable is accessed that is not
definite.cpp:// da, and a compile-time error if a blank final is assigned when it is
definite.cpp:// not du.  This code also handles the compile-time error when an assignment
definite.cpp:// state (if different) - this is to allow speculative decisions when
definite.cpp:    if (expr -> IsConstant()) // A constant expression has no effect on DA/DU.
definite.cpp:    else if (expr -> symbol != control.no_type)
definite.cpp:        definite = (this ->* DefiniteExpr[expr -> kind])(expr, def_pair);
definite.cpp:    assert(! definite || expr -> Type() == control.boolean_type);
definite.cpp:    if (name -> resolution_opt)
definite.cpp:        return DefiniteBooleanExpression(name -> resolution_opt, def_pair);
definite.cpp:    if (name -> base_opt)
definite.cpp:        DefiniteName(name -> base_opt, def_pair);
definite.cpp:    VariableSymbol* variable = name -> symbol
definite.cpp:        ? name -> symbol -> VariableCast() : (VariableSymbol*) NULL;
definite.cpp:    if (variable && ! variable -> ACC_SYNTHETIC() && ! name -> base_opt &&
definite.cpp:        (variable -> IsLocal(ThisMethod()) || variable -> IsFinal(ThisType())))
definite.cpp:        int index = variable -> LocalVariableIndex(this);
definite.cpp:        if (! def_pair.da_set[index] && ! name -> IsConstant())
definite.cpp:                           name -> identifier_token, variable -> Name());
definite.cpp:            if (variable -> IsLocal(ThisMethod())) // avoid cascading errors!
definite.cpp:    DefiniteExpression(array_access -> base, def_pair);
definite.cpp:    DefiniteExpression(array_access -> expression, def_pair);
definite.cpp:    if (method_call -> base_opt)
definite.cpp:        DefiniteExpression(method_call -> base_opt, def_pair);
definite.cpp:    for (unsigned i = 0; i < method_call -> arguments -> NumArguments(); i++)
definite.cpp:        DefiniteExpression(method_call -> arguments -> Argument(i), def_pair);
definite.cpp:    if (class_creation -> resolution_opt)
definite.cpp:        class_creation = class_creation -> resolution_opt;
definite.cpp:    if (class_creation -> base_opt)
definite.cpp:        DefiniteExpression(class_creation -> base_opt, def_pair);
definite.cpp:    for (i = 0; i < class_creation -> arguments -> NumArguments(); i++)
definite.cpp:        DefiniteExpression(class_creation -> arguments -> Argument(i),
definite.cpp:    for (i = 0; i < class_creation -> arguments -> NumLocalArguments(); i++)
definite.cpp:        DefiniteExpression(class_creation -> arguments -> LocalArgument(i),
definite.cpp:    for (unsigned i = 0; i < array_creation -> NumDimExprs(); i++)
definite.cpp:        AstDimExpr* dim_expr = array_creation -> DimExpr(i);
definite.cpp:        DefiniteExpression(dim_expr -> expression, def_pair);
definite.cpp:    if (array_creation -> array_initializer_opt)
definite.cpp:        DefiniteArrayInitializer(array_creation -> array_initializer_opt,
definite.cpp:    if (field_access -> resolution_opt)
definite.cpp:        field_access = field_access -> resolution_opt -> FieldAccessCast();
definite.cpp:        VariableSymbol* variable = (field_access -> symbol
definite.cpp:                                    ? field_access -> symbol -> VariableCast()
definite.cpp:        if (variable && variable -> IsFinal(ThisType()))
definite.cpp:            if (variable -> ACC_STATIC() ||
definite.cpp:                field_access -> base -> ThisExpressionCast())
definite.cpp:    while (expr -> ParenthesizedExpressionCast())
definite.cpp:        expr = ((AstParenthesizedExpression*) expr) -> expression;
definite.cpp:    if (! expr -> ArrayAccessCast()) // some kind of name
definite.cpp:        AstName* name = expr -> NameCast();
definite.cpp:            if (name -> resolution_opt)
definite.cpp:                read_method = name -> resolution_opt -> symbol -> MethodCast();
definite.cpp:            AstFieldAccess* field_access = expr -> FieldAccessCast();
definite.cpp:            if (field_access -> resolution_opt)
definite.cpp:                    field_access -> resolution_opt -> symbol -> MethodCast();
definite.cpp:                    ? (VariableSymbol*) read_method -> accessed_member
definite.cpp:                    : expr -> symbol -> VariableCast());
definite.cpp:        while (variable && variable -> accessed_local)
definite.cpp:            variable = variable -> accessed_local;
definite.cpp:    if (variable && variable -> ACC_FINAL())
definite.cpp:        if ((variable -> IsLocal(ThisMethod()) ||
definite.cpp:             variable -> IsFinal(ThisType())) &&
definite.cpp:            ! variable -> ACC_SYNTHETIC() &&
definite.cpp:            (*BlankFinals())[variable -> LocalVariableIndex(this)])
definite.cpp:                           expr -> LeftToken(),
definite.cpp:                           expr -> RightToken(),
definite.cpp:                           variable -> Name());
definite.cpp:                           expr -> LeftToken(),
definite.cpp:                           expr -> RightToken(),
definite.cpp:                           variable -> Name());
definite.cpp:        if (variable -> IsFinal(ThisType()) && ! variable -> ACC_SYNTHETIC())
definite.cpp:            def_pair.du_set.RemoveElement(variable -> LocalVariableIndex(this));
definite.cpp:    return DefinitePLUSPLUSOrMINUSMINUS(postfix_expression -> expression,
definite.cpp:        DefinitePair temp(after_expr -> true_pair);
definite.cpp:        after_expr -> true_pair = after_expr -> false_pair;
definite.cpp:        after_expr -> false_pair = temp;
definite.cpp:// The default pre unary operators are +, -, and ~.
definite.cpp:    return (this ->* DefiniteExpr[expr -> kind])(expr, def_pair);
definite.cpp:    return (this ->* DefinitePreUnaryExpr[prefix_expression -> Tag()])
definite.cpp:        (prefix_expression -> expression, def_pair);
definite.cpp:        DefiniteBooleanExpression(expr -> left_expression, def_pair);
definite.cpp:        def_pair = after_left -> true_pair;
definite.cpp:        DefiniteBooleanExpression(expr -> right_expression, def_pair);
definite.cpp:            after_right -> false_pair *= after_left -> false_pair;
definite.cpp:            after_right -> true_pair = def_pair;
definite.cpp:            after_right -> false_pair *= def_pair;
definite.cpp:        after_right -> false_pair *= *before_right;
definite.cpp:        DefiniteBooleanExpression(expr -> left_expression, def_pair);
definite.cpp:        def_pair = after_left -> false_pair;
definite.cpp:        DefiniteBooleanExpression(expr -> right_expression, def_pair);
definite.cpp:            after_right -> true_pair *= after_left -> true_pair;
definite.cpp:            after_right -> true_pair *= def_pair;
definite.cpp:            after_right -> false_pair = def_pair;
definite.cpp:        after_right -> true_pair *= *before_right;
definite.cpp:    DefiniteExpression(expr -> left_expression, def_pair);
definite.cpp:    DefiniteExpression(expr -> right_expression, def_pair);
definite.cpp:    return (this ->* DefiniteBinaryExpr[binary_expression -> Tag()])
definite.cpp:    DefiniteExpression(expr -> expression, def_pair);
definite.cpp:        DefiniteBooleanExpression(conditional_expression -> test_expression,
definite.cpp:        def_pair = after_condition -> true_pair;
definite.cpp:        DefiniteBooleanExpression(conditional_expression -> true_expression,
definite.cpp:         def_pair = after_condition -> false_pair;
definite.cpp:        DefiniteBooleanExpression(conditional_expression -> false_expression,
definite.cpp:    if (conditional_expression -> Type() == control.boolean_type)
definite.cpp:            after_true -> true_pair *= after_false -> true_pair;
definite.cpp:            after_true -> false_pair *= after_false -> false_pair;
definite.cpp:            after_true -> true_pair *= def_pair;
definite.cpp:            after_true -> false_pair *= def_pair;
definite.cpp:        assignment_expression -> left_hand_side -> CastExpressionCast();
definite.cpp:        ? casted_left_hand_side -> expression
definite.cpp:        : assignment_expression -> left_hand_side;
definite.cpp:    if (left_hand_side -> NameCast())
definite.cpp:        simple_name = ! name -> base_opt;
definite.cpp:        AstFieldAccess* field_access = left_hand_side -> FieldAccessCast();
definite.cpp:            if (field_access -> resolution_opt)
definite.cpp:                left_hand_side = field_access -> resolution_opt;
definite.cpp:            // TODO: This is not well-specified in the JLS; rather we are just
definite.cpp:            if (field_access -> base -> ThisExpressionCast())
definite.cpp:                simple_name = ((AstThisExpression*) field_access -> base) ->
definite.cpp:    VariableSymbol* variable = (left_hand_side -> symbol
definite.cpp:                                ? left_hand_side -> symbol -> VariableCast()
definite.cpp:    while (variable && variable -> accessed_local)
definite.cpp:        variable = variable -> accessed_local;
definite.cpp:        if (variable -> IsLocal(ThisMethod()) ||
definite.cpp:            variable -> IsFinal(ThisType()))
definite.cpp:            index = variable -> LocalVariableIndex(this);
definite.cpp:            if (! assignment_expression -> SimpleAssignment() &&
definite.cpp:                               left_hand_side -> LeftToken(),
definite.cpp:                               left_hand_side -> RightToken(),
definite.cpp:                               variable -> Name());
definite.cpp:        else if (variable -> ACC_FINAL())
definite.cpp:                           left_hand_side -> LeftToken(),
definite.cpp:                           left_hand_side -> RightToken(),
definite.cpp:                           variable -> Name());
definite.cpp:    // The left-hand-side of an assignment expression is either a simple name,
definite.cpp:        AstFieldAccess* field_access = left_hand_side -> FieldAccessCast();
definite.cpp:        DefiniteExpression((field_access ? field_access -> base
definite.cpp:    // JLS2 16.1.7 - The rules for definite assignment of boolean valued
definite.cpp:    DefiniteExpression(assignment_expression -> expression, def_pair);
definite.cpp:        (variable -> IsLocal(ThisMethod()) || variable -> IsFinal(ThisType())))
definite.cpp:        if (variable -> ACC_FINAL())
definite.cpp:                               left_hand_side -> LeftToken(),
definite.cpp:                               left_hand_side -> RightToken(),
definite.cpp:                               variable -> Name());
definite.cpp:            else if (variable -> IsFinal(ThisType()) && ! simple_name)
definite.cpp:                               left_hand_side -> LeftToken(),
definite.cpp:                               left_hand_side -> RightToken(),
definite.cpp:                               variable -> Name(),
definite.cpp:                               (variable -> ACC_STATIC() ? NULL
definite.cpp:                                : variable -> Name()));
definite.cpp:                // executed, so it does not affect loop or try-catch analysis.
definite.cpp:                if (DefiniteFinalAssignments() -> Size() > 0)
definite.cpp:                    DefiniteFinalAssignments() -> Top().Next() =
definite.cpp:                ReachableAssignments() -> AddElement(index);
definite.cpp:    return DefiniteBooleanExpression(expr -> expression, def_pair);
definite.cpp:    //          if (! def_pair.da_set[variable -> LocalVariableIndex(this)])
definite.cpp:    //                             expr -> LeftToken(),
definite.cpp:    //                             expr -> RightToken(),
definite.cpp:    //                             variable -> Name());
definite.cpp:    //              def_pair.da_set.AddElement(variable -> LocalVariableIndex(this));
definite.cpp:    return DefiniteBooleanExpression((expr -> resolution_opt
definite.cpp:                                      ? expr -> resolution_opt
definite.cpp:                                      : expr -> base), def_pair);
definite.cpp:    return DefiniteBooleanExpression(expr -> expression, def_pair);
definite.cpp:         i < array_initializer -> NumVariableInitializers(); i++)
definite.cpp:        AstArrayInitializer* sub_array_initializer = array_initializer ->
definite.cpp:            VariableInitializer(i) -> ArrayInitializerCast();
definite.cpp:                (AstExpression*) array_initializer -> VariableInitializer(i);
definite.cpp:    assert(variable_declarator -> variable_initializer_opt);
definite.cpp:        variable_declarator -> variable_initializer_opt -> ExpressionCast();
definite.cpp:        DefiniteArrayInitializer((AstArrayInitializer*) variable_declarator ->
definite.cpp:    // Even when initialized by a non-constant, variables declared in a
definite.cpp:        DefiniteBlocks() -> TopBlock() -> Tag() == AstBlock::SWITCH &&
definite.cpp:        (! init || ! init -> IsConstant()))
definite.cpp:        BlankFinals() -> AddElement(variable_declarator -> symbol ->
definite.cpp:    (this ->* DefiniteStmt[ast -> kind])(ast);
definite.cpp:    for (unsigned i = 0; i < block_body -> NumStatements(); i++)
definite.cpp:        AstStatement* statement = block_body -> Statement(i);
definite.cpp:        if (statement -> is_reachable)
definite.cpp:    DefiniteBlocks() -> Push(block_body);
definite.cpp:        block_body -> NumLocallyDefinedVariables() > 0)
definite.cpp:                << lex_stream -> Line(block_body -> RightToken())
definite.cpp:        for (i = 0; i < block_body -> NumLocallyDefinedVariables(); i++)
definite.cpp:                    << block_body -> LocallyDefinedVariable(i) -> Name()
definite.cpp:    for (i = 0; i < block_body -> block_symbol -> NumVariableSymbols(); i++)
definite.cpp:            block_body -> block_symbol -> VariableSym(i);
definite.cpp:        int index = variable -> LocalVariableIndex(this);
definite.cpp:        BlankFinals() -> RemoveElement(index);
definite.cpp:        ReachableAssignments() -> RemoveElement(index);
definite.cpp:        DefinitelyAssignedVariables() -> ReclaimElement(index);
definite.cpp:        DefiniteBlocks() ->
definite.cpp:            ContinuePair(DefiniteBlocks() -> Size() - 2).ReclaimElement(index);
definite.cpp:    if (block_body -> label_opt)
definite.cpp:        *DefinitelyAssignedVariables() *= DefiniteBlocks() -> TopBreakPair();
definite.cpp:    DefiniteBlocks() -> Pop();
definite.cpp:    TypeSymbol* local_type = local_decl -> declaration -> class_body ->
definite.cpp:        semantic_environment -> Type();
definite.cpp:    assert(local_type -> LocalClassProcessingCompleted());
definite.cpp:    for (unsigned i = 0; i < local_type -> NumConstructorParameters(); i++)
definite.cpp:            local_type -> ConstructorParameter(i) -> accessed_local;
definite.cpp:        if (var -> owner == ThisMethod() &&
definite.cpp:            (! DefinitelyAssignedVariables() ->
definite.cpp:             da_set[var -> LocalVariableIndex(this)]))
definite.cpp:                           local_decl, var -> Name());
definite.cpp:    for (unsigned i = 0; i < local_decl -> NumVariableDeclarators(); i++)
definite.cpp:            local_decl -> VariableDeclarator(i);
definite.cpp:        VariableSymbol* variable_symbol = variable_declarator -> symbol;
definite.cpp:        int index = variable_symbol -> LocalVariableIndex(this);
definite.cpp:            Coutput << "(3.5) Local Variable \"" << variable_symbol -> Name()
definite.cpp:                    << lex_stream -> Line(variable_declarator -> LeftToken())
definite.cpp:            DefiniteBlocks() -> TopBlock() ->
definite.cpp:        if (variable_declarator -> variable_initializer_opt)
definite.cpp:            DefinitelyAssignedVariables() -> AssignElement(index);
definite.cpp:            DefinitelyAssignedVariables() -> ReclaimElement(index);
definite.cpp:            if (variable_symbol -> ACC_FINAL())
definite.cpp:                BlankFinals() -> AddElement(index);
definite.cpp:    DefiniteExpression(expression_statement -> expression,
definite.cpp:    DefiniteExpression(synchronized_statement -> expression,
definite.cpp:    DefiniteBlock(synchronized_statement -> block);
definite.cpp:        DefiniteBooleanExpression(if_statement -> expression,
definite.cpp:        *DefinitelyAssignedVariables() = after_expr -> true_pair;
definite.cpp:    // if-statement (both the true and false statement) are enclosed in a
definite.cpp:    DefiniteBlock(if_statement -> true_statement);
definite.cpp:    if (! if_statement -> false_statement_opt) // no else part ?
definite.cpp:                                           ? after_expr -> false_pair
definite.cpp:                                          ? after_expr -> false_pair
definite.cpp:        DefiniteBlock(if_statement -> false_statement_opt);
definite.cpp:    starting_set -= DefinitelyAssignedVariables() -> du_set;
definite.cpp:    for (unsigned i = 0; i < DefiniteFinalAssignments() -> Top().Length(); i++)
definite.cpp:        AstExpression* name = DefiniteFinalAssignments() -> Top()[i];
definite.cpp:        VariableSymbol* variable = (VariableSymbol*) name -> symbol;
definite.cpp:        if (starting_set[variable -> LocalVariableIndex(this)])
definite.cpp:                           name -> LeftToken(),
definite.cpp:                           name -> RightToken(),
definite.cpp:                           variable -> Name());
definite.cpp:    DefiniteFinalAssignments() -> Pop();
definite.cpp:    DefiniteFinalAssignments() -> Push();
definite.cpp:    BitSet starting_set(DefinitelyAssignedVariables() -> du_set);
definite.cpp:        DefiniteBooleanExpression(while_statement -> expression,
definite.cpp:    DefinitePair before_statement(Universe() -> Size());
definite.cpp:        *DefinitelyAssignedVariables() = after_expr -> true_pair;
definite.cpp:    if (while_statement -> statement -> is_reachable)
definite.cpp:        DefiniteBlock(while_statement -> statement);
definite.cpp:    *DefinitelyAssignedVariables() *= DefiniteBlocks() -> TopContinuePair();
definite.cpp:    *DefinitelyAssignedVariables() = DefiniteBlocks() -> TopBreakPair() *
definite.cpp:        (after_expr ? after_expr -> false_pair : before_statement);
definite.cpp:    // for-statement in its own block, so that any variables defined in the
definite.cpp:    // for-init-statements have scope limited to the for loop. Thus, we do
definite.cpp:    // for-init section in this method.
definite.cpp:    for (i = 0; i < for_statement -> NumForInitStatements(); i++)
definite.cpp:        DefiniteStatement(for_statement -> ForInitStatement(i));
definite.cpp:    DefiniteFinalAssignments() -> Push();
definite.cpp:    BitSet starting_set(DefinitelyAssignedVariables() -> du_set);
definite.cpp:    DefinitePair before_statement(Universe() -> Size());
definite.cpp:    if (for_statement -> end_expression_opt)
definite.cpp:            DefiniteBooleanExpression(for_statement -> end_expression_opt,
definite.cpp:        *DefinitelyAssignedVariables() = after_end_expression -> true_pair;
definite.cpp:    if (for_statement -> statement -> is_reachable)
definite.cpp:        DefiniteBlock(for_statement -> statement);
definite.cpp:    *DefinitelyAssignedVariables() *= DefiniteBlocks() -> TopContinuePair();
definite.cpp:    for (i = 0; i < for_statement -> NumForUpdateStatements(); i++)
definite.cpp:        DefiniteExpressionStatement(for_statement -> ForUpdateStatement(i));
definite.cpp:    *DefinitelyAssignedVariables() = DefiniteBlocks() -> TopBreakPair() *
definite.cpp:        (for_statement -> end_expression_opt
definite.cpp:         ? (after_end_expression ? after_end_expression -> false_pair
definite.cpp:    // for-statement in its own block, so that the loop variable defined in
definite.cpp:    // for-init section in this method.
definite.cpp:        for_statement -> formal_parameter -> formal_declarator;
definite.cpp:    VariableSymbol* variable_symbol = variable_declarator -> symbol;
definite.cpp:        int index = variable_symbol -> LocalVariableIndex(this);
definite.cpp:            Coutput << "(3.6) Foreach Variable \"" << variable_symbol -> Name()
definite.cpp:                    << lex_stream -> Line(variable_declarator -> LeftToken())
definite.cpp:            DefiniteBlocks() -> TopBlock() ->
definite.cpp:        DefinitelyAssignedVariables() -> AssignElement(index);
definite.cpp:    DefiniteExpression(for_statement -> expression,
definite.cpp:    BitSet starting_set(DefinitelyAssignedVariables() -> du_set);
definite.cpp:    DefiniteFinalAssignments() -> Push();
definite.cpp:    if (for_statement -> statement -> is_reachable)
definite.cpp:        DefiniteBlock(for_statement -> statement);
definite.cpp:    *DefinitelyAssignedVariables() *= DefiniteBlocks() -> TopContinuePair();
definite.cpp:        DefiniteBlocks() -> TopBreakPair() * before_statement;        
definite.cpp:    DefiniteFinalAssignments() -> Push();
definite.cpp:    BitSet starting_set(DefinitelyAssignedVariables() -> du_set);
definite.cpp:    DefiniteBlock(do_statement -> statement);
definite.cpp:    *DefinitelyAssignedVariables() *= DefiniteBlocks() -> TopContinuePair();
definite.cpp:        DefiniteBooleanExpression(do_statement -> expression,
definite.cpp:    DefinitePair after_loop(Universe() -> Size());
definite.cpp:        *DefinitelyAssignedVariables() = after_expr -> true_pair;
definite.cpp:    *DefinitelyAssignedVariables() = DefiniteBlocks() -> TopBreakPair() *
definite.cpp:        (after_expr ? after_expr -> false_pair : after_loop);
definite.cpp:    AstBlock* block_body = switch_statement -> switch_block;
definite.cpp:    DefiniteBlocks() -> Push(block_body);
definite.cpp:    DefiniteExpression(switch_statement -> expression,
definite.cpp:    for (i = 0; i < block_body -> NumStatements(); i++)
definite.cpp:            (AstSwitchBlockStatement*) block_body -> Statement(i);
definite.cpp:    if (! switch_statement -> DefaultCase())
definite.cpp:    *DefinitelyAssignedVariables() *= DefiniteBlocks() -> TopBreakPair();
definite.cpp:    for (i = 0; i < block_body -> block_symbol -> NumVariableSymbols(); i++)
definite.cpp:            block_body -> block_symbol -> VariableSym(i);
definite.cpp:        int index = variable -> LocalVariableIndex(this);
definite.cpp:        BlankFinals() -> RemoveElement(index);
definite.cpp:        ReachableAssignments() -> RemoveElement(index);
definite.cpp:        DefinitelyAssignedVariables() -> ReclaimElement(index);
definite.cpp:    DefiniteBlocks() -> Pop();
definite.cpp:    if (AbruptFinallyStack().Top() < break_statement -> nesting_level)
definite.cpp:        DefiniteBlocks() -> BreakPair(break_statement -> nesting_level) *=
definite.cpp:    if (AbruptFinallyStack().Top() < continue_statement -> nesting_level)
definite.cpp:        DefiniteBlocks() -> ContinuePair(continue_statement ->
definite.cpp:    if (return_statement -> expression_opt)
definite.cpp:        DefiniteExpression(return_statement -> expression_opt,
definite.cpp:        DefiniteBlocks() -> ReturnPair() *= *DefinitelyAssignedVariables();
definite.cpp:    DefiniteExpression(throw_statement -> expression,
definite.cpp:    if (try_statement -> finally_clause_opt &&
definite.cpp:        (! try_statement -> finally_clause_opt -> block ->
definite.cpp:        AbruptFinallyStack().Push(try_statement -> finally_clause_opt ->
definite.cpp:                                  block -> nesting_level);
definite.cpp:    ReachableAssignments() -> SetEmpty();
definite.cpp:    DefiniteBlock(try_statement -> block);
definite.cpp:    BitSet before_catch_finals(starting_pair.du_set - *ReachableAssignments()),
definite.cpp:           possibly_finals_union(DefinitelyAssignedVariables() -> du_set);
definite.cpp:    BitSet after_blocks(DefinitelyAssignedVariables() -> da_set);
definite.cpp:    for (unsigned i = 0; i < try_statement -> NumCatchClauses(); i++)
definite.cpp:        DefinitelyAssignedVariables() -> da_set = starting_pair.da_set;
definite.cpp:        DefinitelyAssignedVariables() -> du_set = before_catch_finals;
definite.cpp:        AstCatchClause* clause = try_statement -> CatchClause(i);
definite.cpp:        VariableSymbol* variable = clause -> parameter_symbol;
definite.cpp:        int index = variable -> LocalVariableIndex(this);
definite.cpp:        DefinitelyAssignedVariables() -> AddElement(index);
definite.cpp:            Coutput << "(7) Variable \"" << variable -> Name() << " #"
definite.cpp:                    << lex_stream -> Line(clause -> formal_parameter -> LeftToken())
definite.cpp:        DefiniteBlock(clause -> block);
definite.cpp:        DefinitelyAssignedVariables() -> ReclaimElement(index);
definite.cpp:        VariableSymbol* variable = clause -> parameter_symbol;
definite.cpp:            Coutput << "(8) Variable \"" << variable -> Name() << " #"
definite.cpp:                    << lex_stream -> Line(clause -> formal_parameter -> RightToken())
definite.cpp:        possibly_finals_union *= DefinitelyAssignedVariables() -> du_set;
definite.cpp:        after_blocks *= DefinitelyAssignedVariables() -> da_set;
definite.cpp:    if (try_statement -> finally_clause_opt)
definite.cpp:        if (! try_statement -> finally_clause_opt -> block ->
definite.cpp:        DefinitelyAssignedVariables() -> da_set = starting_pair.da_set;
definite.cpp:        DefinitelyAssignedVariables() -> du_set =
definite.cpp:            starting_pair.du_set - *ReachableAssignments();
definite.cpp:        DefiniteBlock(try_statement -> finally_clause_opt -> block);
definite.cpp:        DefinitelyAssignedVariables() -> da_set += after_blocks;
definite.cpp:        DefinitelyAssignedVariables() -> da_set = after_blocks;
definite.cpp:        DefinitelyAssignedVariables() -> du_set = possibly_finals_union;
definite.cpp:        DefiniteBooleanExpression(assert_statement -> condition,
definite.cpp:        *DefinitelyAssignedVariables() = after_condition -> false_pair;
definite.cpp:        before_assert.du_set *= after_condition -> true_pair.du_set;
definite.cpp:    else before_assert.du_set *= DefinitelyAssignedVariables() -> du_set;
definite.cpp:    if (assert_statement -> message_opt)
definite.cpp:        DefiniteExpression(assert_statement -> message_opt,
definite.cpp:    for (unsigned i = 0; i < this_call -> arguments -> NumArguments(); i++)
definite.cpp:        DefiniteExpression(this_call -> arguments -> Argument(i),
definite.cpp:    if (super_call -> base_opt)
definite.cpp:        DefiniteExpression(super_call -> base_opt,
definite.cpp:    for (unsigned i = 0; i < super_call -> arguments -> NumArguments(); i++)
definite.cpp:        DefiniteExpression(super_call -> arguments -> Argument(i),
definite.cpp:    AstBlock* block_body = method_declaration -> method_body_opt;
definite.cpp:                << method_declaration -> method_symbol -> Name() << "\" in "
definite.cpp:                << ThisType() -> ContainingPackageName()
definite.cpp:                << "/" << ThisType() -> ExternalName() << endl;
definite.cpp:    int size = block_body -> block_symbol -> max_variable_index +
definite.cpp:        FinalFields() -> Length();
definite.cpp:    Universe() -> Resize(size, BitSet::UNIVERSE);
definite.cpp:    int stack_size = method_declaration -> method_symbol -> max_block_depth;
definite.cpp:    DefinitelyAssignedVariables() -> Resize(size);
definite.cpp:    BlankFinals() -> Resize(size, BitSet::EMPTY);
definite.cpp:    ReachableAssignments() -> Resize(size, BitSet::EMPTY);
definite.cpp:    DefiniteBlocks() -> Push(block_body);
definite.cpp:        method_declaration -> method_declarator;
definite.cpp:    for (i = 0; i < method_declarator -> NumFormalParameters(); i++)
definite.cpp:            method_declarator -> FormalParameter(i) -> formal_declarator;
definite.cpp:        DefinitelyAssignedVariables() ->
definite.cpp:            AssignElement(formal_declarator -> symbol ->
definite.cpp:            VariableSymbol* variable = formal_declarator -> symbol;
definite.cpp:            Coutput << "(10) Variable \"" << variable -> Name() << " #"
definite.cpp:                    << variable -> LocalVariableIndex(this)
definite.cpp:                    << lex_stream -> Line(formal_declarator -> LeftToken())
definite.cpp:        block_body -> NumLocallyDefinedVariables() > 0)
definite.cpp:                << lex_stream -> Line(block_body -> RightToken())
definite.cpp:        for (i = 0; i < block_body -> NumLocallyDefinedVariables(); i++)
definite.cpp:                    << block_body -> LocallyDefinedVariable(i) -> Name()
definite.cpp:    DefiniteBlocks() -> Pop();
definite.cpp:    size = FinalFields() -> Length();
definite.cpp:    Universe() -> Resize(size);
definite.cpp:    DefinitelyAssignedVariables() -> Resize(size);
definite.cpp:    BlankFinals() -> Resize(size);
definite.cpp:    ReachableAssignments() -> Resize(size);
definite.cpp:                << constructor_declaration -> constructor_symbol -> Name()
definite.cpp:                << ThisType() -> ContainingPackageName() << "/"
definite.cpp:                << ThisType() -> ExternalName() << endl;
definite.cpp:    AstMethodBody* block_body = constructor_declaration -> constructor_body;
definite.cpp:    int size = block_body -> block_symbol -> max_variable_index +
definite.cpp:        FinalFields() -> Length();
definite.cpp:    Universe() -> Resize(size, BitSet::UNIVERSE);
definite.cpp:        constructor_declaration -> constructor_symbol -> max_block_depth;
definite.cpp:    DefinitelyAssignedVariables() -> Resize(size);
definite.cpp:    BlankFinals() -> Resize(size, BitSet::EMPTY);
definite.cpp:    ReachableAssignments() -> Resize(size, BitSet::EMPTY);
definite.cpp:    DefiniteBlocks() -> Push(block_body);
definite.cpp:        constructor_declaration -> constructor_declarator;
definite.cpp:    for (i = 0; i < constructor_declarator -> NumFormalParameters(); i++)
definite.cpp:            constructor_declarator -> FormalParameter(i) -> formal_declarator;
definite.cpp:        DefinitelyAssignedVariables() ->
definite.cpp:            AddElement(formal_declarator -> symbol -> LocalVariableIndex(this));
definite.cpp:            VariableSymbol* variable = formal_declarator -> symbol;
definite.cpp:            Coutput << "(13) Variable \"" << variable -> Name() << " #"
definite.cpp:                    << variable -> LocalVariableIndex(this)
definite.cpp:                    << lex_stream -> Line(formal_declarator -> LeftToken())
definite.cpp:    if (block_body -> explicit_constructor_opt)
definite.cpp:        if (block_body -> explicit_constructor_opt -> ThisCallCast())
definite.cpp:            DefiniteThisCall((AstThisCall*) block_body ->
definite.cpp:        else DefiniteSuperCall((AstSuperCall*) block_body ->
definite.cpp:        block_body -> NumLocallyDefinedVariables() > 0)
definite.cpp:                << lex_stream -> Line(block_body -> RightToken())
definite.cpp:        for (unsigned j = 0; j < block_body -> NumLocallyDefinedVariables(); j++)
definite.cpp:                    << block_body -> LocallyDefinedVariable(j) -> Name()
definite.cpp:    *DefinitelyAssignedVariables() *= DefiniteBlocks() -> ReturnPair();
definite.cpp:    DefiniteBlocks() -> Pop();
definite.cpp:    size = FinalFields() -> Length();
definite.cpp:    Universe() -> Resize(size);
definite.cpp:    DefinitelyAssignedVariables() -> Resize(size);
definite.cpp:    BlankFinals() -> Resize(size);
definite.cpp:    ReachableAssignments() -> Resize(size);
definite.cpp:                << ThisType() -> ContainingPackageName() << "/"
definite.cpp:                << ThisType() -> ExternalName() << endl;
definite.cpp:    int size = block_body -> block_symbol -> max_variable_index +
definite.cpp:        FinalFields() -> Length();
definite.cpp:    Universe() -> Resize(size, BitSet::UNIVERSE);
definite.cpp:    DefinitelyAssignedVariables() -> Resize(size);
definite.cpp:    BlankFinals() -> Resize(size, BitSet::EMPTY);
definite.cpp:    ReachableAssignments() -> Resize(size, BitSet::EMPTY);
definite.cpp:    DefiniteBlocks() -> Push(block_body);
definite.cpp:        block_body -> NumLocallyDefinedVariables() > 0)
definite.cpp:                << lex_stream -> Line(block_body -> RightToken())
definite.cpp:        for (i = 0; i < block_body -> NumLocallyDefinedVariables(); i++)
definite.cpp:                    << block_body -> LocallyDefinedVariable(i) -> Name()
definite.cpp:    DefiniteBlocks() -> Pop();
definite.cpp:    size = FinalFields() -> Length();
definite.cpp:    Universe() -> Resize(size);
definite.cpp:    DefinitelyAssignedVariables() -> Resize(size);
definite.cpp:    BlankFinals() -> Resize(size);
definite.cpp:    ReachableAssignments() -> Resize(size);
definite.cpp:    if (variable_declarator -> symbol -> ACC_FINAL())
definite.cpp:        DefinitelyAssignedVariables() ->
definite.cpp:            AssignElement(variable_declarator -> symbol ->
definite.cpp:        new Tuple<VariableSymbol*> (this_type -> NumVariableSymbols());
definite.cpp:    for (unsigned i = 0; i < this_type -> NumVariableSymbols(); i++)
definite.cpp:        VariableSymbol* variable_symbol = this_type -> VariableSym(i);
definite.cpp:        if (variable_symbol -> ACC_FINAL() &&
definite.cpp:            ! variable_symbol -> ACC_SYNTHETIC())
definite.cpp:            variable_symbol -> SetLocalVariableIndex(size++);
definite.cpp:            FinalFields() -> Next() = variable_symbol;
definite.cpp:        if (! final_var -> declarator -> variable_initializer_opt)
definite.cpp:            BlankFinals() -> AddElement(j);
Binary file definite.o matches
depend.cpp:    for (int head = 0, tail = type_list.Length() - 1;
depend.cpp:         head < tail; head++, tail--)
depend.cpp:             k < sem -> compilation_unit -> NumTypeDeclarations(); k++)
depend.cpp:                sem -> compilation_unit -> TypeDeclaration(k);
depend.cpp:            if (declared -> EmptyDeclarationCast())
depend.cpp:                declared -> class_body -> semantic_environment;
depend.cpp:                TypeSymbol* type = env -> Type();
depend.cpp:                if (type -> index == OMEGA)
depend.cpp:        if (type -> index == OMEGA)
depend.cpp:    type -> index = indx;
depend.cpp:    type -> subtypes_closure = new SymbolSet;
depend.cpp:    type -> subtypes_closure -> Union(*(type -> subtypes));
depend.cpp:    for (subtype = (TypeSymbol*) type -> subtypes -> FirstElement();
depend.cpp:         subtype = (TypeSymbol*) type -> subtypes -> NextElement())
depend.cpp:        // Only worry about top-level types.
depend.cpp:        if (subtype -> outermost_type != subtype)
depend.cpp:        if (subtype -> index == OMEGA)
depend.cpp:        type -> index = Min(type -> index, subtype -> index);
depend.cpp:        type -> subtypes_closure -> Union(*(subtype -> subtypes_closure));
depend.cpp:    if (type -> index == indx)
depend.cpp:            scc_subtype -> index = CYCLE_INFINITY;
depend.cpp:            *(scc_subtype -> subtypes_closure) = *(type -> subtypes_closure);
depend.cpp:    for (unsigned k = 0; k < class_body -> NumConstructors(); k++)
depend.cpp:            class_body -> Constructor(k);
depend.cpp:        if (constructor_declaration -> index == OMEGA)
depend.cpp:    constructor_declaration -> index = indx;
depend.cpp:        constructor_declaration -> constructor_body;
depend.cpp:    if (constructor_block -> explicit_constructor_opt)
depend.cpp:            constructor_block -> explicit_constructor_opt -> ThisCallCast();
depend.cpp:            (MethodSymbol*) (this_call ? this_call -> symbol : NULL);
depend.cpp:                (AstConstructorDeclaration*) called_constructor -> declaration;
depend.cpp:            if (called_constructor_declaration -> index == OMEGA)
depend.cpp:            constructor_declaration -> index =
depend.cpp:                Min(constructor_declaration -> index,
depend.cpp:                    called_constructor_declaration -> index);
depend.cpp:    if (constructor_declaration -> index == indx)
depend.cpp:            constructor_declaration -> index = CYCLE_INFINITY;
depend.cpp:                called_constructor_declaration -> index = CYCLE_INFINITY;
depend.cpp:                    (AstMethodBody*) called_constructor_declaration ->
depend.cpp:                    called_constructor_declaration -> constructor_declarator;
depend.cpp:                Semantic* sem = called_constructor_declaration ->
depend.cpp:                    constructor_symbol -> containing_type ->
depend.cpp:                    semantic_environment -> sem;
depend.cpp:                sem -> ReportSemError(SemanticError::CIRCULAR_THIS_CALL,
depend.cpp:                                      constructor_block -> explicit_constructor_opt,
depend.cpp:                                      sem -> lex_stream -> NameString(constructor_declarator -> identifier_token));
depend.cpp:        for (unsigned j = 0; j < file_symbol -> types.Length(); j++)
depend.cpp:            TypeSymbol* type = file_symbol -> types[j];
depend.cpp:            if (type -> incremental_index == OMEGA)
depend.cpp:        if (type -> incremental_index == OMEGA)
depend.cpp:    type -> incremental_index = indx;
depend.cpp:    // if dependents is reflexive make it non-reflexive - saves time !!!
depend.cpp:    type -> dependents -> RemoveElement(type);
depend.cpp:    type -> dependents_closure = new SymbolSet;
depend.cpp:    type -> dependents_closure -> AddElement(type);
depend.cpp:    for (dependent = (TypeSymbol*) type -> dependents -> FirstElement();
depend.cpp:         dependent = (TypeSymbol*) type -> dependents -> NextElement())
depend.cpp:        if (dependent -> incremental_index == OMEGA)
depend.cpp:        type -> incremental_index = Min(type -> incremental_index,
depend.cpp:                                        dependent -> incremental_index);
depend.cpp:        type -> dependents_closure ->
depend.cpp:            Union(*(dependent -> dependents_closure));
depend.cpp:    if (type -> incremental_index == indx)
depend.cpp:            scc_dependent -> incremental_index = CYCLE_INFINITY;
depend.cpp:            *(scc_dependent -> dependents_closure) =
depend.cpp:                *(type -> dependents_closure);
depend.cpp:        char* name = file_symbol -> FileName();
depend.cpp:        int length = file_symbol -> FileNameLength() -
depend.cpp:            (file_symbol -> IsJava() ? FileSymbol::java_suffix_length
depend.cpp:    if (control -> option.directory == NULL)
depend.cpp:        name = file_symbol -> FileName();
depend.cpp:        length = file_symbol -> FileNameLength() -
depend.cpp:            (file_symbol -> IsJava() ? FileSymbol::java_suffix_length
depend.cpp:        name = file_symbol -> Utf8Name();
depend.cpp:        DirectorySymbol* dir_symbol = file_symbol -> OutputDirectory();
depend.cpp:        char* dir_name = dir_symbol -> DirectoryName();
depend.cpp:    for (unsigned i = 0; i < file_symbol -> types.Length(); i++)
depend.cpp:        TypeSymbol* type = file_symbol -> types[i];
depend.cpp:        for (parent = (TypeSymbol*) type -> parents_closure -> FirstElement();
depend.cpp:             parent = (TypeSymbol*) type -> parents_closure -> NextElement())
depend.cpp:            FileSymbol* symbol = parent -> file_symbol;
depend.cpp:            if (symbol && (! symbol -> IsZip()))
depend.cpp:    if (control -> option.directory)
depend.cpp:        type -> parents_closure = new SymbolSet;
depend.cpp:        FileSymbol* file_symbol = type -> file_symbol;
depend.cpp:        if (file_symbol && (! file_symbol -> IsZip()))
depend.cpp:        for (dependent = (TypeSymbol*) parent -> dependents_closure -> FirstElement();
depend.cpp:             dependent = (TypeSymbol*) parent -> dependents_closure -> NextElement())
depend.cpp:            dependent -> parents_closure -> AddElement(parent);
depend.cpp:        delete type -> parents_closure;
depend.cpp:        type -> parents_closure = NULL;
depend.cpp:    pending -> AddElement(type);
depend.cpp:    for (super_type = (TypeSymbol*) type -> supertypes_closure -> FirstElement();
depend.cpp:         super_type = (TypeSymbol*) type -> supertypes_closure -> NextElement())
depend.cpp:            if (! pending -> IsElement(super_type))
depend.cpp:        if (! pending -> IsElement(type))
depend.cpp:    pending -> SetEmpty();
depend.cpp:    assert(! base_type -> IsArray() && ! base_type -> Primitive());
depend.cpp:    if (parent_type -> IsArray())
depend.cpp:        parent_type = parent_type -> base_type;
depend.cpp:    if (base_type -> Bad() || parent_type -> Bad() ||
depend.cpp:        parent_type == control.null_type || parent_type -> Primitive())
depend.cpp:    base_type = base_type -> outermost_type;
depend.cpp:    parent_type = parent_type -> outermost_type;
depend.cpp:    parent_type -> dependents -> AddElement(base_type);
depend.cpp:        base_type -> static_parents -> AddElement(parent_type);
depend.cpp:    else base_type -> parents -> AddElement(parent_type);
depend.cpp:    assert(parent_type -> ContainingPackage() != control.UnnamedPackage() ||
depend.cpp:           base_type -> ContainingPackage() == control.UnnamedPackage());
depend.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
depend.h:    enum { OMEGA = -1, CYCLE_INFINITY = INT_MAX };
depend.h:        void Pop() { if (info.Length() > 0) info.Reset(info.Length() - 1); }
depend.h:            return (T *) (info.Length() > 0 ? info[info.Length() - 1] : NULL);
Binary file depend.o matches
diagnose.cpp:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $
diagnose.cpp:    lex_stream -> Reset();
diagnose.cpp:    TokenObject curtok = lex_stream -> Gettoken();
diagnose.cpp:    tok = lex_stream -> Kind(curtok);
diagnose.cpp:        prev_pos = -1;
diagnose.cpp:        prev_stack_top = -1;
diagnose.cpp:        next_pos = -1;
diagnose.cpp:        next_stack_top = -1;
diagnose.cpp:        temp_stack_top = state_stack_top - 1;
diagnose.cpp:/* Eventually, a SHIFT, SHIFT-REDUCE, ACCEPT or ERROR action is  */
diagnose.cpp:                temp_stack_top -= (rhs[act]-1);
diagnose.cpp:/* At this point, we have a shift, shift-reduce, accept or error */
diagnose.cpp:        while (act > ERROR_ACTION ||       /* SHIFT-REDUCE action */
diagnose.cpp:            /* If we have a shift-reduce, process it as well as  */
diagnose.cpp:            /* the goto-reduce actions that follow it.           */
diagnose.cpp:                act -= ERROR_ACTION;
diagnose.cpp:                    next_stack_top -= (rhs[act]-1);
diagnose.cpp:            curtok = lex_stream -> Gettoken();
diagnose.cpp:            tok = lex_stream -> Kind(curtok);
diagnose.cpp:                /* ... Process all goto-reduce actions following */
diagnose.cpp:                    temp_stack_top -= (rhs[act]-1);
diagnose.cpp:                lhs_symbol = candidate.symbol - NT_OFFSET;
diagnose.cpp:                    state_stack_top -= (rhs[act]-1);
diagnose.cpp:                curtok = lex_stream -> Gettoken();
diagnose.cpp:                tok = lex_stream -> Kind(curtok);
diagnose.cpp:    TokenObject prevtok = lex_stream -> Previous(error_token);
diagnose.cpp:/* file, we issue the end-of-file error and quit. Otherwise, ... */
diagnose.cpp:    if (lex_stream -> Kind(error_token) == EOFT_SYMBOL)
diagnose.cpp:    while (lex_stream -> Kind(buffer[BUFF_UBOUND]) != EOFT_SYMBOL)
diagnose.cpp:        candidate = SecondaryPhase(buffer[MAX_DISTANCE - MIN_DISTANCE + 2]);
diagnose.cpp:    for (i = BUFF_UBOUND; lex_stream -> Kind(buffer[i]) == EOFT_SYMBOL; i--)
diagnose.cpp:    error.Report(0, DELETION_CODE, terminal_index[lex_stream -> Kind(prevtok)],
diagnose.cpp:    for (k = i; k > 0; k--)
diagnose.cpp:        buffer[k - 1] = lex_stream -> Previous(buffer[k]);
diagnose.cpp:        buffer[k] = lex_stream -> Next(buffer[k - 1]);
diagnose.cpp:    repair.distance = repair.distance - repair.buffer_position + 1;
diagnose.cpp:         repair.distance--;
diagnose.cpp:        if (! lex_stream -> Kind(buffer[repair.buffer_position - 1]))
diagnose.cpp:    for (p1 = lex_stream -> NameString(buffer[buffer_position]); *p1; p1++)
diagnose.cpp:    for (p2 = lex_stream -> NameString(buffer[buffer_position + 1]); *p2; p2++)
diagnose.cpp:    p1 = lex_stream -> NameString(buffer[buffer_position]);
diagnose.cpp:    p2 = lex_stream -> NameString(buffer[buffer_position + 1]);
diagnose.cpp:                   lex_stream -> Kind(buffer[repair.buffer_position+1]),
diagnose.cpp:    if (lex_stream -> Kind(buffer[repair.buffer_position]) == EOLT_SYMBOL &&
diagnose.cpp:        lex_stream -> AfterEol(buffer[repair.buffer_position+1]))
diagnose.cpp:    temp_stack_top = stack_top - 1;
diagnose.cpp:    tok = lex_stream -> Kind(buffer[repair.buffer_position]);
diagnose.cpp:    lex_stream -> Reset(buffer[repair.buffer_position + 1]);
diagnose.cpp:            temp_stack_top -= (rhs[act]-1);
diagnose.cpp:            lex_stream -> AfterEol(buffer[repair.buffer_position]))
diagnose.cpp:            lex_stream -> AfterEol(buffer[repair.buffer_position+1]))
diagnose.cpp:    TokenObject prevtok = buffer[repair.buffer_position - 1],
diagnose.cpp:                         Loc(curtok), lex_stream -> Next(curtok));
diagnose.cpp:                                -scope_index[i],
diagnose.cpp:                            -scope_index[scope_stack_top],
diagnose.cpp:            lex_stream -> Reset(buffer[repair.buffer_position]);
diagnose.cpp:            lex_stream -> Reset(buffer[repair.buffer_position + 1]);
diagnose.cpp:            lex_stream -> Reset(buffer[repair.buffer_position + 2]);
diagnose.cpp:                      lex_stream -> Kind(buffer[repair.buffer_position + 1]);
diagnose.cpp:            lex_stream -> Reset(buffer[repair.buffer_position + 2]);
diagnose.cpp:/* parser is simulated until a shift (or shift-reduce) action    */
diagnose.cpp:    temp_stack_top = stack_top - 1;
diagnose.cpp:/* candidate until a SHIFT or SHIFT-REDUCE is computed. ERROR    */
diagnose.cpp:    lex_stream -> Reset(buffer[buffer_position]);
diagnose.cpp:        /* Process all goto-reduce actions following reduction,  */
diagnose.cpp:            temp_stack_top -= (rhs[act]-1);
diagnose.cpp:/* candidate and we are ready to shift or shift-reduce it. First,   */
diagnose.cpp:                        /* next move is shift or shift-reduce.      */
diagnose.cpp:    tok = lex_stream -> Kind(buffer[buffer_position]);
diagnose.cpp:    lex_stream -> Reset(buffer[buffer_position + 1]);
diagnose.cpp:    if (act > ERROR_ACTION)   /* shift-reduce on candidate? */
diagnose.cpp:        act -= ERROR_ACTION;
diagnose.cpp:        /* Process all goto-reduce actions following reduction,  */
diagnose.cpp:            temp_stack_top -= (rhs[act]-1);
diagnose.cpp:                           ? non_terminal_index[highest_symbol - NT_OFFSET]
diagnose.cpp:/* It returns the highest level non-terminal B such that         */
diagnose.cpp:    highest_symbol = sym - NT_OFFSET;
diagnose.cpp:    tok = lex_stream -> Kind(buffer[buffer_position]);
diagnose.cpp:    lex_stream -> Reset(buffer[buffer_position + 1]);
diagnose.cpp:        /* Process all goto-reduce actions following reduction,  */
diagnose.cpp:            temp_stack_top -= (rhs[act]-1);
diagnose.cpp:    int index = Spell::Index(lex_stream -> NameString(tok), keyword);
diagnose.cpp:        temp_stack_top = stack_top - 1;
diagnose.cpp:        lex_stream -> Reset(buffer[repair.buffer_position]);
diagnose.cpp:            /* ... Process all goto-reduce actions following */
diagnose.cpp:                temp_stack_top -= (rhs[act]-1);
diagnose.cpp:                 in_symbol(temp_stack[j]) == scope_rhs[k]; j--)
diagnose.cpp:                     j--)
diagnose.cpp:                /* the left-hand side of the scope is used as    */
diagnose.cpp:                /* after parsing the left-hand symbol.           */
diagnose.cpp:                    /* by the left-hand symbol, and recursively  */
diagnose.cpp:                    if ((distance - repair.buffer_position + 1) <
diagnose.cpp:                            top -= (rhs[act]-1);
diagnose.cpp:                    if (lex_stream -> Kind(buffer[repair.buffer_position]) ==
diagnose.cpp:    for (top = stack_top - 1; top >= 0; top--)
diagnose.cpp:                       lex_stream -> Kind(buffer[buffer_position]),
diagnose.cpp:        if (((j - buffer_position + 1) > MIN_DISTANCE) &&
diagnose.cpp:    if ((repair.distance - buffer_position) > MIN_DISTANCE &&
diagnose.cpp://    if ((manual_distance - repair.buffer_position) > MIN_DISTANCE &&
diagnose.cpp:        buffer[1] = lex_stream -> Previous(buffer[2]);
diagnose.cpp:        buffer[0] = lex_stream -> Previous(buffer[1]);
diagnose.cpp:            buffer[k] = lex_stream -> Next(buffer[k - 1]);
diagnose.cpp:        for (next_last_index = MAX_DISTANCE - 1;
diagnose.cpp:             lex_stream -> Kind(buffer[next_last_index]) == EOFT_SYMBOL;
diagnose.cpp:             next_last_index--);
diagnose.cpp:    buffer[2] = lex_stream -> Previous(buffer[3]);
diagnose.cpp:    buffer[1] = lex_stream -> Previous(buffer[2]);
diagnose.cpp:    buffer[0] = lex_stream -> Previous(buffer[1]);
diagnose.cpp:        buffer[k] = lex_stream -> Next(buffer[k - 1]);
diagnose.cpp:    for (last_index = MAX_DISTANCE - 1;
diagnose.cpp:             lex_stream -> Kind(buffer[last_index]) == EOFT_SYMBOL;
diagnose.cpp:         last_index--);
diagnose.cpp:/* recovery either deletes fewer symbols or parse-checks further */
diagnose.cpp:           (misplaced.distance - misplaced.num_deletions) >=
diagnose.cpp:           (repair.distance - repair.num_deletions))
diagnose.cpp:        buffer[1] = lex_stream -> Previous(buffer[2]);
diagnose.cpp:        buffer[0] = lex_stream -> Previous(buffer[1]);
diagnose.cpp:            buffer[k] = lex_stream -> Next(buffer[k - 1]);
diagnose.cpp:            k = scope_repair.buffer_position - 1;
diagnose.cpp:            if ((j - k) > MIN_DISTANCE &&
diagnose.cpp:                (j - k) > (repair.distance - repair.num_deletions))
diagnose.cpp:        lex_stream -> Kind(buffer[last_index]) == EOFT_SYMBOL)
diagnose.cpp:             top >= 0 && repair.code == 0; top--)
diagnose.cpp:             candidate.symbol = lex_stream -> Kind(buffer[2]);
diagnose.cpp:             lex_stream -> Reset(lex_stream -> Next(buffer[2]));
diagnose.cpp:                       lex_stream -> Kind(buffer[repair.buffer_position]);
diagnose.cpp:             lex_stream -> Reset(lex_stream ->
diagnose.cpp:             lex_stream -> Reset(buffer[repair.buffer_position]);
diagnose.cpp:    for (int top = stack_top - 1; top >= 0; top--)
diagnose.cpp:        int j = ParseCheck(stck, top, lex_stream -> Kind(buffer[2]), 3);
diagnose.cpp:            (j - stack_deletions) >
diagnose.cpp:            (repair.distance - repair.num_deletions))
diagnose.cpp:         top >= 0 && repair.num_deletions >= stack_deletions; top--)
diagnose.cpp:             i <= (last_index - MIN_DISTANCE + 1) &&
diagnose.cpp:             (repair.num_deletions >= (stack_deletions + i - 1)); i++)
diagnose.cpp:            j = ParseCheck(stck, top, lex_stream -> Kind(buffer[i]), i + 1);
diagnose.cpp:            if ((j - i + 1) > MIN_DISTANCE)
diagnose.cpp:                k = stack_deletions + i - 1;
diagnose.cpp:                    (j - k) > (repair.distance - repair.num_deletions) ||
diagnose.cpp:                     (j - k) == (repair.distance -
diagnose.cpp:                if ((j - i + 1) > MIN_DISTANCE)
diagnose.cpp:                    k = stack_deletions + i - 1;
diagnose.cpp:                       (j - k) > (repair.distance -
diagnose.cpp:                                -scope_index[i],
diagnose.cpp:                            -scope_index[scope_stack_top],
diagnose.cpp:                         buffer[repair.buffer_position - 1]);
diagnose.cpp:     histack[top] = errors.Length() - 1;
diagnose.cpp:         top--;
diagnose.cpp:             /* The array is most-likely almost sorted. Therefore,    */
diagnose.cpp:                 /* Recall that its right-span location is reached    */
diagnose.cpp:             if ((i - lower) < (upper - i))
diagnose.cpp:                 upper = i - 1;
diagnose.cpp:                 histack[top] = i - 1;
diagnose.cpp:        lex_stream -> RereadInput();
diagnose.cpp:    left_line_no = lex_stream -> Line(left_token);
diagnose.cpp:    left_column_no = lex_stream -> Column(left_token);
diagnose.cpp:    right_line_no = lex_stream -> Line(right_token);
diagnose.cpp:    right_column_no = lex_stream -> RightColumn(right_token);
diagnose.cpp:    return lex_stream -> FileName();
diagnose.cpp:        for (i = ParseError::scope_suffix[- (int)name_index];
diagnose.cpp:    lex_stream -> OutputSource(this, s);
diagnose.cpp:                << lex_stream -> FileName() << "\":";
diagnose.cpp:    lex_stream -> RereadInput();
diagnose.cpp:    if (! lex_stream -> InputBuffer())
diagnose.cpp:        char* file_name = lex_stream -> FileName();
diagnose.cpp:        int length = lex_stream -> FileNameLength();
diagnose.cpp:        control.system_semantic ->
diagnose.cpp:    int stack_top = -1;
diagnose.cpp:              stack_top--)
diagnose.cpp:                     j = error_stack[stack_top - 1];
diagnose.cpp:    for ( ; stack_top > 0; stack_top--)
diagnose.cpp:            j = error_stack[stack_top - 1];
diagnose.cpp:        lex_stream -> DestroyInput();
diagnose.cpp:    JikesAPI::getInstance() -> reportError(&errors[k]);
diagnose.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
diagnose.h:    enum { NIL = -1 };
Binary file diagnose.o matches
double.cpp:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $
double.cpp:        a  = -a; // even works for MIN_INT!
double.cpp:        l = -a;
double.cpp:        int exponent = FRACT_SIZE - 1, sticky = 0;
double.cpp:    if (d.Exponent() < -BIAS - 30)
double.cpp:            // A regular, normalized number - do work on the parts
double.cpp:            *this = Normalize(d.Sign(), d.Exponent() - 2, fraction);
double.cpp:            aadj1 = -1;
double.cpp:            // special case - mantissa is power of 2
double.cpp:            aadj1 = -aadj;
double.cpp:        aadj1 = dsign ? aadj : -aadj;
double.cpp:        value.word -= (FRACT_SIZE + 1) * MIN_FRACT;
double.cpp:        if (Exponent() >= BIAS - FRACT_SIZE)
double.cpp:            if (tmp.value.word == POS_INF - 1)
double.cpp:            value.word = POS_INF - 1;
double.cpp:        // correctly round *this + adj in some half-way cases.
double.cpp:        if (y <= FRACT_SIZE - BIAS || aadj > 1)
double.cpp:                aadj1 = -aadj1;
double.cpp:        aadj -= aadj.IntValue();
double.cpp:                    shift -= 4;
double.cpp:                    shift -= 4;
double.cpp:                    exponent = exponent * 10 + c - U_0;
double.cpp:                                *this = - *this;
double.cpp:                exponent = - exponent;
double.cpp:            y = 10 * y + c - U_0;
double.cpp:            if (c -= U_0)
double.cpp:                L = c - U_0;
double.cpp:                    L = 10 * L + c - U_0;
double.cpp:                if (s - s1 > 8 || L > 19999)
double.cpp:                    e = -e;
double.cpp:        k = nd - MAX_DIGITS;
double.cpp:        i = MAX_DIGITS - nd0;
double.cpp:            nf -= k;
double.cpp:            nf -= k;
double.cpp:        roundup = s0[MAX_DIGITS - 1 + j] != U_4;
double.cpp:    e1 = e -= nf;
double.cpp:    // decimal point, followed by nd-nd0 digits.  The number we're
double.cpp:                *this = -*this;
double.cpp:                    *this = -*this;
double.cpp:            i = 7 - nd;
double.cpp:                e -= i;
double.cpp:                    *this = -*this;
double.cpp:        else if (e >= -10 )
double.cpp:            *this /= tens[-e];
double.cpp:                *this = -*this;
double.cpp:    e1 += nd - k;
double.cpp:            value.word -= (FRACT_SIZE + 1) * MIN_FRACT;
double.cpp:            if (z > BIAS - FRACT_SIZE)
double.cpp:            if (z > BIAS - FRACT_SIZE - 1)
double.cpp:                value.word = POS_INF - 1;
double.cpp:        e1 = -e1;
double.cpp:    // Now the hard part -- adjusting *this to the correct value.
double.cpp:            bb2 = bb5 = -e;
double.cpp:            bd2 -= bbe;
double.cpp:        i = j + bbbits - 1; // logb(*this)
double.cpp:        if (i < 1 - BIAS) // denormal
double.cpp:            j = FRACT_SIZE + 2 - bbbits;
double.cpp:            bb2 -= i;
double.cpp:            bd2 -= i;
double.cpp:            bs2 -= i;
double.cpp:        BigInt delta = bb - bd;
double.cpp:        // Error is less than half an ulp -- check for
double.cpp:            if (dsign || FractBits() || Exponent() <= 1 - BIAS
double.cpp:                // boundary case -- decrement exponent
double.cpp:                value.word--;
double.cpp:        // exactly half-way between
double.cpp:                value.word += dsign ? 1 : -1;
double.cpp:        // more than 1/2 ulp off - try again
double.cpp:        // has an ICE caused by register over-allocation if it is inline.
double.cpp:        *this = -*this;
double.cpp:        result <<= (exponent - FRACT_SIZE);
double.cpp:        result >>= (FRACT_SIZE - exponent);
double.cpp:    return sign ? -result : result;
double.cpp:        result <<= (exponent - FRACT_SIZE);
double.cpp:        result >>= (FRACT_SIZE - exponent);
double.cpp:    return sign ? (LongInt) -result : result;
double.cpp:        if (round && (sticky || (fraction & 1)) && exponent > -BIAS)
double.cpp:            exponent--;
double.cpp:    if (exponent <= -BIAS)
double.cpp:        if (exponent < -BIAS - FRACT_SIZE)
double.cpp:        while (exponent <= -BIAS)
double.cpp:        exponent = -BIAS;
double.cpp:    if (exponent == -BIAS)
double.cpp:            exponent--;
double.cpp:    L = (i4) f.ExpBits() - FRACT_SIZE * MIN_FRACT;
double.cpp:        L = -L >> FRACT_SIZE;
double.cpp:    k = b.hi0bits() - a.hi0bits() + 32 * (a.wds - b.wds);
double.cpp:        fb.value.word -= k * MIN_FRACT;
double.cpp:    // Now for the real work - do manipulations on copies
double.cpp:        x = -x;
double.cpp:        y = -y;
double.cpp:        round = y << (32 + expy - expx);
double.cpp:        y >>= expx - expy;
double.cpp:        round = x << (32 + expx - expy);
double.cpp:        x >>= expy - expx;
double.cpp:    // Do the arithmetic. The excess magnitude of 32-bit arithmetic means
double.cpp:    // pre-alignment avoids any question of INT_MIN negation problems.
double.cpp:        x = -x;
double.cpp:    return Normalize(signx, expx - 6, (u4) x);
double.cpp:IEEEfloat IEEEfloat::operator- () const
double.cpp:    return IEEEfloat(-value.float_value);
double.cpp:    // Now for the real work - do manipulations on copies
double.cpp:    // will be 46-48 bits (unsigned); shift it back to 28 bits for Normalize,
double.cpp:    return Normalize(sign, exponent - 3, x);
double.cpp:    // Now for the real work - do manipulations on copies
double.cpp:    exponent = SplitInto(x) - op.SplitInto(y);
double.cpp:        exponent--;
double.cpp:            x -= y;
double.cpp:    return Normalize(sign, exponent - 8, result);
double.cpp:    // Now for the real work - do manipulations on copies
double.cpp:    // This algorithm is from fdlibm.c - see above notice
double.cpp:    exponent = SplitInto(x) - expy;
double.cpp:    while (exponent--)
double.cpp:        z = x - y;
double.cpp:    z = x - y;
double.cpp:    if (exponent == -IEEEfloat::Bias())
double.cpp:            *this = Normalize(sign, 1 - IEEEfloat::Bias(),
double.cpp:        a  = -a; // even works for MIN_INT!
double.cpp:        l  = -a; // even works for MIN_LONG!
double.cpp:                    shift -= 4;
double.cpp:                    shift -= 4;
double.cpp:                    exponent = exponent * 10 + c - U_0;
double.cpp:                                *this = - *this;
double.cpp:                exponent = - exponent;
double.cpp:            y = 10 * y + c - U_0;
double.cpp:            z = 10 * z + c - U_0;
double.cpp:            if (c -= U_0)
double.cpp:                L = c - U_0;
double.cpp:                    L = 10 * L + c - U_0;
double.cpp:                if (s - s1 > 8 || L > 19999)
double.cpp:                    e = -e;
double.cpp:        k = nd - MAX_DIGITS;
double.cpp:        i = MAX_DIGITS - nd0;
double.cpp:            nf -= k;
double.cpp:            nf -= k;
double.cpp:        roundup = s0[MAX_DIGITS - 1 + j] != U_4;
double.cpp:    e1 = e -= nf;
double.cpp:    // decimal point, followed by nd-nd0 digits.  The number we're
double.cpp:        *this = *this * tens[k - 9] + z;
double.cpp:                *this = -*this;
double.cpp:                    *this = -*this;
double.cpp:            i = 15 - nd;
double.cpp:                e -= i;
double.cpp:                    *this = -*this;
double.cpp:        else if (e >= -22 )
double.cpp:            *this /= tens[-e];
double.cpp:                *this = -*this;
double.cpp:    e1 += nd - k;
double.cpp:            setHighWord(HighWord() - (FRACT_SIZE + 1) * MIN_FRACT);
double.cpp:            if (z > BIAS - FRACT_SIZE)
double.cpp:            if (z > BIAS - FRACT_SIZE - 1)
double.cpp:                setHighAndLowWords(POS_INF_HI - 1, ZERO_LO - 1);
double.cpp:        e1 = -e1;
double.cpp:    // Now the hard part -- adjusting *this to the correct value.
double.cpp:            bb2 = bb5 = -e;
double.cpp:            bd2 -= bbe;
double.cpp:        i = j + bbbits - 1; // logb(*this)
double.cpp:        if (i < 1 - BIAS) // denormal
double.cpp:            j = FRACT_SIZE + 2 - bbbits;
double.cpp:            bb2 -= i;
double.cpp:            bd2 -= i;
double.cpp:            bs2 -= i;
double.cpp:        BigInt delta = bb - bd;
double.cpp:        // Error is less than half an ulp -- check for
double.cpp:                || Exponent() <= 1 - BIAS || delta.IsZero())
double.cpp:                // boundary case -- decrement exponent
double.cpp:                BaseLong::operator --();
double.cpp:        // exactly half-way between
double.cpp:                BaseLong::operator +=(dsign ? 1 : -1);
double.cpp:        // more than 1/2 ulp off - try again
double.cpp:                aadj1 = -1;
double.cpp:                // special case - mantissa is power of 2
double.cpp:                aadj1 = -aadj;
double.cpp:            //            aadj1 = dsign ? aadj : -aadj;
double.cpp:                aadj1 = -aadj;
double.cpp:            setHighWord(HighWord() - (FRACT_SIZE + 1) * MIN_FRACT);
double.cpp:            if (Exponent() >= BIAS - FRACT_SIZE)
double.cpp:                if (tmp.HighWord() == POS_INF_HI - 1 &&
double.cpp:                    tmp.LowWord() == ZERO_LO - 1)
double.cpp:                setHighAndLowWords(POS_INF_HI - 1, ZERO_LO - 1);
double.cpp:            // correctly round *this + adj in some half-way cases.
double.cpp:            if (y <= FRACT_SIZE - BIAS || aadj > 1)
double.cpp:                    aadj1 = -aadj1;
double.cpp:            aadj -= aadj.IntValue();
double.cpp:        *this = -*this;
double.cpp:    i4 result = (i4) (Fraction() >> (FRACT_SIZE - exponent)).LowWord();
double.cpp:    return sign ? -result : result;
double.cpp:        result <<= (exponent - FRACT_SIZE);
double.cpp:        result >>= (FRACT_SIZE - exponent);
double.cpp:    return sign ? (LongInt) -result : result;
double.cpp:            exponent > -(int) BIAS)
double.cpp:            exponent--;
double.cpp:    if (exponent <= -BIAS)
double.cpp:        if (exponent < -BIAS - FRACT_SIZE)
double.cpp:        while (exponent <= -BIAS)
double.cpp:        exponent = -BIAS;
double.cpp:    if (exponent == -(int) BIAS)
double.cpp:            exponent--;
double.cpp:    L = (i4) d.ExpBits() - FRACT_SIZE * MIN_FRACT;
double.cpp:        L = -L >> FRACT_SIZE_HI;
double.cpp:            L -= FRACT_SIZE_HI;
double.cpp:            d.setHighAndLowWords(0, L >= 31 ? 1 : 1 << (31 - L));
double.cpp:    k = b.hi0bits() - a.hi0bits() + 32 * (a.wds - b.wds);
double.cpp:        db.setHighWord(db.HighWord() - k * MIN_FRACT);
double.cpp:    // Now for the real work - do manipulations on copies
double.cpp:        x = -x;
double.cpp:        y = -y;
double.cpp:        round = y << (64 + expy - expx);
double.cpp:        y >>= expx - expy;
double.cpp:        round = x << (64 + expx - expy);
double.cpp:        x >>= expy - expx;
double.cpp:    // Do the arithmetic. The excess magnitude of 64-bit arithmetic means
double.cpp:    // pre-alignment avoids any question of LONG_MIN negation problems.
double.cpp:        x = -x;
double.cpp:    return Normalize(signx, expx - 8, (ULongInt) x);
double.cpp:IEEEdouble IEEEdouble::operator- () const
double.cpp:    return IEEEdouble(-value.double_value);
double.cpp:    // Now for the real work - do manipulations on copies
double.cpp:    return Normalize(sign, exponent - 8, x);
double.cpp:    // Now for the real work - do manipulations on copies
double.cpp:    exponent = SplitInto(x) - op.SplitInto(y);
double.cpp:        exponent--;
double.cpp:            x -= y;
double.cpp:    return Normalize(sign, exponent - 11, result);
double.cpp:    // Now for the real work - do manipulations on copies
double.cpp:    // This algorithm is from fdlibm.c - see above notice
double.cpp:    exponent = SplitInto(x) - expy;
double.cpp:    while (exponent--)
double.cpp:        z = x - y;
double.cpp:    z = x - y;
double.cpp:        e = k + fe - IEEEfloat::FractSize();
double.cpp:        bits = IEEEfloat::FractSize() - k + 1;
double.cpp:        e = k + fe - IEEEfloat::FractSize() + 1;
double.cpp:        bits = 32 - hi0bits(z);
double.cpp:            data[0] = y | z << (32 - k);
double.cpp:        e = k + de - IEEEdouble::FractSize();
double.cpp:        bits = IEEEdouble::FractSize() - k + 1;
double.cpp:        e = k + de - IEEEdouble::FractSize() + 1;
double.cpp:        bits = 32 * wds - hi0bits(data[wds - 1]);
double.cpp:            multadd(10, *s++ - U_0);
double.cpp:        multadd(10, *s++ - U_0);
double.cpp:BigInt BigInt::operator -(const BigInt &op) const
double.cpp:    i = a -> compareTo(op);
double.cpp:    c.resize(a -> k);
double.cpp:    wa = a -> wds;
double.cpp:    xa = a -> data;
double.cpp:    wb = b -> wds;
double.cpp:    xb = b -> data;
double.cpp:        y = ULongInt(*xa++) - *xb++ - borrow;
double.cpp:        y = ULongInt(*xa++) - borrow;
double.cpp:    while (!*--xc)
double.cpp:        wa--;
double.cpp:    int k; // c -> k
double.cpp:    if (a -> wds < b -> wds)
double.cpp:    k = a -> k;
double.cpp:    wa = a -> wds;
double.cpp:    wb = b -> wds;
double.cpp:    if (wc > a -> maxwds)
double.cpp:    c.neg = a -> neg ^ b -> neg;
double.cpp:    xa = a -> data;
double.cpp:    xb = b -> data;
double.cpp:    for (xc0 = c.data, xc = xc0 + wc; wc > 0 && !*--xc; --wc);
double.cpp:        k1 = 32 - op;
double.cpp:    result.wds = n1 - 1;
double.cpp:            p5 = bigfives[i] = new BigInt(*bigfives[i-1] * *bigfives[i-1]);
double.cpp:    if (i -= j)
double.cpp:        if (*--xa != *--xb)
double.cpp:            return *xa < *xb ? -1 : 1;
double.cpp:    sxe = sx + --n;
double.cpp:            y = ULongInt(*bx) - ys.LowWord() - borrow;
double.cpp:            while (--bxe > bx && !*bxe)
double.cpp:                --n;
double.cpp:            y = ULongInt(*bx) - ys.LowWord() - borrow;
double.cpp:            while (--bxe > bx && !*bxe)
double.cpp:                --n;
double.cpp:    y = *--xa;
double.cpp:        return IEEEfloat(0x3f800000 | y >> (8 - k));
double.cpp:    z = xa > data ? *--xa : 0;
double.cpp:    if (k -= 8)
double.cpp:        return IEEEfloat(0x3f800000 | y << k | z >> (32 - k));
double.cpp:    y = *--xa;
double.cpp:        hi = 0x3ff00000 | y >> (11 - k);
double.cpp:        w = xa > data ? *--xa : 0;
double.cpp:        lo = y << (32 - 11 + k) | w >> (11 - k);
double.cpp:    z = xa > data ? *--xa : 0;
double.cpp:    if (k -= 11)
double.cpp:        hi = 0x3ff00000 | y << k | z >> (32 - k);
double.cpp:        y = xa > data ? *--xa : 0;
double.cpp:        lo = z << k | y >> (32 - k);
double.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
double.h:    // compiler-supported IEEE operations.  If not, then this class
double.h:        MAX_DIGITS = BIAS + FRACT_SIZE + 1 - MAX_DEC_EXP
double.h:        NEG_ZERO = 0x80000000, // -0.0
double.h:        NEG_INF = 0xFF800000, // -Inf
double.h:        return ((value.word & EXP_BITS) >> FRACT_SIZE) - BIAS;
double.h:    // fields, rather than generating a non-const every time.  However,
double.h:    // Floating-point operations
double.h:    inline IEEEfloat operator++() { return *this += 1; } // pre-increment
double.h:    inline IEEEfloat operator++(int) // post-increment
double.h:    IEEEfloat operator-() const;        // unary minus
double.h:    inline IEEEfloat operator-(const IEEEfloat op) const // binary subtraction
double.h:        return *this + (-op);
double.h:    inline IEEEfloat& operator-=(const IEEEfloat op) // subtract and assign
double.h:        return *this = *this - op;
double.h:    inline IEEEfloat operator--() { return *this -= 1; } // pre-decrement
double.h:    inline IEEEfloat operator--(int) // post-decrement
double.h:        *this -= 1;
double.h:    // Comparison operators.  Recall that NaN does not compare, and 0.0 == -0.0
double.h:    bool operator<(const IEEEfloat) const; // less-than
double.h:    bool operator>(const IEEEfloat) const; // greater-than
double.h:    bool operator<=(const IEEEfloat) const; // less-than or equal
double.h:    bool operator>=(const IEEEfloat) const; // greater-than or equal
double.h:    //  * -0.0f and 0.0f are different, with positive 0 comparing as greater
double.h:            : (IsZero() && op.IsZero()) ? op.Sign() - Sign()
double.h:            : (*this < op) ? -1 : *this > op;
double.h:    // compiler-supported IEEE operations.  If not, then this class
double.h:        FRACT_SIZE_HI = FRACT_SIZE - 32, // mantissa bits in high word
double.h:        MAX_DIGITS = BIAS + FRACT_SIZE + 1 - MAX_DEC_EXP
double.h:        NEG_ZERO_HI = 0x80000000, // -0.0
double.h:        NEG_INF_HI = 0xFFF00000, // -Inf
double.h:        return ((HighWord() & EXP_BITS) >> (FRACT_SIZE_HI)) - BIAS;
double.h:        return ((high & ABS_BITS) | ((low | -(i4) low) >> 31)) > EXP_BITS;
double.h:    // fields, rather than generating a non-const every time, as in
double.h:    // Floating-point operations
double.h:    inline IEEEdouble operator++() { return *this += 1; } // pre-increment
double.h:    inline IEEEdouble operator++(int) // post-increment
double.h:    IEEEdouble operator-() const;         // unary minus
double.h:    inline IEEEdouble operator-(const IEEEdouble op) const // binary subtract
double.h:        return *this + (-op);
double.h:    inline IEEEdouble& operator-=(const IEEEdouble op) // subtract and assign
double.h:        return *this = *this - op;
double.h:    inline IEEEdouble operator--() { return *this -= 1; } // pre-decrement
double.h:    inline IEEEdouble operator--(int) // post-decrement
double.h:        *this -= 1;
double.h:    // Comparison operators.  Recall that NaN does not compare, and 0.0 == -0.0
double.h:    bool operator<(const IEEEdouble) const; // less-than
double.h:    bool operator>(const IEEEdouble) const; // greater-than
double.h:    bool operator<=(const IEEEdouble) const; // less-than or equal
double.h:    bool operator>=(const IEEEdouble) const; // greater-than or equal
double.h:    //  * -0.0 and 0.0 are different, with positive 0 comparing as greater
double.h:            : (IsZero() && op.IsZero()) ? op.Sign() - Sign()
double.h:            : (*this < op) ? -1 : *this > op;
double.h:    // return count of high-order 0's in x
double.h:    // return count of low-order 0's in y, shift y so that
double.h:    inline int hi0bits() const { assert(data); return hi0bits(data[wds - 1]); }
double.h:    inline BigInt& operator++() { return *this += 1; } // pre-increment
double.h:    BigInt operator-(const BigInt& op) const;
double.h:    this -> k = k;
Binary file double.o matches
dump.cpp:                FindColumn(comments[com].location - 1) + 1);
dump.cpp:                    FindColumn(comments[com].location - 1) + 1);
Binary file dump.o matches
error.cpp:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $
error.cpp:        if (lex_stream -> NumBadTokens() > 0)
error.cpp:            lex_stream -> PrintMessages();
error.cpp:        else if (lex_stream -> NumWarnTokens() > 0)
error.cpp:            lex_stream -> PrintMessages();
error.cpp:            compilation_unit -> BadCompilationUnitCast())
error.cpp:    if (error && error -> error.Length() > 0 &&
error.cpp:        error -> PrintMessages() > return_code)
error.cpp:    // Not thread-safe, but jikes isn't threaded.
error.cpp:    left_line_no = lex_stream -> Line(left_token);
error.cpp:    left_column_no = lex_stream -> Column(left_token);
error.cpp:    right_line_no = lex_stream -> Line(right_token);
error.cpp:    right_column_no = lex_stream -> RightColumn(right_token);
error.cpp:    return lex_stream -> FileName();
error.cpp:    lex_stream -> OutputSource(this, s);
error.cpp:      lex_stream(file_symbol -> lex_stream),
error.cpp:    // Some warning severities are dependent on command-line options, and
error.cpp:    // Don't report non-mandatory errors if we're in -nowarn mode.
error.cpp:        lex_stream -> RereadInput();
error.cpp:    // group can be named for command-line use.
error.cpp:// 'name' is used on the command-line, and with 'reason' in
error.cpp:// Jikes' -help output.
error.cpp:// HOWTO: Add a +Pno-<something> flag to selectively enable/disable a warning.
error.cpp:    group = new MessageGroup("modifier-order",
error.cpp:    group -> AddMessage(RECOMMENDED_MODIFIER_ORDER);
error.cpp:    group -> AddMessage(RECOMMENDED_ANNOTATION_ORDER);
error.cpp:    group = new MessageGroup("redundant-modifiers",
error.cpp:    group -> AddMessage(REDUNDANT_MODIFIER);
error.cpp:    group -> AddMessage(BAD_SERIAL_VERSION_UID);
error.cpp:    group -> AddMessage(EJ_SERIALIZABLE_INNER_CLASS);
error.cpp:    group -> AddMessage(MISSING_SERIAL_VERSION_UID);
error.cpp:    group -> AddMessage(UNNEEDED_SERIAL_VERSION_UID);
error.cpp:    group -> AddMessage(HIDDEN_FIELD);
error.cpp:    group -> AddMessage(LOCAL_SHADOWS_FIELD);
error.cpp:    group -> AddMessage(SWITCH_FALLTHROUGH);
error.cpp:    group = new MessageGroup("naming-convention",
error.cpp:    group -> AddMessage(UNCONVENTIONAL_CLASS_NAME);
error.cpp:    group -> AddMessage(UNCONVENTIONAL_CONSTANT_FIELD_NAME);
error.cpp:    group -> AddMessage(UNCONVENTIONAL_FIELD_NAME);
error.cpp:    group -> AddMessage(UNCONVENTIONAL_METHOD_NAME);
error.cpp:    group -> AddMessage(UNCONVENTIONAL_VARIABLE_NAME);
error.cpp:    group = new MessageGroup("effective-java",
error.cpp:    group -> AddMessage(EJ_AVOID_OVERLOADING_EQUALS);
error.cpp:    group -> AddMessage(EJ_EMPTY_CATCH_BLOCK);
error.cpp:    group -> AddMessage(EJ_EMPTY_FINALLY_BLOCK);
error.cpp:    group -> AddMessage(EJ_EQUALS_WITHOUT_HASH_CODE);
error.cpp:    group -> AddMessage(EJ_HASH_CODE_WITHOUT_EQUALS);
error.cpp:    group -> AddMessage(EJ_INTERFACE_DOES_NOT_DEFINE_TYPE);
error.cpp:    group -> AddMessage(EJ_MISSING_PRIVATE_CONSTRUCTOR);
error.cpp:    group -> AddMessage(EJ_OVERLY_GENERAL_THROWS_CLAUSE);
error.cpp:    group -> AddMessage(EJ_PUBLIC_STATIC_FINAL_ARRAY_FIELD);
error.cpp:    group -> AddMessage(EJ_RETURN_OF_NULL_ARRAY);
error.cpp:    group = new MessageGroup("unused-type-imports",
error.cpp:                             "unused single-type import statements",
error.cpp:    group -> AddMessage(UNUSED_TYPE_IMPORT);
error.cpp:    group = new MessageGroup("unused-package-imports",
error.cpp:    group -> AddMessage(UNUSED_PACKAGE_IMPORT);
error.cpp:// command-line. Called by the code that handles the -help option.
error.cpp:        printf("+P[no-]%-*s", SPACE_FOR_NAME, group -> name);
error.cpp:        if (strlen(group -> name) >= SPACE_FOR_NAME)
error.cpp:        printf("warn about %s\n", group -> reason);
error.cpp:        if (group -> level == NAMED_WEAK_ON ||
error.cpp:            group -> level == NAMED_STRONG_ON)
error.cpp:        assert(group -> level > DISABLED); // Is this a named warning?
error.cpp:        for (unsigned c = 0; c < group -> codes.Length(); ++c)
error.cpp:            SemanticErrorKind kind = group -> codes[c];
error.cpp:                warning[kind] = group -> level;
error.cpp:// Processes a command-line option enabling or disabling a warning.
error.cpp:// Command-line options are of the form +P<name> or +Pno-<name> to
error.cpp:// synonyms like -Xswitchcheck also use this method).
error.cpp:    // Is this +P<name> or +Pno-<name>?
error.cpp:    if (strncmp(image, "no-", 3) == 0)
error.cpp:    // +P[no-]all turns everything on/off.
error.cpp:        if (override || strcmp(group -> name, image) == 0)
error.cpp:            for (unsigned c = 0; c < group -> codes.Length(); ++c)
error.cpp:                SemanticErrorKind kind = group -> codes[c];
error.cpp:                switch(group -> level)
error.cpp:     histack[top] = error.Length() - 1;
error.cpp:         top--;
error.cpp:             // The array is most-likely almost sorted. Therefore,
error.cpp:                 // Recall that its right-span location is reached
error.cpp:             if ((i - lower) < (upper - i))
error.cpp:                 upper = i - 1;
error.cpp:                 histack[top] = i - 1;
error.cpp:                    << (lex_stream -> file_symbol -> semantic ==
error.cpp:                    << (lex_stream -> file_symbol -> semantic ==
error.cpp:        if (lex_stream -> file_symbol -> semantic !=
error.cpp:            Coutput << " compiling \"" << lex_stream -> FileName() << '\"';
error.cpp:    if (lex_stream -> file_symbol -> semantic != control.system_semantic)
error.cpp:        lex_stream -> RereadInput();
error.cpp:        if (! lex_stream -> InputBuffer())
error.cpp:            char *file_name = lex_stream -> FileName();
error.cpp:            int length = lex_stream -> FileNameLength();
error.cpp:            control.system_semantic ->
error.cpp:    if (lex_stream -> file_symbol -> semantic == control.system_semantic ||
error.cpp:        lex_stream -> InputBuffer())
error.cpp:        lex_stream -> DestroyInput();
error.cpp:    return insert[index - 1];
error.cpp:        s << "                " << path_symbol -> Name() << endl;
error.cpp:    int index = insert_char - '0';
error.cpp:    int index = insert_char - '0';
error.cpp:// If the given insert is non-NULL, writes " or this.<insert-text>" to the
error.cpp:    int index = insert_char - '0';
error.cpp:                s << err.getInsert(verb - '0');
error.cpp:                s << lex_stream -> FileName();
error.cpp:    JikesAPI::getInstance() -> reportError(&error[k]);
error.cpp://       lex_stream -> FileName() as an insert.
error.cpp://   %Qn Writes an optional this-qualified name. The name is written if
error.cpp://       insert<n> is non-NULL, otherwise nothing is written. The text written
error.cpp://       is of the form " or this.<insert-text>".
error.cpp:        "A non-standard version of the type \"%T1\" "
error.cpp:        "in your choice of -target. Either use \"-target 1.4\" or greater, or "
error.cpp:        "use \"--noassert\" (or \"+a\") at the command line.";
error.cpp:        "The shift count of %1 is >= the %2-bit width of the type.";
error.cpp:        "because file names are case-insensitive in this system.";
error.cpp:        "An overly-general throws clause obscures which exceptions may "
error.cpp:        "Return a zero-length array instead of null. This avoids the need "
error.cpp:        "for special-case code in the caller. "
error.cpp:        "The default serialized form of an inner class is ill-defined; "
error.cpp:        "in \"%T4\" has a different return type than the non-inherited "
error.cpp:        "The left-hand side of an assignment must be a variable.";
error.cpp:        "The type of the left sub-expression, \"%T1\", cannot possibly "
error.cpp:        "The type of the right sub-expression, \"%T3\", is not "
error.cpp:        "The type of the left sub-expression, \"%T1\", is not "
error.cpp:        "compatible with the type of the right sub-expression, \"%T3\".";
error.cpp:        "In the conditional, the type of the true sub-expression, "
error.cpp:        "sub-expression, \"%T3\".";
error.cpp:        "A byte value must be an integer value in the range -128..127.";
error.cpp:        "A short value must be an integer value in the range -32768..32767.";
error.cpp:        "range -2147483648..2147483647 or a hexadecimal or octal literal "
error.cpp:        "-9223372036854775808L..9223372036854775807L or a hexadecimal or "
error.cpp:    // JDK 1.5 (JLS3) feature-related errors.
error.cpp:        "Hexadecimal floating point values are only supported for `-source "
error.cpp:        "for `-source 1.5' or greater.";
error.cpp:        "Variable-arity methods (also known as varargs) are only supported "
error.cpp:        "for `-source 1.5' or greater."
error.cpp:        "Static imports are only supported for `-source 1.5' or greater."
error.cpp:        "Annotation modifiers are only supported for `-source 1.5' or "
error.cpp:        "Annotation types are only supported for `-source 1.5' or greater."
error.cpp:        "Enumeration types are only supported for `-source 1.5' or greater."
error.cpp:        "use the \"enum\" keyword added in `-source 1.5'.";
error.cpp:        "\"-source 1.5\" or greater. Compilation will continue using the raw "
error.cpp:        "\"-source 1.5\" or greater. Compilation will continue, but will "
error.cpp:        "Covariant return types require the use of \"-source 1.5\" or "
error.cpp:        "Wildcard type parameters are not yet supported in \"-source 1.5\".";
error.cpp:        "Explicit type arguments are not yet supported in \"-source 1.5\".";
error.cpp:    // More type-related errors.
error.cpp:        "not implemented in the non-abstract class \"%T4\".";
error.cpp:        "\"%1\" is either a misplaced package name or a non-existent entity. "
error.cpp:        "The declaration of the non-abstract and non-native method, \"%1\", "
error.cpp:        "This catch block is unreachable because there is no non-null "
error.cpp:        "represent a compile-time constant, but is enclosed in an inner "
error.cpp:        "Invalid reference in inner class \"%T1\" to a non-final "
error.cpp:        "non-static member type \"%T3\" of the enclosing type \"%T5\".";
error.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
error.h:// WARNING: It is not thread-safe - calling Array() in multiple threads may
error.h:    // The returned value is not thread-safe, and is only guaranteed valid
error.h:        // JDK 1.5 (JLS3) feature-related errors.
error.h:        // More type-related errors.
error.h:    void ExitingClone() { clone_count--; }
Binary file error.o matches
expr.cpp:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $
expr.cpp:        semantic -> ReportSemError(SemanticError::CONSTANT_OVERFLOW, expr,
expr.cpp:                                   expr -> Type() -> Name());
expr.cpp:                x < zero && y < zero && x >= (min - y) ||
expr.cpp:                x > zero && y > zero && x <= (max - y);
expr.cpp:    CheckIntegerAddition(semantic, expr, x, T(-y));
expr.cpp:    const T minus_one = T(-1);
expr.cpp:                x < zero && y < zero && T(-x) <= max/-y ||
expr.cpp:    const T minus_one = T(-1);
expr.cpp:    if (! expr -> IsConstant() ||
expr.cpp:        ! control.IsSimpleIntegerValueType(expr -> Type()))
expr.cpp:    IntLiteralValue* literal = DYNAMIC_CAST<IntLiteralValue*> (expr -> value);
expr.cpp:        (type == control.char_type && (literal -> value >= 0) &&
expr.cpp:         (literal -> value <= 65535)) ||
expr.cpp:        (type == control.byte_type && (literal -> value >= -128) &&
expr.cpp:         (literal -> value <= 127)) ||
expr.cpp:        (type == control.short_type && (literal -> value >= -32768) &&
expr.cpp:         (literal -> value <= 32767));
expr.cpp:    return expr -> IsConstant() && expr -> Type() == control.boolean_type &&
expr.cpp:        DYNAMIC_CAST<IntLiteralValue*> (expr -> value) -> value;
expr.cpp:    return expr -> IsConstant() && expr -> Type() == control.boolean_type &&
expr.cpp:        ! DYNAMIC_CAST<IntLiteralValue*> (expr -> value) -> value;
expr.cpp://      if (! CanMethodInvocationConvert(target_method -> containing_type,
expr.cpp://                                       source_method -> containing_type))
expr.cpp:    for (int k = target_method -> NumFormalParameters() - 1; k >= 0; k--)
expr.cpp:        if (! CanMethodInvocationConvert(target_method -> FormalParameter(k) ->
expr.cpp:                                         source_method -> FormalParameter(k) ->
expr.cpp:                           maximally_specific_method[i] -> method_symbol))
expr.cpp:        if (MoreSpecific(maximally_specific_method[i] -> method_symbol, method))
expr.cpp:    unsigned num_arguments = args -> NumArguments();
expr.cpp:    int length = name -> NameLength();
expr.cpp:        TypeSymbol* arg_type = args -> Argument(i) -> Type();
expr.cpp:        length += arg_type -> ContainingPackage() -> PackageNameLength() +
expr.cpp:            arg_type -> ExternalNameLength() + 3;
expr.cpp:    for (s2 = name -> Name(); *s2; s2++)
expr.cpp:            TypeSymbol* arg_type = args -> Argument(i) -> Type();
expr.cpp:            PackageSymbol* package = arg_type -> ContainingPackage();
expr.cpp:            wchar_t* package_name = package -> PackageName();
expr.cpp:            if (package -> PackageNameLength() > 0 &&
expr.cpp:            for (s2 = arg_type -> ExternalName(); *s2; s2++)
expr.cpp:        s -= 2; // remove the last ',' and ' '
expr.cpp:// the same parameter count; an accessible field by the same name (for no-arg
expr.cpp:    AstExpression* base = method_call -> base_opt;
expr.cpp:    TokenIndex id_token = method_call -> identifier_token;
expr.cpp:    NameSymbol* name_symbol = lex_stream -> NameSymbol(id_token);
expr.cpp:    for (env = top_env -> previous; ! base && env; env = env -> previous)
expr.cpp:                           method_call, others[0] -> method_symbol -> Header(),
expr.cpp:                           others[0] -> method_symbol -> containing_type -> ContainingPackageName(),
expr.cpp:                           others[0] -> method_symbol -> containing_type -> ExternalName());
expr.cpp:         env = (base ? (SemanticEnvironment*) NULL : env -> previous))
expr.cpp:            type = env -> Type();
expr.cpp:        if (! type -> expanded_method_table)
expr.cpp:        for (method_shadow = type -> expanded_method_table ->
expr.cpp:             method_shadow; method_shadow = method_shadow -> next_method)
expr.cpp:            MethodSymbol* method = method_shadow -> method_symbol;
expr.cpp:            if (! method -> IsTyped())
expr.cpp:                method -> ProcessMethodSignature(this, id_token);
expr.cpp:                method_shadow -> NumConflicts() > 0)
expr.cpp:                int diff = method_call -> arguments -> NumArguments() -
expr.cpp:                    method -> NumFormalParameters();
expr.cpp:                    diff = - diff;
expr.cpp:            wchar_t* header = Header(name_symbol, method_call -> arguments);
expr.cpp:                           best_match -> containing_type -> ContainingPackageName(),
expr.cpp:                           best_match -> containing_type -> ExternalName(),
expr.cpp:                           best_match -> Header());
expr.cpp:    // For a no-arg method, search for an accessible field of the same name.
expr.cpp:    if (method_call -> arguments -> NumArguments() == 0)
expr.cpp:             env = (base ? (SemanticEnvironment*) NULL : env -> previous))
expr.cpp:                type = env -> Type();
expr.cpp:            if (! type -> expanded_field_table)
expr.cpp:            VariableShadowSymbol* variable_shadow = type ->
expr.cpp:                expanded_field_table -> FindVariableShadowSymbol(name_symbol);
expr.cpp:                VariableSymbol* variable = variable_shadow -> variable_symbol;
expr.cpp:                        variable -> owner -> TypeCast();
expr.cpp:                                   method_call, variable -> Name(),
expr.cpp:                                   enclosing_type -> ContainingPackageName(),
expr.cpp:                                   enclosing_type -> ExternalName());
expr.cpp:         super_type; super_type = super_type -> super)
expr.cpp:        for (method_shadow = super_type -> expanded_method_table ->
expr.cpp:             method_shadow; method_shadow = method_shadow -> next_method)
expr.cpp:            MethodSymbol* method = method_shadow -> method_symbol;
expr.cpp:            if (! method -> IsTyped())
expr.cpp:                method -> ProcessMethodSignature(this, id_token);
expr.cpp:            if (method_call -> arguments -> NumArguments() ==
expr.cpp:                method -> NumFormalParameters())
expr.cpp:                     i < method_call -> arguments -> NumArguments(); i++)
expr.cpp:                        method_call -> arguments -> Argument(i);
expr.cpp:                    if (! CanMethodInvocationConvert(method -> FormalParameter(i) -> Type(),
expr.cpp:                                                     expr -> Type()))
expr.cpp:                if (i == method_call -> arguments -> NumArguments())
expr.cpp:                    if (base && method -> ACC_PROTECTED() &&
expr.cpp:                        base -> Type() -> ACC_INTERFACE())
expr.cpp:                        assert(method -> containing_type == control.Object());
expr.cpp:                                       method_call, method -> Header());
expr.cpp:                    else if (method -> ACC_PROTECTED() &&
expr.cpp:                             ! method -> ACC_STATIC() &&
expr.cpp:                             ThisType() -> HasProtectedAccessTo(method -> containing_type))
expr.cpp:                                       method_call, method -> Header(),
expr.cpp:                                       method -> containing_type -> ContainingPackageName(),
expr.cpp:                                       method -> containing_type -> ExternalName(),
expr.cpp:                                       ThisType() -> ContainingPackageName(),
expr.cpp:                                       ThisType() -> ExternalName());
expr.cpp:                                       method_call, method -> Header(),
expr.cpp:                                       method -> containing_type -> ContainingPackageName(),
expr.cpp:                                       method -> containing_type -> ExternalName(),
expr.cpp:                                       method -> AccessString());
expr.cpp:         env = (base ? (SemanticEnvironment*) NULL : env -> previous))
expr.cpp:            type = env -> Type();
expr.cpp:                           method_call, name_symbol -> Name(),
expr.cpp:                           type -> ContainingPackageName(),
expr.cpp:                           type -> ExternalName(), best_match -> Name());
expr.cpp:                       name_symbol -> Name());
expr.cpp:        wchar_t* header = Header(name_symbol, method_call -> arguments);
expr.cpp:                       header, type -> ContainingPackageName(),
expr.cpp:                       type -> ExternalName());
expr.cpp:        ast -> ClassCreationExpressionCast();
expr.cpp:    AstSuperCall* super_call = ast -> SuperCallCast();
expr.cpp:        args = class_creation -> arguments;
expr.cpp:        left_tok = class_creation -> new_token;
expr.cpp:        if (class_creation -> class_body_opt)
expr.cpp:        args = super_call -> arguments;
expr.cpp:        left_tok = super_call -> super_token;
expr.cpp:        AstThisCall* this_call = ast -> ThisCallCast();
expr.cpp:        args = this_call -> arguments;
expr.cpp:        left_tok = this_call -> this_token;
expr.cpp:    unsigned num_arguments = args -> NumArguments();
expr.cpp:    TokenIndex right_tok = args -> right_parenthesis_token;
expr.cpp:    for (ctor = type -> FindMethodSymbol(control.init_name_symbol);
expr.cpp:         ctor; ctor = ctor -> next_method)
expr.cpp:            int diff = num_arguments - ctor -> NumFormalParameters();
expr.cpp:                diff = - diff;
expr.cpp:        wchar_t* header = Header(type -> Identity(), args);
expr.cpp:                       header, type -> ContainingPackageName(),
expr.cpp:                       type -> ExternalName(), best_match -> Header());
expr.cpp:    for (ctor = type -> FindMethodSymbol(control.init_name_symbol);
expr.cpp:         ctor; ctor = ctor -> next_method)
expr.cpp:        if (num_arguments == ctor -> NumFormalParameters())
expr.cpp:                AstExpression* expr = args -> Argument(i);
expr.cpp:                if (! CanMethodInvocationConvert(ctor -> FormalParameter(i) -> Type(),
expr.cpp:                                                 expr -> Type()))
expr.cpp:                               ctor -> Header(),
expr.cpp:                               type -> ContainingPackageName(),
expr.cpp:                               type -> ExternalName(), ctor -> AccessString());
expr.cpp:    for (method = type -> FindMethodSymbol(type -> Identity());
expr.cpp:         method; method = method -> next_method)
expr.cpp:        if (! method -> IsTyped())
expr.cpp:            method -> ProcessMethodSignature(this, right_tok);
expr.cpp:        if (num_arguments == method -> NumFormalParameters())
expr.cpp:                if (! CanMethodInvocationConvert(method -> FormalParameter(i) -> Type(),
expr.cpp:                                                 args -> Argument(i) -> Type()))
expr.cpp:        if (method -> declaration)
expr.cpp:                (AstMethodDeclaration*) method -> declaration;
expr.cpp:            FileLocation loc((method -> containing_type ->
expr.cpp:                              semantic_environment -> sem -> lex_stream),
expr.cpp:                             (method_declaration -> method_declarator ->
expr.cpp:                           left_tok, right_tok, type -> Name(),
expr.cpp:                           left_tok, right_tok, type -> Name(),
expr.cpp:                           method -> containing_type -> file_location -> location);
expr.cpp:    wchar_t* header = Header(type -> Identity(), args);
expr.cpp:                   type -> ContainingPackageName(), type -> ExternalName());
expr.cpp:    if (containing_type -> Anonymous())
expr.cpp:        return containing_type -> declaration -> default_constructor ->
expr.cpp:        ast -> ClassCreationExpressionCast();
expr.cpp:    AstSuperCall* super_call = ast -> SuperCallCast();
expr.cpp:        args = class_creation -> arguments;
expr.cpp:        if (class_creation -> class_body_opt)
expr.cpp:        args = super_call -> arguments;
expr.cpp:        AstThisCall* this_call = ast -> ThisCallCast();
expr.cpp:        args = this_call -> arguments;
expr.cpp:    unsigned num_arguments = args -> NumArguments();
expr.cpp:    assert(containing_type -> ConstructorMembersProcessed());
expr.cpp:    for (ctor = containing_type -> FindMethodSymbol(control.init_name_symbol);
expr.cpp:         ctor; ctor = ctor -> next_method)
expr.cpp:        if (! ctor -> IsTyped())
expr.cpp:            ctor -> ProcessMethodSignature(this, right_tok);
expr.cpp:        if (num_arguments == ctor -> NumFormalParameters() &&
expr.cpp:                if (! CanMethodInvocationConvert(ctor -> FormalParameter(i) -> Type(),
expr.cpp:                                                 args -> Argument(i) -> Type()))
expr.cpp:        if (! containing_type -> Bad() || NumErrors() == 0)
expr.cpp:                       left_tok, right_tok, containing_type -> Name(),
expr.cpp:                       constructor_set[0] -> Header(),
expr.cpp:                       constructor_set[1] -> Header());
expr.cpp:    if (ctor -> ACC_SYNTHETIC())
expr.cpp:                       left_tok, right_tok, ctor -> Header(),
expr.cpp:                       containing_type -> ContainingPackageName(),
expr.cpp:                       containing_type -> ExternalName());
expr.cpp:    ctor -> ProcessMethodThrows(this, right_tok);
expr.cpp:    if (control.option.deprecation && ctor -> IsDeprecated() &&
expr.cpp:                       left_tok, right_tok, ctor -> Header(),
expr.cpp:                       ctor -> containing_type -> ContainingPackageName(),
expr.cpp:                       ctor -> containing_type -> ExternalName());
expr.cpp:    AstFieldAccess* field_access = expr -> FieldAccessCast();
expr.cpp:    AstName* field_name = expr -> NameCast();
expr.cpp:        field_name ? field_name -> base_opt : field_access -> base;
expr.cpp:    TokenIndex identifier_token = expr -> RightToken();
expr.cpp:    const wchar_t* name = lex_stream -> NameString(identifier_token);
expr.cpp:         k < type -> expanded_field_table -> symbol_pool.Length(); k++)
expr.cpp:            type -> expanded_field_table -> symbol_pool[k];
expr.cpp:        VariableSymbol* variable = variable_shadow -> variable_symbol;
expr.cpp:        if (! variable -> IsTyped())
expr.cpp:            variable -> ProcessVariableSignature(this, identifier_token);
expr.cpp:             ! variable && i < variable_shadow -> NumConflicts(); i++)
expr.cpp:            variable = variable_shadow -> Conflict(i);
expr.cpp:            if (! variable -> IsTyped())
expr.cpp:                variable -> ProcessVariableSignature(this,
expr.cpp:            int new_index = Spell::Index(name, variable -> Name());
expr.cpp:    AstExpression* base = method_call -> base_opt;
expr.cpp:    TokenIndex identifier_token = method_call -> identifier_token;
expr.cpp:         k < type -> expanded_method_table -> symbol_pool.Length(); k++)
expr.cpp:            type -> expanded_method_table -> symbol_pool[k];
expr.cpp:        MethodSymbol* method = method_shadow -> method_symbol;
expr.cpp:        if (! method -> IsTyped())
expr.cpp:            method -> ProcessMethodSignature(this, identifier_token);
expr.cpp:        if ((method_call -> arguments -> NumArguments() ==
expr.cpp:             method -> NumFormalParameters()) &&
expr.cpp:             method_shadow -> NumConflicts() > 0))
expr.cpp:            for (i = 0; i < method_call -> arguments -> NumArguments(); i++)
expr.cpp:                AstExpression* expr = method_call -> arguments -> Argument(i);
expr.cpp:                if (! CanMethodInvocationConvert(method -> FormalParameter(i) -> Type(),
expr.cpp:                                                 expr -> Type()))
expr.cpp:            if (i == method_call -> arguments -> NumArguments())
expr.cpp:                int new_index = Spell::Index(name_symbol -> Name(),
expr.cpp:                                             method -> Name());
expr.cpp:    int length = name_symbol -> NameLength();
expr.cpp:    int num_args = method_call -> arguments -> NumArguments();
expr.cpp:    AstExpression* base = method_call -> base_opt;
expr.cpp:    TokenIndex id_token = method_call -> identifier_token;
expr.cpp:        name_symbol = lex_stream -> NameSymbol(id_token);
expr.cpp:    if (! type -> expanded_method_table)
expr.cpp:    for (MethodShadowSymbol* method_shadow = type -> expanded_method_table ->
expr.cpp:         method_shadow; method_shadow = method_shadow -> next_method)
expr.cpp:        MethodSymbol* method = method_shadow -> method_symbol;
expr.cpp:        if (! method -> IsTyped())
expr.cpp:            method -> ProcessMethodSignature(this, id_token);
expr.cpp:        if ((method_call -> arguments -> NumArguments() ==
expr.cpp:             method -> NumFormalParameters()) &&
expr.cpp:             method_shadow -> NumConflicts() > 0))
expr.cpp:            for (i = 0; i < method_call -> arguments -> NumArguments(); i++)
expr.cpp:                AstExpression* expr = method_call -> arguments -> Argument(i);
expr.cpp:                if (! CanMethodInvocationConvert(method -> FormalParameter(i) -> Type(),
expr.cpp:                                                 expr -> Type()))
expr.cpp:            if (i == method_call -> arguments -> NumArguments())
expr.cpp:                       method_call, name_symbol -> Name(),
expr.cpp:                       method_set[0] -> method_symbol -> Header(),
expr.cpp:                       method_set[0] -> method_symbol -> containing_type -> ContainingPackageName(),
expr.cpp:                       method_set[0] -> method_symbol -> containing_type -> ExternalName(),
expr.cpp:                       method_set[1] -> method_symbol -> Header(),
expr.cpp:                       method_set[1] -> method_symbol -> containing_type -> ContainingPackageName(),
expr.cpp:                       method_set[1] -> method_symbol -> containing_type -> ExternalName());
expr.cpp:    MethodSymbol* method = method_set[0] -> method_symbol;
expr.cpp:    if (method -> ACC_SYNTHETIC())
expr.cpp:                       method_call, method -> Header(),
expr.cpp:                       method -> containing_type -> ContainingPackageName(),
expr.cpp:                       method -> containing_type -> ExternalName());
expr.cpp:    method -> ProcessMethodThrows(this, id_token);
expr.cpp:    if (control.option.deprecation && method -> IsDeprecated() &&
expr.cpp:                       method -> Header(),
expr.cpp:                       method -> containing_type -> ContainingPackageName(),
expr.cpp:                       method -> containing_type -> ExternalName());
expr.cpp:    assert(! method_call -> base_opt);
expr.cpp:    TokenIndex id_token = method_call -> identifier_token;
expr.cpp:    NameSymbol* name_symbol = lex_stream -> NameSymbol(id_token);
expr.cpp:    for (SemanticEnvironment* env = envstack; env; env = env -> previous)
expr.cpp:        TypeSymbol* type = env -> Type();
expr.cpp:        if (! type -> expanded_method_table)
expr.cpp:        MethodShadowSymbol* method_shadow = type -> expanded_method_table ->
expr.cpp:                  method_shadow = method_shadow -> next_method)
expr.cpp:                MethodSymbol* method = method_shadow -> method_symbol;
expr.cpp:                if (! method -> IsTyped())
expr.cpp:                    method -> ProcessMethodSignature(this, id_token);
expr.cpp:                // Since type -> IsOwner(this_type()), i.e., type encloses
expr.cpp:                if (method_call -> arguments -> NumArguments() ==
expr.cpp:                    method -> NumFormalParameters())
expr.cpp:                    for (i = 0; i < method_call -> arguments -> NumArguments(); i++)
expr.cpp:                        AstExpression* expr = method_call -> arguments -> Argument(i);
expr.cpp:                        if (! CanMethodInvocationConvert(method -> FormalParameter(i) -> Type(),
expr.cpp:                                                         expr -> Type()))
expr.cpp:                    if (i == method_call -> arguments -> NumArguments())
expr.cpp:    MethodSymbol* method_symbol =  methods_found[0] -> method_symbol;
expr.cpp:                       method_call, method_symbol -> Name(),
expr.cpp:                       methods_found[0] -> method_symbol -> Header(),
expr.cpp:                       method_symbol -> containing_type -> ContainingPackageName(),
expr.cpp:                       method_symbol -> containing_type -> ExternalName(),
expr.cpp:                       methods_found[i] -> method_symbol -> Header(),
expr.cpp:                       methods_found[i] -> method_symbol -> containing_type -> ContainingPackageName(),
expr.cpp:                       methods_found[i] -> method_symbol -> containing_type -> ExternalName());
expr.cpp:    if (method_symbol -> containing_type != where_found -> Type())
expr.cpp:        if (method_symbol -> ACC_SYNTHETIC())
expr.cpp:                           method_call, method_symbol -> Header(),
expr.cpp:                           method_symbol -> containing_type -> ContainingPackageName(),
expr.cpp:                           method_symbol -> containing_type -> ExternalName());
expr.cpp:            SemanticEnvironment* previous_env = where_found -> previous;
expr.cpp:                where_found -> Type() != found_other -> Type())
expr.cpp:                    if (others[i] -> method_symbol != method_symbol &&
expr.cpp:                        (others[i] -> method_symbol -> containing_type ==
expr.cpp:                         found_other -> Type()))
expr.cpp:                                       method_symbol -> Name(),
expr.cpp:                                       method_symbol -> containing_type -> ContainingPackageName(),
expr.cpp:                                       method_symbol -> containing_type -> ExternalName(),
expr.cpp:                                       found_other -> Type() -> ContainingPackageName(),
expr.cpp:                                       found_other -> Type() -> ExternalName());
expr.cpp:    method_symbol -> ProcessMethodThrows(this,
expr.cpp:                                         method_call -> identifier_token);
expr.cpp:    if (control.option.deprecation && method_symbol -> IsDeprecated() &&
expr.cpp:                       method_call, method_symbol -> Header(),
expr.cpp:                       method_symbol -> containing_type -> ContainingPackageName(),
expr.cpp:                       method_symbol -> containing_type -> ExternalName());
expr.cpp:    AstFieldAccess* field_access = expr -> FieldAccessCast();
expr.cpp:    AstName* name = expr -> NameCast();
expr.cpp:    AstExpression* base = name ? name -> base_opt : field_access -> base;
expr.cpp:        name_symbol = lex_stream -> NameSymbol(expr -> RightToken());
expr.cpp:    if (! type -> expanded_field_table)
expr.cpp:        ComputeFieldsClosure(type, expr -> RightToken());
expr.cpp:        type -> expanded_field_table -> FindVariableShadowSymbol(name_symbol);
expr.cpp:        variable = variable_shadow -> variable_symbol;
expr.cpp:        if (! variable -> IsTyped())
expr.cpp:            variable -> ProcessVariableSignature(this, expr -> RightToken());
expr.cpp:        for (unsigned i = 0; i < variable_shadow -> NumConflicts(); i++)
expr.cpp:            variable = variable_shadow -> Conflict(i);
expr.cpp:            if (! variable -> IsTyped())
expr.cpp:                variable -> ProcessVariableSignature(this,
expr.cpp:                                                     expr -> RightToken());
expr.cpp:                       name_symbol -> Name(),
expr.cpp:                       variable_set[0] -> ContainingType() -> ContainingPackageName(),
expr.cpp:                       variable_set[0] -> ContainingType() -> ExternalName(),
expr.cpp:                       variable_set[1] -> ContainingType() -> ContainingPackageName(),
expr.cpp:                       variable_set[1] -> ContainingType() -> ExternalName());
expr.cpp:    if (variable -> ACC_SYNTHETIC())
expr.cpp:                       variable -> Name(),
expr.cpp:                       variable -> ContainingType() -> ContainingPackageName(),
expr.cpp:                       variable -> ContainingType() -> ExternalName());
expr.cpp:    if (control.option.deprecation && variable -> IsDeprecated() &&
expr.cpp:                       variable -> Name(),
expr.cpp:                       variable -> ContainingType() -> ContainingPackageName(),
expr.cpp:                       variable -> ContainingType() -> ExternalName());
expr.cpp:// AstFieldAccess or AstSimpleName. This checks in order: an accessible no-arg
expr.cpp:    TokenIndex id_token = access -> RightToken();
expr.cpp:    NameSymbol* name_symbol = lex_stream -> NameSymbol(id_token);
expr.cpp:    if (! type -> expanded_field_table)
expr.cpp:    if (! type -> expanded_method_table)
expr.cpp:    // Search for an accessible no-arg method of the same name.
expr.cpp:    for (method_shadow = type -> expanded_method_table ->
expr.cpp:         method_shadow; method_shadow = method_shadow -> next_method)
expr.cpp:        MethodSymbol* method = method_shadow -> method_symbol;
expr.cpp:        if (! method -> IsTyped())
expr.cpp:            method -> ProcessMethodSignature(this, id_token);
expr.cpp:        if (method -> NumFormalParameters() == 0 &&
expr.cpp:                           id_token, name_symbol -> Name(),
expr.cpp:                           method -> containing_type -> ContainingPackageName(),
expr.cpp:                           method -> containing_type -> ExternalName());
expr.cpp:         super_type; super_type = super_type -> super)
expr.cpp:        variable_shadow = super_type -> expanded_field_table ->
expr.cpp:            VariableSymbol* variable = variable_shadow -> variable_symbol;
expr.cpp:            TypeSymbol* containing_type = variable -> owner -> TypeCast();
expr.cpp:            if (variable -> ACC_PROTECTED() &&
expr.cpp:                ! variable -> ACC_STATIC() &&
expr.cpp:                ThisType() -> HasProtectedAccessTo(containing_type))
expr.cpp:                               id_token, name_symbol -> Name(),
expr.cpp:                               containing_type -> ContainingPackageName(),
expr.cpp:                               containing_type -> ExternalName(),
expr.cpp:                               ThisType() -> ContainingPackageName(),
expr.cpp:                               ThisType() -> ExternalName());
expr.cpp:                               id_token, name_symbol -> Name(),
expr.cpp:                               containing_type -> ContainingPackageName(),
expr.cpp:                               containing_type -> ExternalName(),
expr.cpp:                               variable -> AccessString());
expr.cpp:    AstName* ast_name = access -> NameCast();
expr.cpp:    TypeSymbol* inaccessible_type = (! ast_name || ast_name -> base_opt)
expr.cpp:                       id_token, name_symbol -> Name(),
expr.cpp:                       type -> ContainingPackageName(),
expr.cpp:                       type -> ExternalName(),
expr.cpp:                       variable -> Name());
expr.cpp:                       id_token, name_symbol -> Name());
expr.cpp:    else if (access -> symbol && access -> symbol -> PackageCast())
expr.cpp:                       access, name_symbol -> Name());
expr.cpp:                       id_token, name_symbol -> Name(),
expr.cpp:                       type -> ContainingPackageName(),
expr.cpp:                       type -> ExternalName());
expr.cpp:    for (SemanticEnvironment* env = envstack; env; env = env -> previous)
expr.cpp:            env -> symbol_table.FindVariableSymbol(name_symbol);
expr.cpp:        TypeSymbol* type = env -> Type();
expr.cpp:        if (! type -> expanded_field_table)
expr.cpp:        VariableShadowSymbol* variable_shadow = type ->
expr.cpp:            expanded_field_table -> FindVariableShadowSymbol(name_symbol);
expr.cpp:            // Since type -> IsOwner(this_type()), i.e., type encloses
expr.cpp:            variables_found.Next() = variable_shadow -> variable_symbol;
expr.cpp:            for (unsigned i = 0; i < variable_shadow -> NumConflicts(); i++)
expr.cpp:                variables_found.Next() = variable_shadow -> Conflict(i);
expr.cpp:    NameSymbol* name_symbol = lex_stream -> NameSymbol(identifier_token);
expr.cpp:        if (variable_symbol -> IsLocal()) // a local variable
expr.cpp:                TypeSymbol* type = envstack -> Type();
expr.cpp:                if (! variable_symbol -> ACC_FINAL())
expr.cpp:                        variable_symbol -> owner -> MethodCast();
expr.cpp:                    // if (method -> Identity() != control.init_symbol &&
expr.cpp:                    //     method -> Identity() != control.block_init_symbol &&
expr.cpp:                    //     method -> Identity() != control.clinit_symbol)
expr.cpp:                                   type -> ContainingPackageName(),
expr.cpp:                                   type -> ExternalName(),
expr.cpp:                                   lex_stream -> NameString(identifier_token),
expr.cpp:                                   method -> ExternalName());
expr.cpp:                else if (! variable_symbol -> initial_value)
expr.cpp:                                                        envstack -> Type());
expr.cpp:                        variable_symbol -> ContainingType();
expr.cpp:                    where_found = shadow_owner -> semantic_environment;
expr.cpp:        else if (variable_symbol -> owner != where_found -> Type())
expr.cpp:            TypeSymbol* type = (TypeSymbol*) variable_symbol -> owner;
expr.cpp:            if (variable_symbol -> ACC_SYNTHETIC())
expr.cpp:                               variable_symbol -> Name(),
expr.cpp:                               type -> ContainingPackageName(),
expr.cpp:                               type -> ExternalName());
expr.cpp:                SemanticEnvironment* previous_env = where_found -> previous;
expr.cpp:                    where_found -> Type() != found_other -> Type())
expr.cpp:                                others[i] -> owner -> MethodCast();
expr.cpp:                                               lex_stream -> NameString(identifier_token),
expr.cpp:                                               type -> ContainingPackageName(),
expr.cpp:                                               type -> ExternalName(),
expr.cpp:                                               method -> Name());
expr.cpp:                            else if (others[i] -> owner == found_other -> Type())
expr.cpp:                                               lex_stream -> NameString(identifier_token),
expr.cpp:                                               type -> ContainingPackageName(),
expr.cpp:                                               type -> ExternalName(),
expr.cpp:                                               found_other -> Type() -> ContainingPackageName(),
expr.cpp:                                               found_other -> Type() -> ExternalName());
expr.cpp:                       variable_symbol -> Name(),
expr.cpp:                       variable_symbol -> ContainingType() -> ContainingPackageName(),
expr.cpp:                       variable_symbol -> ContainingType() -> ExternalName(),
expr.cpp:                       variables_found[i] -> ContainingType() -> ContainingPackageName(),
expr.cpp:                       variables_found[i] -> ContainingType() -> ExternalName());
expr.cpp:        if (control.option.deprecation && variable_symbol -> IsDeprecated() &&
expr.cpp:                           variable_symbol -> Name(),
expr.cpp:                           variable_symbol -> ContainingType() -> ContainingPackageName(),
expr.cpp:                           variable_symbol -> ContainingType() -> ExternalName());
expr.cpp:        if (! variable_symbol -> IsTyped())
expr.cpp:            variable_symbol -> ProcessVariableSignature(this, identifier_token);
expr.cpp:    while (local -> accessed_local)
expr.cpp:        local = local -> accessed_local;
expr.cpp:    assert(local -> IsLocal());
expr.cpp:    TypeSymbol* containing_type = local -> ContainingType();
expr.cpp:    while (type && type -> ContainingType() != containing_type)
expr.cpp:        if (! type -> EnclosingType())
expr.cpp:            assert(type -> Anonymous());
expr.cpp:        type = type -> ContainingType();
expr.cpp:    assert(type && type -> IsLocal());
expr.cpp:    return type -> FindOrInsertLocalShadow(local);
expr.cpp:    TypeSymbol* base_type = base -> Type();
expr.cpp:           base_type -> HasEnclosingInstance(environment_type, exact));
expr.cpp:    VariableSymbol* this0 = base_type -> EnclosingInstance();
expr.cpp:        // available through additional constructor parameters) - JLS 8.8.5.1
expr.cpp:        assert(base_type -> Anonymous() && base_type -> IsLocal());
expr.cpp:    TokenIndex tok = base -> RightToken();
expr.cpp:        compilation_unit -> ast_pool -> GenFieldAccess();
expr.cpp:    field_access -> base = base;
expr.cpp:    field_access -> identifier_token = tok;
expr.cpp:    field_access -> symbol = this0;
expr.cpp:    if (exact ? (this0 -> Type() == environment_type)
expr.cpp:        : (this0 -> Type() -> IsSubclass(environment_type)))
expr.cpp:    AstName* variable = source -> NameCast();
expr.cpp:    AstMethodInvocation* method = source -> MethodInvocationCast();
expr.cpp:    AstSuperCall* super_call = source -> SuperCallCast();
expr.cpp:    AstThisExpression* this_expr = source -> ThisExpressionCast();
expr.cpp:    AstSuperExpression* super_expr = source -> SuperExpressionCast();
expr.cpp:        source -> ClassCreationExpressionCast();
expr.cpp:        assert(! variable -> base_opt);
expr.cpp:        left_tok = right_tok = variable -> identifier_token;
expr.cpp:        if (this_type -> IsSubclass(environment_type))
expr.cpp:        assert(! method -> base_opt);
expr.cpp:        left_tok = right_tok = method -> identifier_token;
expr.cpp:        if (this_type -> IsSubclass(environment_type))
expr.cpp:        left_tok = right_tok = class_creation -> new_token;
expr.cpp:        left_tok = right_tok = super_call -> super_token;
expr.cpp:        assert(this_expr -> base_opt);
expr.cpp:        left_tok = this_expr -> LeftToken();
expr.cpp:        right_tok = this_expr -> this_token;
expr.cpp:        assert(super_expr -> base_opt);
expr.cpp:        left_tok = super_expr -> LeftToken();
expr.cpp:        right_tok = super_expr -> super_token;
expr.cpp:    if (! this_type -> HasEnclosingInstance(environment_type, exact))
expr.cpp:                        this_type -> IsSubclass(environment_type)
expr.cpp:                       environment_type -> ContainingPackageName(),
expr.cpp:                       environment_type -> ExternalName());
expr.cpp:        resolution = compilation_unit -> ast_pool -> GenName(left_tok);
expr.cpp:        resolution -> symbol = control.no_type;
expr.cpp:            resolution = compilation_unit -> ast_pool -> GenName(left_tok);
expr.cpp:            resolution -> symbol = variable;
expr.cpp:                compilation_unit -> ast_pool -> GenThisExpression(left_tok);
expr.cpp:            resolution -> symbol = this_type;
expr.cpp:        TypeSymbol* resolved_type = resolution -> Type();
expr.cpp:            (! resolved_type -> IsSubclass(environment_type) || exact))
expr.cpp:                               environment_type -> ContainingPackageName(),
expr.cpp:                               environment_type -> ExternalName());
expr.cpp:                resolution -> symbol = control.no_type;
expr.cpp:        environment_type = environment_type -> super;
expr.cpp:    assert(! name -> base_opt);
expr.cpp:    VariableSymbol* variable = (VariableSymbol*) name -> symbol;
expr.cpp:    assert(variable -> owner -> TypeCast());
expr.cpp:    if (variable -> ACC_STATIC())
expr.cpp:        access_expression = compilation_unit -> ast_pool ->
expr.cpp:            GenName(name -> identifier_token);
expr.cpp:        access_expression -> symbol = environment_type;
expr.cpp:        AstThisExpression* this_expr = compilation_unit -> ast_pool ->
expr.cpp:            GenThisExpression(name -> identifier_token);
expr.cpp:        this_expr -> resolution_opt =
expr.cpp:        this_expr -> symbol = this_expr -> resolution_opt -> symbol;
expr.cpp:    if (access_expression -> symbol != control.no_type)
expr.cpp:        TypeSymbol* containing_type = variable -> ContainingType();
expr.cpp:        if (variable -> ACC_PRIVATE() ||
expr.cpp:            (variable -> ACC_PROTECTED() &&
expr.cpp:            assert((variable -> ACC_PRIVATE() &&
expr.cpp:                   (variable -> ACC_PROTECTED() &&
expr.cpp:                    environment_type -> IsSubclass(containing_type)));
expr.cpp:            TokenIndex loc = name -> identifier_token;
expr.cpp:                compilation_unit -> ast_pool -> GenArguments(loc, loc);
expr.cpp:            if (! variable -> ACC_STATIC())
expr.cpp:                args -> AllocateArguments(1);
expr.cpp:                args -> AddArgument(access_expression);
expr.cpp:                compilation_unit -> ast_pool -> GenMethodInvocation(loc);
expr.cpp:            accessor -> base_opt = access_expression;
expr.cpp:            accessor -> arguments = args;
expr.cpp:            accessor -> symbol =
expr.cpp:                environment_type -> GetReadAccessMethod(variable);
expr.cpp:            name -> resolution_opt = accessor;
expr.cpp:                compilation_unit -> ast_pool -> GenFieldAccess();
expr.cpp:            field_access -> base = access_expression;
expr.cpp:            field_access -> identifier_token = name -> identifier_token;
expr.cpp:            field_access -> symbol = variable;
expr.cpp:            name -> resolution_opt = field_access;
expr.cpp:    assert(environment_type -> IsOwner(ThisType()));
expr.cpp:    assert(! method_call -> base_opt);
expr.cpp:    MethodSymbol* method = (MethodSymbol*) method_call -> symbol;
expr.cpp:    if (method -> ACC_STATIC())
expr.cpp:        access_expression = compilation_unit -> ast_pool ->
expr.cpp:            GenName(method_call -> identifier_token);
expr.cpp:        access_expression -> symbol = environment_type;
expr.cpp:        AstThisExpression* this_expr = compilation_unit -> ast_pool ->
expr.cpp:            GenThisExpression(method_call -> identifier_token);
expr.cpp:        this_expr -> resolution_opt =
expr.cpp:        this_expr -> symbol = this_expr -> resolution_opt -> symbol;
expr.cpp:    if (access_expression -> symbol != control.no_type)
expr.cpp:        method_call -> base_opt = access_expression;
expr.cpp:        TypeSymbol* containing_type = method -> containing_type;
expr.cpp:        if (method -> ACC_PRIVATE() ||
expr.cpp:            (method -> ACC_PROTECTED() &&
expr.cpp:            assert((method -> ACC_PRIVATE() &&
expr.cpp:                   (method -> ACC_PROTECTED() &&
expr.cpp:                    environment_type -> IsSubclass(containing_type)));
expr.cpp:            AstArguments* args = compilation_unit -> ast_pool ->
expr.cpp:                GenArguments(method_call -> arguments -> left_parenthesis_token,
expr.cpp:                             method_call -> arguments -> right_parenthesis_token);
expr.cpp:            unsigned num_args = method_call -> arguments -> NumArguments();
expr.cpp:            if (! method -> ACC_STATIC())
expr.cpp:                args -> AllocateArguments(num_args + 1);
expr.cpp:                args -> AddArgument(access_expression);
expr.cpp:            else args -> AllocateArguments(num_args);
expr.cpp:                args -> AddArgument(method_call -> arguments -> Argument(i));
expr.cpp:            AstMethodInvocation* accessor = compilation_unit -> ast_pool ->
expr.cpp:                GenMethodInvocation(method_call -> identifier_token);
expr.cpp:            accessor -> base_opt = access_expression;
expr.cpp:            accessor -> arguments = args;
expr.cpp:            accessor -> symbol =
expr.cpp:                environment_type -> GetReadAccessMethod(method);
expr.cpp:            method_call -> symbol = method;
expr.cpp:            method_call -> resolution_opt = accessor;
expr.cpp:    VariableSymbol* variable_symbol = name -> symbol -> VariableCast();
expr.cpp:    assert(variable_symbol && ! name -> base_opt);
expr.cpp:        if (! (variable_symbol -> IsLocal() ||
expr.cpp:               variable_symbol -> ACC_STATIC()))
expr.cpp:                           name -> identifier_token,
expr.cpp:                           lex_stream -> NameString(name -> identifier_token));
expr.cpp:        else if (variable_symbol -> owner -> TypeCast() &&
expr.cpp:                 ! variable_symbol -> IsDeclarationComplete() &&
expr.cpp:                           name -> identifier_token,
expr.cpp:                           lex_stream -> NameString(name -> identifier_token));
expr.cpp:    else if (! variable_symbol -> ACC_STATIC()) // an instance variable?
expr.cpp:        TypeSymbol* containing_type = variable_symbol -> owner -> TypeCast();
expr.cpp:        if (containing_type && ! variable_symbol -> accessed_local)
expr.cpp:                ! variable_symbol -> IsDeclarationComplete() &&
expr.cpp:                               name -> identifier_token,
expr.cpp:                               lex_stream -> NameString(name -> identifier_token));
expr.cpp:                               name -> identifier_token,
expr.cpp:                               lex_stream -> NameString(name -> identifier_token),
expr.cpp:                               containing_type -> Name());
expr.cpp:    if (expr -> symbol == control.String() && ! expr -> IsConstant())
expr.cpp:    TypeSymbol* type = name -> Type();
expr.cpp:    if (! type || name -> symbol -> TypeCast())
expr.cpp:        name -> symbol = control.no_type;
expr.cpp:    if (type -> IsArray())
expr.cpp:        type = type -> base_type;
expr.cpp:    // non-private types in the current package, are accessible. For a member
expr.cpp:    if (type -> ACC_PUBLIC() ||
expr.cpp:        (type -> ContainingPackage() == this_package &&
expr.cpp:         ! type -> ACC_PRIVATE()))
expr.cpp:        assert(this_type -> ContainingPackage() == this_package);
expr.cpp:        if (this_type -> outermost_type == type -> outermost_type ||
expr.cpp:            (type -> ACC_PROTECTED() &&
expr.cpp:             this_type -> HasProtectedAccessTo(type)))
expr.cpp:    TypeSymbol* containing_type = constructor -> containing_type;
expr.cpp:    if (this_type -> outermost_type != containing_type -> outermost_type &&
expr.cpp:        constructor -> ACC_PRIVATE())
expr.cpp:    if (containing_type -> ContainingPackage() != this_package &&
expr.cpp:        ! constructor -> ACC_PUBLIC())
expr.cpp:        return constructor -> ACC_PROTECTED() && explicit_ctor;
expr.cpp:    VariableSymbol* variable_symbol = symbol -> VariableCast();
expr.cpp:    MethodSymbol* method_symbol = symbol -> MethodCast();
expr.cpp:                                   ? variable_symbol -> ContainingType()
expr.cpp:                                   : method_symbol -> containing_type);
expr.cpp:    if (this_type -> outermost_type != containing_type -> outermost_type)
expr.cpp:        if (flags -> ACC_PRIVATE())
expr.cpp:        else if (flags -> ACC_PROTECTED())
expr.cpp:            if (base && base -> Type() -> ACC_INTERFACE())
expr.cpp:            if (containing_type -> ContainingPackage() == this_package ||
expr.cpp:                (base && base -> SuperExpressionCast()))
expr.cpp:            if (this_type -> HasProtectedAccessTo(containing_type))
expr.cpp:                if (flags -> ACC_STATIC())
expr.cpp:                         this_type -> semantic_environment;
expr.cpp:                     env; env = env -> previous)
expr.cpp:                    if (base_type -> IsSubclass(env -> Type()))
expr.cpp:        else if (! flags -> ACC_PUBLIC() &&
expr.cpp:                 containing_type -> ContainingPackage() != this_package)
expr.cpp:    return ThisType() -> IsSubclass(containing_type) ||
expr.cpp:        this_package == containing_type -> ContainingPackage();
expr.cpp:    AstFieldAccess* field_access = expr -> FieldAccessCast();
expr.cpp:    AstName* name = expr -> NameCast();
expr.cpp:    AstExpression* base = name ? name -> base_opt : field_access -> base;
expr.cpp:    TokenIndex id_token = expr -> RightToken();
expr.cpp:    bool base_is_type = base -> symbol -> TypeCast() && base -> NameCast();
expr.cpp:    if (type -> Bad())
expr.cpp:        expr -> symbol = control.no_type;
expr.cpp:    else if (type == control.null_type || type -> Primitive())
expr.cpp:                       type -> Name());
expr.cpp:        expr -> symbol = control.no_type;
expr.cpp:            expr -> symbol = control.no_type;
expr.cpp:            assert(variable -> IsTyped());
expr.cpp:            if (base_is_type && ! variable -> ACC_STATIC())
expr.cpp:                               id_token, lex_stream -> NameString(id_token));
expr.cpp:                expr -> symbol = control.no_type;
expr.cpp:            if (variable -> ACC_STATIC() && ! base_is_type)
expr.cpp:                               id_token, lex_stream -> NameString(id_token));
expr.cpp:            // expression here - JLS 15.28. If it is of any other form, we
expr.cpp:            // bytecode, but do not treat the expression as a constant - JLS2
expr.cpp:            if (variable -> ACC_FINAL())
expr.cpp:                if (! variable -> IsInitialized())
expr.cpp:                    assert(variable -> IsInitialized());
expr.cpp:                    expr -> value = variable -> initial_value;
expr.cpp:            TypeSymbol* containing_type = variable -> ContainingType();
expr.cpp:            if (! variable -> ACC_STATIC() && base -> SuperExpressionCast())
expr.cpp:                if (super_expr -> base_opt)
expr.cpp:                    target_type = super_expr -> base_opt -> symbol;
expr.cpp:                (variable -> ACC_PRIVATE() ||
expr.cpp:                 (variable -> ACC_PROTECTED() &&
expr.cpp:                if (expr -> IsConstant())
expr.cpp:                    expr -> symbol = variable;
expr.cpp:                    if (variable -> ACC_PROTECTED())
expr.cpp:                                 this_type -> semantic_environment;
expr.cpp:                             env; env = env -> previous)
expr.cpp:                            if (env -> Type() -> IsSubclass(target_type))
expr.cpp:                                environment_type = env -> Type();
expr.cpp:                        compilation_unit -> ast_pool -> GenArguments(id_token,
expr.cpp:                    if (! variable -> ACC_STATIC())
expr.cpp:                        args -> AllocateArguments(1);
expr.cpp:                        args -> AddArgument(base);
expr.cpp:                    AstMethodInvocation* accessor = compilation_unit ->
expr.cpp:                        ast_pool -> GenMethodInvocation(id_token);
expr.cpp:                    accessor -> base_opt = base;
expr.cpp:                    accessor -> arguments = args;
expr.cpp:                    accessor -> symbol = environment_type ->
expr.cpp:                        GetReadAccessMethod(variable, base -> Type());
expr.cpp:                        name -> resolution_opt = accessor;
expr.cpp:                        field_access -> resolution_opt = accessor;
expr.cpp:                    expr -> symbol = accessor -> symbol;
expr.cpp:                expr -> symbol = variable;
expr.cpp:                    expr -> symbol = inner_type;
expr.cpp:                                   lex_stream -> NameString(id_token));
expr.cpp:                    expr -> symbol = control.no_type;
expr.cpp:                expr -> symbol = control.no_type;
expr.cpp:    if (! name -> base_opt)
expr.cpp:            FindVariableInEnvironment(where_found, name -> identifier_token);
expr.cpp:            assert(variable_symbol -> IsTyped());
expr.cpp:            if (variable_symbol -> ACC_FINAL() &&
expr.cpp:                ! variable_symbol -> IsInitialized())
expr.cpp:            name -> value = variable_symbol -> initial_value;
expr.cpp:            name -> symbol = variable_symbol;
expr.cpp:                variable_symbol -> owner -> TypeCast())
expr.cpp:                CreateAccessToScopedVariable(name, where_found -> Type());
expr.cpp:        // single-type-import declaration (7.5.1) or by a class or interface
expr.cpp:        // type-import-on-demand declaration (7.5.2) of the compilation unit
expr.cpp:        // type-import-on-demand declaration of the compilation unit
expr.cpp:        // containing the Identifier, then a compile-time error results.
expr.cpp:        else if ((type = FindType(name -> identifier_token)))
expr.cpp:            name -> symbol = type;
expr.cpp:            if (control.option.deprecation && type -> IsDeprecated() &&
expr.cpp:                               name -> identifier_token,
expr.cpp:                               type -> ContainingPackageName(),
expr.cpp:                               type -> ExternalName());
expr.cpp:                lex_stream -> NameSymbol(name -> identifier_token);
expr.cpp:            if (package -> directory.Length())
expr.cpp:                name -> symbol = package;
expr.cpp:                name -> symbol = control.no_type;
expr.cpp:        AstName* base = name -> base_opt;
expr.cpp:        TypeSymbol* type = base -> Type();
expr.cpp:        assert(type || base -> symbol -> PackageCast());
expr.cpp:            name -> symbol = control.no_type;
expr.cpp:        PackageSymbol* package = base -> symbol -> PackageCast();
expr.cpp:                lex_stream -> NameSymbol(name -> identifier_token);
expr.cpp:            type = package -> FindTypeSymbol(name_symbol);
expr.cpp:                if (type -> SourcePending())
expr.cpp:                    control.ProcessHeaders(type -> file_symbol);
expr.cpp:                name -> symbol = type;
expr.cpp:                                    name -> identifier_token);
expr.cpp:                    name -> symbol = type;
expr.cpp:                        package -> FindPackageSymbol(name_symbol);
expr.cpp:                            package -> InsertPackageSymbol(name_symbol);
expr.cpp:                    if (subpackage -> directory.Length())
expr.cpp:                        name -> symbol = subpackage;
expr.cpp:                                       name, name_symbol -> Name());
expr.cpp:                        name -> symbol = control.no_type;
expr.cpp:            AddDependence(this_type, type, name -> IsConstant());
expr.cpp:    assert(! field_access -> base -> NameCast());
expr.cpp:    ProcessExpressionOrStringConstant(field_access -> base);
expr.cpp:    TypeSymbol* type = field_access -> base -> Type();
expr.cpp:        field_access -> symbol = control.no_type;
expr.cpp:    if (field_access -> symbol != control.no_type)
expr.cpp:        PackageSymbol* package = field_access -> symbol -> PackageCast();
expr.cpp:                           field_access, package -> PackageName());
expr.cpp:            field_access -> symbol = control.no_type;
expr.cpp:        else if (field_access -> symbol -> TypeCast())
expr.cpp:            type = (TypeSymbol*) field_access -> symbol;
expr.cpp:                           field_access, type -> Name());
expr.cpp:            field_access -> symbol = control.no_type;
expr.cpp:            assert(! field_access -> symbol -> VariableCast() ||
expr.cpp:                   field_access -> symbol -> VariableCast() -> IsTyped());
expr.cpp:        lex_stream -> LiteralSymbol(char_literal -> character_literal_token);
expr.cpp:    if (! literal -> value)
expr.cpp:    if (literal -> value == control.BadValue())
expr.cpp:        char_literal -> symbol = control.no_type;
expr.cpp:        char_literal -> value = literal -> value;
expr.cpp:        char_literal -> symbol = control.char_type;
expr.cpp:        lex_stream -> LiteralSymbol(int_literal -> integer_literal_token);
expr.cpp:    if (! literal -> value)
expr.cpp:    if (literal -> value == control.BadValue())
expr.cpp:        int_literal -> symbol = control.no_type;
expr.cpp:        int_literal -> value = literal -> value;
expr.cpp:        int_literal -> symbol = control.int_type;
expr.cpp:        lex_stream -> LiteralSymbol(long_literal -> long_literal_token);
expr.cpp:    if (! literal -> value)
expr.cpp:    if (literal -> value == control.BadValue())
expr.cpp:        long_literal -> symbol = control.no_type;
expr.cpp:        long_literal -> value = literal -> value;
expr.cpp:        long_literal -> symbol = control.long_type;
expr.cpp:        lex_stream -> LiteralSymbol(float_literal -> float_literal_token);
expr.cpp:    if (! literal -> value)
expr.cpp:        (literal -> Name()[1] == U_x || literal -> Name()[1] == U_X))
expr.cpp:    if (literal -> value == control.BadValue())
expr.cpp:        float_literal -> symbol = control.no_type;
expr.cpp:        float_literal -> value = literal -> value;
expr.cpp:        float_literal -> symbol = control.float_type;
expr.cpp:        lex_stream -> LiteralSymbol(double_literal -> double_literal_token);
expr.cpp:    if (! literal -> value)
expr.cpp:        (literal -> Name()[1] == U_x || literal -> Name()[1] == U_X))
expr.cpp:    if (literal -> value == control.BadValue())
expr.cpp:        double_literal -> symbol = control.no_type;
expr.cpp:        double_literal -> value = literal -> value;
expr.cpp:        double_literal -> symbol = control.double_type;
expr.cpp:    true_literal -> value = control.int_pool.FindOrInsert((int) 1);
expr.cpp:    true_literal -> symbol = control.boolean_type;
expr.cpp:    false_literal -> value = control.int_pool.FindOrInsert((int) 0);
expr.cpp:    false_literal -> symbol = control.boolean_type;
expr.cpp:        lex_stream -> LiteralSymbol(string_literal -> string_literal_token);
expr.cpp:    if (! literal -> value)
expr.cpp:    if (literal -> value == control.BadValue())
expr.cpp:        string_literal -> symbol = control.no_type;
expr.cpp:        string_literal -> value = literal -> value;
expr.cpp:        string_literal -> symbol = control.String();
expr.cpp:    ProcessExpression(array_access -> base);
expr.cpp:    ProcessExpression(array_access -> expression);
expr.cpp:    array_access -> expression =
expr.cpp:        PromoteUnaryNumericExpression(array_access -> expression);
expr.cpp:    if (array_access -> expression -> Type() != control.int_type)
expr.cpp:        TypeSymbol* type = array_access -> expression -> Type();
expr.cpp:        if (array_access -> expression -> symbol != control.no_type)
expr.cpp:                           array_access -> expression,
expr.cpp:                           type -> ContainingPackageName(),
expr.cpp:                           type -> ExternalName());
expr.cpp:        array_access -> symbol = control.no_type;
expr.cpp:    TypeSymbol* array_type = array_access -> base -> Type();
expr.cpp:    if (array_type -> IsArray())
expr.cpp:        if (! array_access -> symbol)
expr.cpp:            array_access -> symbol = array_type -> ArraySubtype();
expr.cpp:                           array_access -> base,
expr.cpp:                           array_type -> ContainingPackageName(),
expr.cpp:                           array_type -> ExternalName());
expr.cpp:        array_access -> symbol = control.no_type;
expr.cpp:    AstExpression* base = method_call -> base_opt;
expr.cpp:    TokenIndex id_token = method_call -> identifier_token;
expr.cpp:    bool base_is_type = base -> symbol -> TypeCast() && base -> NameCast();
expr.cpp:    if (type -> Bad())
expr.cpp:        method_call -> symbol = control.no_type;
expr.cpp:    else if (type == control.null_type || type -> Primitive())
expr.cpp:                       type -> Name());
expr.cpp:        method_call -> symbol = control.no_type;
expr.cpp:            method_call -> symbol = control.no_type;
expr.cpp:        MethodSymbol* method = (shadow ? shadow -> method_symbol
expr.cpp:            assert(method -> IsTyped());
expr.cpp:            if (base_is_type && ! method -> ACC_STATIC())
expr.cpp:                               method_call -> LeftToken(), id_token,
expr.cpp:                               lex_stream -> NameString(id_token));
expr.cpp:                method_call -> symbol = control.no_type;
expr.cpp:            if (method -> ACC_STATIC() && ! base_is_type)
expr.cpp:                               method_call -> LeftToken(), id_token,
expr.cpp:                               lex_stream -> NameString(id_token));
expr.cpp:            MethodInvocationConversion(method_call -> arguments, method);
expr.cpp:            TypeSymbol* containing_type = method -> containing_type;
expr.cpp:            if (! method -> ACC_STATIC() && base -> SuperExpressionCast())
expr.cpp:                if (super_expr -> base_opt)
expr.cpp:                    target_type = super_expr -> base_opt -> symbol;
expr.cpp:                (method -> ACC_PRIVATE() ||
expr.cpp:                 (method -> ACC_PROTECTED() &&
expr.cpp:                if (! method -> ACC_PRIVATE())
expr.cpp:                    for (SemanticEnvironment* env = this_type -> semantic_environment;
expr.cpp:                         env; env = env -> previous)
expr.cpp:                        if (env -> Type() -> IsSubclass(target_type))
expr.cpp:                            environment_type = env -> Type();
expr.cpp:                AstArguments* args = compilation_unit -> ast_pool ->
expr.cpp:                    GenArguments(method_call -> arguments -> left_parenthesis_token,
expr.cpp:                                 method_call -> arguments -> right_parenthesis_token);
expr.cpp:                unsigned num_args = method_call -> arguments -> NumArguments();
expr.cpp:                if (! method -> ACC_STATIC())
expr.cpp:                    args -> AllocateArguments(num_args + 1);
expr.cpp:                    args -> AddArgument(base);
expr.cpp:                else args -> AllocateArguments(num_args);
expr.cpp:                    args -> AddArgument(method_call -> arguments -> Argument(i));
expr.cpp:                AstMethodInvocation* accessor = compilation_unit ->
expr.cpp:                    ast_pool -> GenMethodInvocation(id_token);
expr.cpp:                accessor -> base_opt = base;
expr.cpp:                accessor -> arguments = args;
expr.cpp:                accessor -> symbol = environment_type ->
expr.cpp:                    GetReadAccessMethod(method, base -> Type());
expr.cpp:                method_call -> symbol = method;
expr.cpp:                method_call -> resolution_opt = accessor;
expr.cpp:            else method_call -> symbol = method;
expr.cpp:            method_call -> symbol = control.no_type;
expr.cpp:    AstExpression* base = method_call -> base_opt;
expr.cpp:    TokenIndex id_token = method_call -> identifier_token;
expr.cpp:            method_call -> symbol = control.no_type;
expr.cpp:            base_type = where_found -> Type();
expr.cpp:            MethodSymbol* method = method_shadow -> method_symbol;
expr.cpp:            assert(method -> IsTyped());
expr.cpp:            if (! method -> ACC_STATIC())
expr.cpp:                                       method_call, method -> Header(),
expr.cpp:                                       method -> containing_type -> Name());
expr.cpp:                        method_call -> symbol = control.no_type;
expr.cpp:                                   lex_stream -> NameString(id_token));
expr.cpp:                    method_call -> symbol = control.no_type;
expr.cpp:            MethodInvocationConversion(method_call -> arguments, method);
expr.cpp:            method_call -> symbol = method;
expr.cpp:                CreateAccessToScopedMethod(method_call, where_found -> Type());
expr.cpp:        // If there are more names to the left, we short-circuit
expr.cpp:        if (base -> NameCast())
expr.cpp:        if (base -> symbol -> PackageCast())
expr.cpp:                           base -> symbol -> PackageCast() -> PackageName());
expr.cpp:            base -> symbol = control.no_type;
expr.cpp:        base_type = base -> Type();
expr.cpp:            method_call -> symbol = control.no_type;
expr.cpp:        if (base -> SuperExpressionCast())
expr.cpp:            MethodSymbol* method = method_call -> symbol -> MethodCast();
expr.cpp:            if (method && method -> ACC_ABSTRACT())
expr.cpp:                               lex_stream -> NameString(id_token));
expr.cpp:        MethodSymbol* method = (MethodSymbol*) method_call -> symbol;
expr.cpp:            assert(method_shadow -> NumConflicts() > 0);
expr.cpp:            method = method_shadow -> Conflict(0);
expr.cpp:            method_call -> symbol = method;
expr.cpp:        SymbolSet exceptions(method -> NumThrows());
expr.cpp:        for (i = method -> NumThrows(); --i >= 0; )
expr.cpp:            exceptions.AddElement(method -> Throws(i));
expr.cpp:        for (i = method_shadow -> NumConflicts(); --i >= 0; )
expr.cpp:            MethodSymbol* conflict = method_shadow -> Conflict(i);
expr.cpp:            conflict -> ProcessMethodThrows(this,
expr.cpp:                                            method_call -> identifier_token);
expr.cpp:            for (j = conflict -> NumThrows(); --j >= 0; )
expr.cpp:                TypeSymbol* candidate = conflict -> Throws(j);
expr.cpp:                    if (candidate -> IsSubclass(ex))
expr.cpp:            for (i = method_shadow -> NumConflicts(); --i >= 0; )
expr.cpp:                MethodSymbol* conflict = method_shadow -> Conflict(i);
expr.cpp:                for (j = conflict -> NumThrows(); --j >= 0; )
expr.cpp:                    TypeSymbol* candidate = conflict -> Throws(j);
expr.cpp:                    if (ex -> IsSubclass(candidate))
expr.cpp:                               method_call, method -> Header(),
expr.cpp:                               ex -> ContainingPackageName(),
expr.cpp:                               ex -> ExternalName(),
expr.cpp:            exception_set -> Union(exceptions);
expr.cpp:            exception_set -> AddElement(control.no_type);
expr.cpp:    for (unsigned i = 0; i < args -> NumArguments(); i++)
expr.cpp:        AstExpression* expr = args -> Argument(i);
expr.cpp:        if (expr -> symbol == control.no_type)
expr.cpp:        else if (expr -> Type() == control.void_type)
expr.cpp:                           expr -> Type() -> Name());
expr.cpp:    if (method_call -> type_arguments_opt)
expr.cpp:                       method_call -> type_arguments_opt);
expr.cpp:    bool bad_argument = ProcessArguments(method_call -> arguments);
expr.cpp:        method_call -> symbol = control.no_type;
expr.cpp:    assert(method_call -> symbol == control.no_type ||
expr.cpp:           ((MethodSymbol*) method_call -> symbol) -> IsTyped());
expr.cpp:    // Null is not a compile-time constant, so don't give it a value
expr.cpp:    null_literal -> symbol = control.null_type;
expr.cpp:    if (error && error -> InClone())
expr.cpp:        class_lit -> symbol = control.no_type;
expr.cpp:    ProcessType(class_lit -> type);
expr.cpp:    TypeSymbol* type = class_lit -> type -> symbol;
expr.cpp:    AddDependence(this_type, type -> BoxedType(control));
expr.cpp:        class_lit -> symbol = control.no_type;
expr.cpp:    else if (type -> Primitive())
expr.cpp:            class_lit -> symbol = control.Integer_TYPE_Field();
expr.cpp:            class_lit -> symbol = control.Double_TYPE_Field();
expr.cpp:            class_lit -> symbol = control.Character_TYPE_Field();
expr.cpp:            class_lit -> symbol = control.Long_TYPE_Field();
expr.cpp:            class_lit -> symbol = control.Float_TYPE_Field();
expr.cpp:            class_lit -> symbol = control.Byte_TYPE_Field();
expr.cpp:            class_lit -> symbol = control.Short_TYPE_Field();
expr.cpp:            class_lit -> symbol = control.Boolean_TYPE_Field();
expr.cpp:            class_lit -> symbol = control.Void_TYPE_Field();
expr.cpp:        VariableSymbol* var = this_type -> FindOrInsertClassLiteral(type);
expr.cpp:        AstName* name = compilation_unit -> ast_pool ->
expr.cpp:            GenName(class_lit -> class_token);
expr.cpp:        name -> symbol = var;
expr.cpp:        class_lit -> symbol = var;
expr.cpp:        class_lit -> resolution_opt = name;
expr.cpp:    else class_lit -> symbol = control.Class();
expr.cpp:    AstTypeName* base = this_expression -> base_opt;
expr.cpp:        TypeSymbol* enclosing_type = base -> symbol;
expr.cpp:            this_expression -> symbol = control.no_type;
expr.cpp:            this_expression -> symbol = control.no_type;
expr.cpp:        else if (enclosing_type -> ACC_INTERFACE())
expr.cpp:                           enclosing_type -> ContainingPackageName(),
expr.cpp:                           enclosing_type -> ExternalName());
expr.cpp:            this_expression -> symbol = control.no_type;
expr.cpp:                           base -> LeftToken(),
expr.cpp:                           this_expression -> this_token,
expr.cpp:            this_expression -> symbol = control.no_type;
expr.cpp:        else if (! this_type -> IsNestedIn(enclosing_type))
expr.cpp:                           base -> LeftToken(),
expr.cpp:                           this_expression -> this_token,
expr.cpp:                           enclosing_type -> ContainingPackageName(),
expr.cpp:                           enclosing_type -> ExternalName(),
expr.cpp:                           this_package -> PackageName(),
expr.cpp:                           this_type -> ExternalName());
expr.cpp:            this_expression -> symbol = control.no_type;
expr.cpp:                               base -> LeftToken(),
expr.cpp:                               this_expression -> this_token,
expr.cpp:                               enclosing_type -> ContainingPackageName(),
expr.cpp:                               enclosing_type -> ExternalName());
expr.cpp:                this_expression -> symbol = control.no_type;
expr.cpp:            else this_expression -> symbol = this_type;
expr.cpp:            this_expression -> resolution_opt =
expr.cpp:            this_expression -> symbol =
expr.cpp:                this_expression -> resolution_opt -> symbol;
expr.cpp:                           this_expression -> this_token,
expr.cpp:            this_expression -> symbol = control.no_type;
expr.cpp:                           this_expression -> this_token);
expr.cpp:            this_expression -> symbol = control.no_type;
expr.cpp:        else this_expression -> symbol = this_type;
expr.cpp:    AstTypeName* base = super_expression -> base_opt;
expr.cpp:        TypeSymbol* enclosing_type = base -> symbol;
expr.cpp:            super_expression -> symbol = control.no_type;
expr.cpp:            super_expression -> symbol = control.no_type;
expr.cpp:        else if (enclosing_type -> ACC_INTERFACE())
expr.cpp:                           enclosing_type -> ContainingPackageName(),
expr.cpp:                           enclosing_type -> ExternalName());
expr.cpp:            super_expression -> symbol = control.no_type;
expr.cpp:                           base -> LeftToken(),
expr.cpp:                           super_expression -> super_token);
expr.cpp:            super_expression -> symbol = control.no_type;
expr.cpp:                           base -> LeftToken(),
expr.cpp:                           super_expression -> super_token,
expr.cpp:            super_expression -> symbol = control.no_type;
expr.cpp:        else if (! this_type -> IsNestedIn(enclosing_type))
expr.cpp:                           base -> LeftToken(),
expr.cpp:                           super_expression -> super_token,
expr.cpp:                           enclosing_type -> ContainingPackageName(),
expr.cpp:                           enclosing_type -> ExternalName(),
expr.cpp:                           this_package -> PackageName(),
expr.cpp:                           this_type -> ExternalName());
expr.cpp:            super_expression -> symbol = control.no_type;
expr.cpp:                               base -> LeftToken(),
expr.cpp:                               super_expression -> super_token,
expr.cpp:                               enclosing_type -> ContainingPackageName(),
expr.cpp:                               enclosing_type -> ExternalName());
expr.cpp:                super_expression -> symbol = control.no_type;
expr.cpp:            else super_expression -> symbol = this_type -> super;
expr.cpp:            super_expression -> resolution_opt =
expr.cpp:            super_expression -> symbol =
expr.cpp:                super_expression -> resolution_opt -> symbol;
expr.cpp:                           super_expression -> super_token);
expr.cpp:            super_expression -> symbol = control.no_type;
expr.cpp:                           super_expression -> super_token,
expr.cpp:            super_expression -> symbol = control.no_type;
expr.cpp:                           super_expression -> super_token);
expr.cpp:            super_expression -> symbol = control.no_type;
expr.cpp:        else super_expression -> symbol = ThisType() -> super;
expr.cpp:    // intermediate Strings - see CheckConstantString in lookup.cpp
expr.cpp:    ProcessExpression(parenthesized -> expression);
expr.cpp:    if (parenthesized -> expression -> Type() == control.void_type)
expr.cpp:                       parenthesized -> expression,
expr.cpp:                       control.void_type -> Name());
expr.cpp:        parenthesized -> symbol = control.no_type;
expr.cpp:        parenthesized -> value = parenthesized -> expression -> value;
expr.cpp:        parenthesized -> symbol = parenthesized -> expression -> symbol;
expr.cpp:    assert(inner_type -> IsLocal() &&
expr.cpp:           (! inner_type -> Anonymous() || ! inner_type -> EnclosingType()));
expr.cpp:    inner_type -> MarkLocalClassProcessingCompleted();
expr.cpp:    unsigned param_count = inner_type -> NumConstructorParameters();
expr.cpp:        for (ctor = inner_type -> FindMethodSymbol(control.init_name_symbol);
expr.cpp:             ctor; ctor = ctor -> next_method)
expr.cpp:            ctor -> SetSignature(control);
expr.cpp:             j < inner_type -> NumPrivateAccessConstructors(); j++)
expr.cpp:            inner_type -> PrivateAccessConstructor(j) ->
expr.cpp:                SetSignature(control, (inner_type -> outermost_type ->
expr.cpp:         i < inner_type -> NumLocalConstructorCallEnvironments(); i++)
expr.cpp:            inner_type -> LocalConstructorCallEnvironment(i);
expr.cpp:        AstArguments* args = env -> args;
expr.cpp:        args -> AllocateLocalArguments(param_count);
expr.cpp:            AstName* name = compilation_unit ->
expr.cpp:                ast_pool -> GenName(args -> right_parenthesis_token);
expr.cpp:                FindLocalVariable(inner_type -> ConstructorParameter(k),
expr.cpp:            name -> symbol = accessor;
expr.cpp:            TypeSymbol* owner = accessor -> ContainingType();
expr.cpp:            args -> AddLocalArgument(name);
expr.cpp:        if (ThisType() -> Anonymous() &&
expr.cpp:            ! ThisType() -> LocalClassProcessingCompleted())
expr.cpp:    TokenIndex left_loc = class_creation -> class_type -> LeftToken();
expr.cpp:        class_creation -> arguments -> right_parenthesis_token;
expr.cpp:    state_stack.Push(anonymous_type -> semantic_environment);
expr.cpp:    TypeSymbol* super_type = anonymous_type -> super;
expr.cpp:        class_creation -> class_type -> symbol = control.no_type;
expr.cpp:    assert(super_constructor -> IsTyped());
expr.cpp:    AstArguments* resolution_args = compilation_unit -> ast_pool ->
expr.cpp:        GenArguments(class_creation -> arguments -> left_parenthesis_token,
expr.cpp:        compilation_unit -> ast_pool -> GenClassCreationExpression();
expr.cpp:    resolution -> new_token = class_creation -> new_token;
expr.cpp:    resolution -> class_type = class_creation -> class_type;
expr.cpp:    resolution -> arguments = resolution_args;
expr.cpp:    resolution -> symbol = anonymous_type;
expr.cpp:    class_creation -> resolution_opt = resolution;
expr.cpp:        new BlockSymbol(super_constructor -> NumFormalParameters() + 3);
expr.cpp:    block_symbol -> max_variable_index = 1; // A spot for "this".
expr.cpp:        anonymous_type -> InsertMethodSymbol(control.init_name_symbol);
expr.cpp:    constructor -> SetType(anonymous_type);
expr.cpp:    constructor -> SetContainingType(anonymous_type);
expr.cpp:    constructor -> SetBlockSymbol(block_symbol);
expr.cpp:    for (unsigned i = 0; i < super_constructor -> NumThrows(); i++)
expr.cpp:        constructor -> AddThrows(super_constructor -> Throws(i));
expr.cpp:    if (anonymous_type -> EnclosingType())
expr.cpp:            block_symbol -> InsertVariableSymbol(control.this_name_symbol);
expr.cpp:        this0_variable -> SetType(anonymous_type -> EnclosingType());
expr.cpp:        this0_variable -> SetOwner(constructor);
expr.cpp:        this0_variable -> SetFlags(AccessFlags::ACCESS_FINAL |
expr.cpp:        this0_variable -> SetLocalVariableIndex(block_symbol ->
expr.cpp:        this0_variable -> MarkComplete();
expr.cpp:            compilation_unit -> ast_pool -> GenThisExpression(left_loc);
expr.cpp:        this0_expression -> symbol = anonymous_type -> EnclosingType();
expr.cpp:        resolution -> base_opt = this0_expression;
expr.cpp:    AstArguments* super_args = compilation_unit -> ast_pool ->
expr.cpp:        GenArguments(class_creation -> arguments -> left_parenthesis_token,
expr.cpp:    AstSuperCall* super_call = compilation_unit -> ast_pool -> GenSuperCall();
expr.cpp:    if (super_constructor -> ACC_PRIVATE())
expr.cpp:            super_type -> GetReadAccessConstructor(super_constructor);
expr.cpp:        super_args -> AddNullArgument();
expr.cpp:    super_call -> base_opt = class_creation -> base_opt;
expr.cpp:    super_call -> super_token = class_creation -> new_token;
expr.cpp:    super_call -> arguments = super_args;
expr.cpp:    super_call -> semicolon_token = right_loc;
expr.cpp:    super_call -> symbol = super_constructor;
expr.cpp:    AstClassBody* class_body = class_creation -> class_body_opt;
expr.cpp:        compilation_unit -> ast_pool -> GenMethodBody();
expr.cpp:    constructor_block -> block_symbol =
expr.cpp:        constructor -> block_symbol -> InsertBlockSymbol(0);
expr.cpp:    constructor_block -> left_brace_token = class_body -> left_brace_token;
expr.cpp:    constructor_block -> right_brace_token = class_body -> left_brace_token;
expr.cpp:    constructor_block -> explicit_constructor_opt = super_call;
expr.cpp:    constructor_block -> AllocateStatements(1); // for the generated return
expr.cpp:        compilation_unit -> ast_pool -> GenMethodDeclarator();
expr.cpp:    method_declarator -> identifier_token = left_loc;
expr.cpp:    method_declarator -> left_parenthesis_token =
expr.cpp:        class_creation -> arguments -> left_parenthesis_token;
expr.cpp:    method_declarator -> right_parenthesis_token = right_loc;
expr.cpp:        compilation_unit -> ast_pool -> GenConstructorDeclaration();
expr.cpp:    constructor_declaration -> constructor_declarator = method_declarator;
expr.cpp:    constructor_declaration -> constructor_body = constructor_block;
expr.cpp:    constructor_declaration -> constructor_symbol = constructor;
expr.cpp:    constructor -> declaration = constructor_declaration;
expr.cpp:    class_body -> default_constructor = constructor_declaration;
expr.cpp:    unsigned num_args = class_creation -> arguments -> NumArguments();
expr.cpp:    if (class_creation -> base_opt)
expr.cpp:            block_symbol -> InsertVariableSymbol(control.MakeParameter(0));
expr.cpp:        super_this0_variable -> SetACC_SYNTHETIC();
expr.cpp:        super_this0_variable -> SetType(super_call -> base_opt -> Type());
expr.cpp:        super_this0_variable -> SetOwner(constructor);
expr.cpp:        super_this0_variable -> SetLocalVariableIndex(block_symbol ->
expr.cpp:        super_this0_variable -> MarkComplete();
expr.cpp:        resolution_args -> AllocateArguments(num_args + 1);
expr.cpp:        resolution_args -> AddArgument(class_creation -> base_opt);
expr.cpp:        constructor -> AddFormalParameter(super_this0_variable);
expr.cpp:        AstName* name = compilation_unit -> ast_pool ->
expr.cpp:            GenName(class_creation -> new_token);
expr.cpp:        name -> symbol = super_this0_variable;
expr.cpp:        super_call -> base_opt = name;
expr.cpp:    else resolution_args -> AllocateArguments(num_args);
expr.cpp:    super_args -> AllocateArguments(super_constructor ->
expr.cpp:    for (unsigned j = 0; j < super_constructor -> NumFormalParameters(); j++)
expr.cpp:        VariableSymbol* param = super_constructor -> FormalParameter(j);
expr.cpp:            block_symbol -> InsertVariableSymbol(param -> Identity());
expr.cpp:        symbol -> SetType(param -> Type());
expr.cpp:        symbol -> SetOwner(constructor);
expr.cpp:        symbol -> SetLocalVariableIndex(block_symbol -> max_variable_index++);
expr.cpp:        symbol -> MarkComplete();
expr.cpp:        if (control.IsDoubleWordType(symbol -> Type()))
expr.cpp:            block_symbol -> max_variable_index++;
expr.cpp:        resolution_args -> AddArgument(class_creation -> arguments -> Argument(j));
expr.cpp:        constructor -> AddFormalParameter(symbol);
expr.cpp:        AstName* name = compilation_unit -> ast_pool ->
expr.cpp:            GenName(class_creation -> new_token);
expr.cpp:        name -> symbol = symbol;
expr.cpp:        super_args -> AddArgument(name);
expr.cpp:    if (super_type -> IsLocal())
expr.cpp:        unsigned param_count = super_type -> NumConstructorParameters();
expr.cpp:        if (super_type -> LocalClassProcessingCompleted() && param_count)
expr.cpp:            super_args -> AllocateLocalArguments(param_count);
expr.cpp:                AstName* name = compilation_unit ->
expr.cpp:                    ast_pool -> GenName(super_call -> super_token);
expr.cpp:                    FindLocalVariable(super_type -> ConstructorParameter(k),
expr.cpp:                name -> symbol = accessor;
expr.cpp:                TypeSymbol* owner = accessor -> ContainingType();
expr.cpp:                super_args -> AddLocalArgument(name);
expr.cpp:            super_type -> AddLocalConstructorCallEnvironment
expr.cpp:                (GetEnvironment(super_call -> arguments));
expr.cpp:    constructor -> SetSignature(control);
expr.cpp:    if (error && error -> InClone())
expr.cpp:    AstClassBody* class_body = class_creation -> class_body_opt;
expr.cpp:    TypeSymbol* outermost_type = this_type -> outermost_type;
expr.cpp:    IntToWstring value(this_type -> NumLocalTypes() +
expr.cpp:                       this_type -> NumAnonymousTypes() + 1);
expr.cpp:    int length = this_type -> ExternalNameLength() + 1 +
expr.cpp:    wcscpy(anonymous_name, this_type -> ExternalName());
expr.cpp:        this_type -> InsertAnonymousTypeSymbol(name_symbol);
expr.cpp:    anon_type -> MarkAnonymous();
expr.cpp:    anon_type -> outermost_type = outermost_type;
expr.cpp:    anon_type -> supertypes_closure = new SymbolSet;
expr.cpp:    anon_type -> subtypes_closure = new SymbolSet;
expr.cpp:    anon_type -> semantic_environment =
expr.cpp:    anon_type -> declaration = class_body;
expr.cpp:    anon_type -> declaration -> semantic_environment =
expr.cpp:        anon_type -> semantic_environment;
expr.cpp:    anon_type -> file_symbol = source_file_symbol;
expr.cpp:        anon_type -> SetOwner(ThisMethod());
expr.cpp:        // requires non-trivial code, so the initializer method should
expr.cpp:        assert(ThisVariable() -> ACC_STATIC()
expr.cpp:               ? this_type -> static_initializer_method
expr.cpp:               : (this_type -> FindMethodSymbol(control.
expr.cpp:        anon_type ->
expr.cpp:            SetOwner(ThisVariable() -> ACC_STATIC()
expr.cpp:                     ? this_type -> static_initializer_method
expr.cpp:                     : (this_type ->
expr.cpp:        assert(class_creation -> generated);
expr.cpp:        anon_type -> SetOwner(this_type);
expr.cpp:    anon_type -> SetSymbolTable(class_body -> NumClassBodyDeclarations() + 3);
expr.cpp:    anon_type -> SetLocation();
expr.cpp:    anon_type -> SetSignature(control);
expr.cpp:    anon_type -> SetACC_FINAL();
expr.cpp:        anon_type -> InsertThis0();
expr.cpp:    if (super_type -> ACC_INTERFACE())
expr.cpp:        anon_type -> AddInterface(super_type);
expr.cpp:        anon_type -> super = control.Object();
expr.cpp:        control.Object() -> subtypes -> AddElement(anon_type);
expr.cpp:    else anon_type -> super = super_type;
expr.cpp:    super_type -> subtypes -> AddElement(anon_type);
expr.cpp:    if (super_type -> ACC_FINAL())
expr.cpp:                        class_creation -> class_type,
expr.cpp:                        super_type -> ContainingPackageName(),
expr.cpp:                        super_type -> ExternalName());
expr.cpp:         anon_type -> MarkBad();
expr.cpp:    else if (super_type -> Bad())
expr.cpp:        anon_type -> MarkBad();
expr.cpp:    this_type -> AddAnonymousType(anon_type);
expr.cpp:    if (class_body -> UnparsedClassBodyCast())
expr.cpp:        if (! control.parser -> InitializerParse(lex_stream, class_body))
expr.cpp:             compilation_unit -> MarkBad();
expr.cpp:        if (! control.parser -> BodyParse(lex_stream, class_body))
expr.cpp:            compilation_unit -> MarkBad();
expr.cpp:    if (class_creation -> class_type -> symbol == control.no_type)
expr.cpp:    if (! super_type -> IsLocal() ||
expr.cpp:        super_type -> LocalClassProcessingCompleted() ||
expr.cpp:        anon_type -> EnclosingType())
expr.cpp:        if (anon_type -> NumConstructorParameters() && ! anon_type -> Bad())
expr.cpp:            class_body -> default_constructor -> constructor_symbol ->
expr.cpp:        anon_type -> MarkLocalClassProcessingCompleted();
expr.cpp:    AstName* actual_type = class_creation -> class_type -> name;
expr.cpp:    if (class_creation -> base_opt)
expr.cpp:        ProcessExpression(class_creation -> base_opt);
expr.cpp:        TypeSymbol* enclosing_type = class_creation -> base_opt -> Type();
expr.cpp:        if (! enclosing_type -> IsSubclass(control.Object()))
expr.cpp:                               class_creation -> base_opt,
expr.cpp:                               enclosing_type -> ExternalName());
expr.cpp:        if (type -> ACC_INTERFACE())
expr.cpp:                           actual_type, type -> ContainingPackageName(),
expr.cpp:                           type -> ExternalName());
expr.cpp:        else if (type -> ACC_STATIC())
expr.cpp:                           actual_type, type -> ContainingPackageName(),
expr.cpp:                           type -> ExternalName());
expr.cpp:        ProcessType(class_creation -> class_type);
expr.cpp:        type = class_creation -> class_type -> symbol;
expr.cpp:        if (type -> EnclosingType())
expr.cpp:            AstThisExpression* this_expr = compilation_unit -> ast_pool ->
expr.cpp:                GenThisExpression(class_creation -> new_token);
expr.cpp:            this_expr -> resolution_opt =
expr.cpp:                CreateAccessToType(class_creation, type -> EnclosingType());
expr.cpp:            this_expr -> symbol = this_expr -> resolution_opt -> symbol;
expr.cpp:            class_creation -> base_opt = this_expr;
expr.cpp:    if (class_creation -> type_arguments_opt)
expr.cpp:                       class_creation -> type_arguments_opt);
expr.cpp:    ProcessArguments(class_creation -> arguments);
expr.cpp:    if (type -> IsEnum())
expr.cpp:                       type -> ContainingPackageName(),
expr.cpp:                       type -> ExternalName());
expr.cpp:    else if (class_creation -> class_body_opt)
expr.cpp:        class_creation -> symbol = type;
expr.cpp:            class_creation = class_creation -> resolution_opt;
expr.cpp:    else if (type -> ACC_INTERFACE())
expr.cpp:                       type -> ContainingPackageName(),
expr.cpp:                       type -> ExternalName());
expr.cpp:    else if (type -> ACC_ABSTRACT())
expr.cpp:                       type -> ExternalName());
expr.cpp:        FindConstructor(type, class_creation, actual_type -> LeftToken(),
expr.cpp:                        class_creation -> arguments -> right_parenthesis_token);
expr.cpp:        assert(ctor -> IsTyped());
expr.cpp:        class_creation -> symbol = ctor;
expr.cpp:        if (class_creation -> base_opt)
expr.cpp:            assert(CanAssignmentConvertReference(ctor -> containing_type -> EnclosingType(),
expr.cpp:                                                 class_creation -> base_opt -> Type()));
expr.cpp:            class_creation -> base_opt =
expr.cpp:                ConvertToType(class_creation -> base_opt,
expr.cpp:                              ctor -> containing_type -> EnclosingType());
expr.cpp:        MethodInvocationConversion(class_creation -> arguments, ctor);
expr.cpp:        for (i = 0; i < ctor -> NumThrows(); i++)
expr.cpp:            TypeSymbol* exception = ctor -> Throws(i);
expr.cpp:                exception_set -> AddElement(exception);
expr.cpp:                ReportSemError((class_creation -> class_body_opt
expr.cpp:                               actual_type, type -> ExternalName(),
expr.cpp:                               exception -> ContainingPackageName(),
expr.cpp:                               exception -> ExternalName(),
expr.cpp:        if (ctor -> ACC_PRIVATE() && ThisType() != type)
expr.cpp:            assert(ThisType() -> outermost_type == type -> outermost_type);
expr.cpp:            ctor = type -> GetReadAccessConstructor(ctor);
expr.cpp:            class_creation -> symbol = ctor;
expr.cpp:            class_creation -> arguments -> AddNullArgument();
expr.cpp:            exception_set -> AddElement(control.no_type);
expr.cpp:        class_creation -> symbol = control.no_type;
expr.cpp:    if (type -> IsLocal())
expr.cpp:        if (type -> LocalClassProcessingCompleted())
expr.cpp:            unsigned param_count = type -> NumConstructorParameters();
expr.cpp:            class_creation -> arguments -> AllocateLocalArguments(param_count);
expr.cpp:                AstName* name = compilation_unit ->
expr.cpp:                    ast_pool -> GenName(class_creation -> new_token);
expr.cpp:                    FindLocalVariable(type -> ConstructorParameter(i),
expr.cpp:                name -> symbol = accessor;
expr.cpp:                TypeSymbol* owner = accessor -> ContainingType();
expr.cpp:                class_creation -> arguments -> AddLocalArgument(name);
expr.cpp:            type -> AddLocalConstructorCallEnvironment
expr.cpp:                (GetEnvironment(class_creation -> arguments));
expr.cpp:    assert(array_creation -> array_initializer_opt ?
expr.cpp:           (! array_creation -> NumDimExprs() &&
expr.cpp:            ! array_creation -> NumBrackets())
expr.cpp:           : array_creation -> NumDimExprs());
expr.cpp:    ProcessType(array_creation -> array_type);
expr.cpp:    TypeSymbol* type = array_creation -> array_type -> symbol;
expr.cpp:    unsigned dims = type -> num_dimensions +
expr.cpp:        array_creation -> NumDimExprs() + array_creation -> NumBrackets();
expr.cpp:    type = type -> GetArrayType(this, dims);
expr.cpp:    array_creation -> symbol = type;
expr.cpp:    for (unsigned i = 0; i < array_creation -> NumDimExprs(); i++)
expr.cpp:        AstDimExpr* dim_expr = array_creation -> DimExpr(i);
expr.cpp:        ProcessExpression(dim_expr -> expression);
expr.cpp:            PromoteUnaryNumericExpression(dim_expr -> expression);
expr.cpp:        if (expr -> Type() != control.int_type &&
expr.cpp:            expr -> symbol != control.no_type)
expr.cpp:                           dim_expr -> expression,
expr.cpp:                           expr -> Type() -> ContainingPackageName(),
expr.cpp:                           expr -> Type() -> ExternalName());
expr.cpp:            array_creation -> symbol = control.no_type;
expr.cpp:        dim_expr -> expression = expr;
expr.cpp:        if (expr -> IsConstant() &&
expr.cpp:            expr -> Type() == control.int_type &&
expr.cpp:            (DYNAMIC_CAST<IntLiteralValue*> (expr -> value)) -> value < 0)
expr.cpp:                           dim_expr -> expression);
expr.cpp:    if (array_creation -> array_initializer_opt)
expr.cpp:        ProcessArrayInitializer(array_creation -> array_initializer_opt, type);
expr.cpp:    AstExpression* expression = postfix_expression -> expression;
expr.cpp:    postfix_expression -> symbol = expression -> symbol;
expr.cpp:    if (expression -> ParenthesizedExpressionCast())
expr.cpp:        while (expression -> ParenthesizedExpressionCast())
expr.cpp:            expression = ((AstParenthesizedExpression*) expression) ->
expr.cpp:    if (expression -> symbol != control.no_type)
expr.cpp:        if (! expression -> IsLeftHandSide())
expr.cpp:                           postfix_expression -> expression,
expr.cpp:                           postfix_expression -> expression -> Type() -> Name());
expr.cpp:            postfix_expression -> symbol = control.no_type;
expr.cpp:        else if (! control.IsNumeric(expression -> Type()))
expr.cpp:                           postfix_expression -> expression,
expr.cpp:                           expression -> Type() -> ContainingPackageName(),
expr.cpp:                           expression -> Type() -> ExternalName());
expr.cpp:            postfix_expression -> symbol = control.no_type;
expr.cpp:        else if (! expression -> ArrayAccessCast()) // some kind of name
expr.cpp:            AstName* name = expression -> NameCast();
expr.cpp:                if (name -> resolution_opt)
expr.cpp:                        name -> resolution_opt -> symbol -> MethodCast();
expr.cpp:                if (field_access -> resolution_opt)
expr.cpp:                    read_method = field_access -> resolution_opt ->
expr.cpp:                        symbol -> MethodCast();
expr.cpp:                postfix_expression -> write_method =
expr.cpp:                    read_method -> containing_type ->
expr.cpp:    ProcessExpression(expr -> expression);
expr.cpp:    expr -> expression = PromoteUnaryNumericExpression(expr -> expression);
expr.cpp:    expr -> value = expr -> expression -> value;
expr.cpp:    expr -> symbol = expr -> expression -> symbol;
expr.cpp:        expr -> expression -> IntegerLiteralCast();
expr.cpp:    AstLongLiteral* long_literal = expr -> expression -> LongLiteralCast();
expr.cpp:        LiteralSymbol* literal = lex_stream ->
expr.cpp:            LiteralSymbol(int_literal -> integer_literal_token);
expr.cpp:        expr -> value = control.int_pool.FindOrInsertNegativeInt(literal);
expr.cpp:        if (expr -> value == control.BadValue())
expr.cpp:            expr -> symbol = control.no_type;
expr.cpp:        else expr -> symbol = control.int_type;
expr.cpp:        LiteralSymbol* literal = lex_stream ->
expr.cpp:            LiteralSymbol(long_literal -> long_literal_token);
expr.cpp:        expr -> value = control.long_pool.FindOrInsertNegativeLong(literal);
expr.cpp:        if (expr -> value == control.BadValue())
expr.cpp:            expr -> symbol = control.no_type;
expr.cpp:        else expr -> symbol = control.long_type;
expr.cpp:        ProcessExpression(expr -> expression);
expr.cpp:        expr -> expression = PromoteUnaryNumericExpression(expr -> expression);
expr.cpp:        expr -> symbol = expr -> expression -> symbol;
expr.cpp:        if (expr -> expression -> IsConstant())
expr.cpp:            TypeSymbol* type = expr -> Type();
expr.cpp:                    (expr -> expression -> value);
expr.cpp:                expr -> value =
expr.cpp:                    control.double_pool.FindOrInsert(-literal -> value);
expr.cpp:                    (expr -> expression -> value);
expr.cpp:                expr -> value =
expr.cpp:                    control.float_pool.FindOrInsert(-literal -> value);
expr.cpp:                    (expr -> expression -> value);
expr.cpp:                CheckIntegerNegation(this, expr, literal -> value);
expr.cpp:                expr -> value =
expr.cpp:                    control.long_pool.FindOrInsert(-literal -> value);
expr.cpp:            else if (expr -> Type() == control.int_type)
expr.cpp:                    (expr -> expression -> value);
expr.cpp:                CheckIntegerNegation(this, expr, literal -> value);
expr.cpp:                expr -> value =
expr.cpp:                    control.int_pool.FindOrInsert(-literal -> value);
expr.cpp:    ProcessExpression(expr -> expression);
expr.cpp:    expr -> expression = PromoteUnaryNumericExpression(expr -> expression);
expr.cpp:    expr -> symbol = expr -> expression -> symbol;
expr.cpp:    if (! control.IsIntegral(expr -> expression -> Type()))
expr.cpp:        TypeSymbol* type = expr -> expression -> Type();
expr.cpp:        if (expr -> expression -> symbol != control.no_type)
expr.cpp:                           expr -> expression,
expr.cpp:                           type -> ContainingPackageName(),
expr.cpp:                           type -> ExternalName());
expr.cpp:        expr -> symbol = control.no_type;
expr.cpp:    else if (expr -> expression -> IsConstant())
expr.cpp:        if (expr -> expression -> Type() == control.long_type)
expr.cpp:                (expr -> expression -> value);
expr.cpp:            expr -> value = control.long_pool.FindOrInsert(~literal -> value);
expr.cpp:        else // assert(expr -> expression -> Type() == control.int_type)
expr.cpp:                (expr -> expression -> value);
expr.cpp:            expr -> value = control.int_pool.FindOrInsert(~literal -> value);
expr.cpp:    ProcessExpression(expr -> expression);
expr.cpp:    if (expr -> expression -> Type() != control.boolean_type)
expr.cpp:        TypeSymbol* type = expr -> expression -> Type();
expr.cpp:        if (expr -> expression -> symbol != control.no_type)
expr.cpp:                           expr -> expression,
expr.cpp:                           type -> ContainingPackageName(),
expr.cpp:                           type -> ExternalName());
expr.cpp:        expr -> symbol = control.no_type;
expr.cpp:        if (expr -> expression -> IsConstant())
expr.cpp:            expr -> value = control.int_pool
expr.cpp:                .FindOrInsert(IsConstantTrue(expr -> expression) ? 0 : 1);
expr.cpp:        expr -> symbol = control.boolean_type;
expr.cpp:    AstExpression* expression = prefix_expression -> expression;
expr.cpp:    prefix_expression -> symbol = expression -> symbol;
expr.cpp:    if (expression -> ParenthesizedExpressionCast())
expr.cpp:        while (expression -> ParenthesizedExpressionCast())
expr.cpp:            expression = ((AstParenthesizedExpression*) expression) ->
expr.cpp:    if (expression -> symbol != control.no_type)
expr.cpp:        if (! expression -> IsLeftHandSide())
expr.cpp:                           prefix_expression -> expression,
expr.cpp:                           prefix_expression -> expression -> Type() -> Name());
expr.cpp:            prefix_expression -> symbol = control.no_type;
expr.cpp:        else if (! control.IsNumeric(expression -> Type()))
expr.cpp:                           prefix_expression -> expression,
expr.cpp:                           expression -> Type() -> ContainingPackageName(),
expr.cpp:                           expression -> Type() -> ExternalName());
expr.cpp:            prefix_expression -> symbol = control.no_type;
expr.cpp:        else if (! expression -> ArrayAccessCast()) // some kind of name
expr.cpp:            AstName* name = expression -> NameCast();
expr.cpp:                if (name -> resolution_opt)
expr.cpp:                       name -> resolution_opt -> symbol -> MethodCast();
expr.cpp:                if (field_access -> resolution_opt)
expr.cpp:                    read_method = field_access -> resolution_opt -> symbol ->
expr.cpp:                prefix_expression -> write_method =
expr.cpp:                    read_method -> containing_type ->
expr.cpp:    (this ->* ProcessPreUnaryExpr[prefix_expression -> Tag()])
expr.cpp:// method invocation - this includes identity and widening conversions.
expr.cpp:    if (source_type -> Primitive())
expr.cpp:        return target_type -> Primitive() &&
expr.cpp:    if (target_type -> Primitive())
expr.cpp:        source_type -> IsSubtype(target_type);
expr.cpp:        expr -> symbol == control.no_type ||
expr.cpp:        CanMethodInvocationConvert(target_type, expr -> Type()) ||
expr.cpp:    if (source_type -> Primitive())
expr.cpp:        return target_type -> Primitive() &&
expr.cpp:    if (target_type -> Primitive())
expr.cpp:        target_type -> IsSubtype(source_type) ||
expr.cpp:        source_type -> IsSubtype(target_type))
expr.cpp:    if (source_type -> IsArray() || target_type -> IsArray())
expr.cpp:        if (source_type -> num_dimensions != target_type -> num_dimensions)
expr.cpp:        source_type = source_type -> base_type;
expr.cpp:        target_type = target_type -> base_type;
expr.cpp:        if (source_type -> Primitive() || target_type -> Primitive())
expr.cpp:    if (source_type -> ACC_FINAL() || target_type -> ACC_FINAL() ||
expr.cpp:        (! source_type -> ACC_INTERFACE() && ! target_type -> ACC_INTERFACE()))
expr.cpp:    if (! source_type -> ACC_INTERFACE() || ! target_type -> ACC_INTERFACE())
expr.cpp:    if (! source_type -> expanded_method_table)
expr.cpp:    if (! target_type -> expanded_method_table)
expr.cpp:        source_type -> expanded_method_table;
expr.cpp:    for (i = 0; i < source_method_table -> symbol_pool.Length(); i++)
expr.cpp:            source_method_table -> symbol_pool[i] -> method_symbol;
expr.cpp:            target_type -> expanded_method_table ->
expr.cpp:            if (! method1 -> IsTyped())
expr.cpp:                method1 -> ProcessMethodSignature(this, tok);
expr.cpp:            MethodSymbol* method2 = method_shadow2 -> method_symbol;
expr.cpp:            if (! method2 -> IsTyped())
expr.cpp:                method2 -> ProcessMethodSignature(this, tok);
expr.cpp:            if (method1 -> Type() != method2 -> Type())
expr.cpp:    TypeSymbol* source_type = expr -> Type();
expr.cpp:        ! expr -> IsConstant())
expr.cpp:        assert(target_type == source_type || ! expr -> value);
expr.cpp:        return expr -> value;
expr.cpp:                DYNAMIC_CAST<DoubleLiteralValue*> (expr -> value);
expr.cpp:            DoubleToString ieee_double(literal -> value);
expr.cpp:                DYNAMIC_CAST<FloatLiteralValue*> (expr -> value);
expr.cpp:            FloatToString ieee_float(literal -> value);
expr.cpp:                DYNAMIC_CAST<LongLiteralValue*> (expr -> value);
expr.cpp:            LongToString long_integer(literal -> value);
expr.cpp:                DYNAMIC_CAST<IntLiteralValue*> (expr -> value);
expr.cpp:            literal_value = control.Utf8_pool.FindOrInsert(literal -> value);
expr.cpp:                literal_value = control.false_name_symbol -> Utf8_literal;
expr.cpp:                literal_value = control.true_name_symbol -> Utf8_literal;
expr.cpp:                DYNAMIC_CAST<IntLiteralValue*> (expr -> value);
expr.cpp:            IntToString integer(literal -> value);
expr.cpp:                DYNAMIC_CAST<FloatLiteralValue*> (expr -> value);
expr.cpp:                control.double_pool.FindOrInsert(literal -> value.DoubleValue());
expr.cpp:                DYNAMIC_CAST<LongLiteralValue*> (expr -> value);
expr.cpp:            IEEEdouble value(literal -> value);
expr.cpp:                DYNAMIC_CAST<IntLiteralValue*> (expr -> value);
expr.cpp:            IEEEdouble value(literal -> value);
expr.cpp:                DYNAMIC_CAST<DoubleLiteralValue*> (expr -> value);
expr.cpp:                control.float_pool.FindOrInsert(literal -> value.FloatValue());
expr.cpp:                DYNAMIC_CAST<LongLiteralValue*> (expr -> value);
expr.cpp:            IEEEfloat value(literal -> value);
expr.cpp:                DYNAMIC_CAST<IntLiteralValue*> (expr -> value);
expr.cpp:            IEEEfloat value(literal -> value);
expr.cpp:                DYNAMIC_CAST<DoubleLiteralValue*> (expr -> value);
expr.cpp:                control.long_pool.FindOrInsert(literal -> value.LongValue());
expr.cpp:                DYNAMIC_CAST<FloatLiteralValue*> (expr -> value);
expr.cpp:                control.long_pool.FindOrInsert(literal -> value.LongValue());
expr.cpp:                DYNAMIC_CAST<IntLiteralValue*> (expr -> value);
expr.cpp:                control.long_pool.FindOrInsert((LongInt) literal -> value);
expr.cpp:                DYNAMIC_CAST<DoubleLiteralValue*> (expr -> value);
expr.cpp:                control.int_pool.FindOrInsert((literal -> value).IntValue());
expr.cpp:                DYNAMIC_CAST<FloatLiteralValue*> (expr -> value);
expr.cpp:                control.int_pool.FindOrInsert(literal -> value.IntValue());
expr.cpp:                DYNAMIC_CAST<LongLiteralValue*> (expr -> value);
expr.cpp:                control.int_pool.FindOrInsert((i4) (literal -> value).LowWord());
expr.cpp:        else literal_value = expr -> value;
expr.cpp:                DYNAMIC_CAST<DoubleLiteralValue*> (expr -> value);
expr.cpp:                control.int_pool.FindOrInsert((i4) (u2) (literal -> value.IntValue()));
expr.cpp:                DYNAMIC_CAST<FloatLiteralValue*> (expr -> value);
expr.cpp:                control.int_pool.FindOrInsert((i4) (u2) (literal -> value.IntValue()));
expr.cpp:                DYNAMIC_CAST<LongLiteralValue*> (expr -> value);
expr.cpp:                control.int_pool.FindOrInsert((i4) (u2) (literal -> value).LowWord());
expr.cpp:                DYNAMIC_CAST<IntLiteralValue*> (expr -> value);
expr.cpp:                control.int_pool.FindOrInsert((i4) (u2) literal -> value);
expr.cpp:                DYNAMIC_CAST<DoubleLiteralValue*> (expr -> value);
expr.cpp:                control.int_pool.FindOrInsert((i4) (i2) (literal -> value.IntValue()));
expr.cpp:                DYNAMIC_CAST<FloatLiteralValue*> (expr -> value);
expr.cpp:                control.int_pool.FindOrInsert((i4) (i2) (literal -> value.IntValue()));
expr.cpp:                DYNAMIC_CAST<LongLiteralValue*> (expr -> value);
expr.cpp:                control.int_pool.FindOrInsert((i4) (i2) (literal -> value).LowWord());
expr.cpp:                DYNAMIC_CAST<IntLiteralValue*> (expr -> value);
expr.cpp:                control.int_pool.FindOrInsert((i4) (i2) literal -> value);
expr.cpp:                DYNAMIC_CAST<DoubleLiteralValue*> (expr -> value);
expr.cpp:                control.int_pool.FindOrInsert((i4) (i1) (literal -> value.IntValue()));
expr.cpp:                DYNAMIC_CAST<FloatLiteralValue*> (expr -> value);
expr.cpp:                control.int_pool.FindOrInsert((i4) (i1) (literal -> value.IntValue()));
expr.cpp:                DYNAMIC_CAST<LongLiteralValue*> (expr -> value);
expr.cpp:                                              (literal -> value).LowWord());
expr.cpp:                DYNAMIC_CAST<IntLiteralValue*> (expr -> value);
expr.cpp:                control.int_pool.FindOrInsert((i4) (i1) literal -> value);
expr.cpp:    // intermediate Strings - see CheckConstantString in lookup.cpp
expr.cpp:    ProcessType(cast_expression -> type);
expr.cpp:    ProcessExpression(cast_expression -> expression);
expr.cpp:    TypeSymbol* source_type = cast_expression -> expression -> Type();
expr.cpp:    TypeSymbol* target_type = cast_expression -> type -> symbol;
expr.cpp:                       cast_expression -> right_parenthesis_token))
expr.cpp:        cast_expression -> symbol = target_type;
expr.cpp:        cast_expression -> value = CastValue(target_type,
expr.cpp:                                             cast_expression -> expression);
expr.cpp:                       cast_expression -> expression,
expr.cpp:                       source_type -> ContainingPackageName(),
expr.cpp:                       source_type -> Name(),
expr.cpp:                       target_type -> ContainingPackageName(),
expr.cpp:                       target_type -> Name());
expr.cpp:        cast_expression -> symbol = control.no_type;
expr.cpp:    TypeSymbol* source_type = expr -> Type();
expr.cpp:        source_type == control.no_type || target_type -> Bad())
expr.cpp:    TokenIndex loc = expr -> LeftToken();
expr.cpp:        compilation_unit -> ast_pool -> GenCastExpression();
expr.cpp:    result -> left_parenthesis_token = loc;
expr.cpp:    result -> type = NULL;
expr.cpp:    result -> right_parenthesis_token = loc;
expr.cpp:    result -> expression = expr;
expr.cpp:    result -> symbol = target_type;
expr.cpp:    result -> value = CastValue(target_type, expr);
expr.cpp:    TypeSymbol* type = unary_expression -> Type();
expr.cpp:                       type -> ContainingPackageName(),
expr.cpp:                       type -> ExternalName());
expr.cpp:        unary_expression -> symbol = control.no_type;
expr.cpp:    binary_expression -> symbol =
expr.cpp:        BinaryNumericPromotion(binary_expression -> left_expression,
expr.cpp:                               binary_expression -> right_expression);
expr.cpp:    AstExpression* left_expr = assignment_expression -> left_hand_side;
expr.cpp:    while (left_expr -> ParenthesizedExpressionCast())
expr.cpp:        left_expr = ((AstParenthesizedExpression*) left_expr) -> expression;
expr.cpp:        BinaryNumericPromotion(left_expr, assignment_expression -> expression);
expr.cpp:    assignment_expression -> left_hand_side = left_expr;
expr.cpp:        assignment_expression -> symbol = control.no_type;
expr.cpp:    conditional_expression -> symbol =
expr.cpp:        BinaryNumericPromotion(conditional_expression -> true_expression,
expr.cpp:                               conditional_expression -> false_expression);
expr.cpp:    TypeSymbol* left_type = left_expr -> Type();
expr.cpp:    TypeSymbol* right_type = right_expr -> Type();
expr.cpp:                           left_type -> ContainingPackageName(),
expr.cpp:                           left_type -> ExternalName());
expr.cpp:                           right_type -> ContainingPackageName(),
expr.cpp:                           right_type -> ExternalName());
expr.cpp:    assert(args -> NumArguments() == method -> NumFormalParameters());
expr.cpp:    for (unsigned i = 0; i < args -> NumArguments(); i++)
expr.cpp:        AstExpression* expr = args -> Argument(i);
expr.cpp:        if (expr -> Type() != method -> FormalParameter(i) -> Type())
expr.cpp:            args -> Argument(i) =
expr.cpp:                ConvertToType(expr, method -> FormalParameter(i) -> Type());
expr.cpp:    // intermediate Strings - see CheckConstantString in lookup.cpp
expr.cpp:    AstExpression* left = expr -> left_expression;
expr.cpp:    AstExpression* right = expr -> right_expression;
expr.cpp:    TypeSymbol* left_type = left -> Type();
expr.cpp:    TypeSymbol* right_type = right -> Type();
expr.cpp:        expr -> symbol = control.no_type;
expr.cpp:            AddDependence(ThisType(), left_type -> BoxedType(control));
expr.cpp:                expr -> symbol = control.no_type;
expr.cpp:            else if (left_type == control.null_type || left -> IsConstant())
expr.cpp:                left -> value = CastValue(control.String(), left);
expr.cpp:                left -> symbol = control.String();
expr.cpp:            AddDependence(ThisType(), right_type -> BoxedType(control));
expr.cpp:                expr -> symbol = control.no_type;
expr.cpp:            else if (right_type == control.null_type || right -> IsConstant())
expr.cpp:                right -> value = CastValue(control.String(), right);
expr.cpp:                right -> symbol = control.String();
expr.cpp:        // constant pool instead of n-1 subresults. See CheckStringConstant
expr.cpp:        if (expr -> symbol != control.no_type)
expr.cpp:            expr -> symbol = control.String();
expr.cpp:        left = expr -> left_expression;
expr.cpp:        right = expr -> right_expression;
expr.cpp:        if (left -> IsConstant() && right -> IsConstant())
expr.cpp:            if (expr -> Type() == control.double_type)
expr.cpp:                    DYNAMIC_CAST<DoubleLiteralValue*> (left -> value);
expr.cpp:                    DYNAMIC_CAST<DoubleLiteralValue*> (right -> value);
expr.cpp:                expr -> value =
expr.cpp:                    control.double_pool.FindOrInsert(left_value -> value +
expr.cpp:                                                     right_value -> value);
expr.cpp:            else if (expr -> Type() == control.float_type)
expr.cpp:                    DYNAMIC_CAST<FloatLiteralValue*> (left -> value);
expr.cpp:                    DYNAMIC_CAST<FloatLiteralValue*> (right -> value);
expr.cpp:                expr -> value =
expr.cpp:                    control.float_pool.FindOrInsert(left_value -> value +
expr.cpp:                                                    right_value -> value);
expr.cpp:            else if (expr -> Type() == control.long_type)
expr.cpp:                    DYNAMIC_CAST<LongLiteralValue*> (left -> value);
expr.cpp:                    DYNAMIC_CAST<LongLiteralValue*> (right -> value);
expr.cpp:                CheckIntegerAddition(this, expr, left_value -> value,
expr.cpp:                                     right_value -> value);
expr.cpp:                expr -> value =
expr.cpp:                    control.long_pool.FindOrInsert(left_value -> value +
expr.cpp:                                                   right_value -> value);
expr.cpp:            else if (expr -> Type() == control.int_type)
expr.cpp:                    DYNAMIC_CAST<IntLiteralValue*> (left -> value);
expr.cpp:                    DYNAMIC_CAST<IntLiteralValue*> (right -> value);
expr.cpp:                CheckIntegerAddition(this, expr, left_value -> value,
expr.cpp:                                     right_value -> value);
expr.cpp:                expr -> value =
expr.cpp:                    control.int_pool.FindOrInsert(left_value -> value +
expr.cpp:                                                  right_value -> value);
expr.cpp:    ProcessExpression(expr -> left_expression);
expr.cpp:    ProcessExpression(expr -> right_expression);
expr.cpp:    TypeSymbol* left_type = expr -> left_expression -> Type();
expr.cpp:    TypeSymbol* right_type = expr -> right_expression -> Type();
expr.cpp:                           expr -> left_expression,
expr.cpp:                           left_type -> ContainingPackageName(),
expr.cpp:                           left_type -> ExternalName());
expr.cpp:        expr -> symbol = control.no_type;
expr.cpp:        expr -> left_expression =
expr.cpp:            PromoteUnaryNumericExpression(expr -> left_expression);
expr.cpp:                           expr -> right_expression,
expr.cpp:                           right_type -> ContainingPackageName(),
expr.cpp:                           right_type -> ExternalName());
expr.cpp:        expr -> symbol = control.no_type;
expr.cpp:        expr -> right_expression = ConvertToType(expr -> right_expression,
expr.cpp:        if (expr -> symbol != control.no_type)
expr.cpp:            expr -> symbol = expr -> left_expression -> symbol;
expr.cpp:        ProcessShiftCount(left_type, expr -> right_expression);
expr.cpp:// with a negative or out-of-range shift count, so it's still valid code,
expr.cpp:    if (! expr -> IsConstant())
expr.cpp:    IntLiteralValue* literal = DYNAMIC_CAST<IntLiteralValue*>(expr -> value);
expr.cpp:    i4 count = literal -> value;
expr.cpp:    if (expr -> left_expression -> IsConstant() &&
expr.cpp:        expr -> right_expression -> IsConstant())
expr.cpp:        if (expr -> Type() == control.long_type)
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value = control.long_pool.FindOrInsert(left -> value <<
expr.cpp:                                                           (right -> value &
expr.cpp:        else if (expr -> Type() == control.int_type)
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value = control.int_pool.FindOrInsert(left -> value <<
expr.cpp:                                                          (right -> value &
expr.cpp:    if (expr -> left_expression -> IsConstant() &&
expr.cpp:        expr -> right_expression -> IsConstant())
expr.cpp:        if (expr -> Type() == control.long_type)
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value = control.long_pool.FindOrInsert(left -> value >>
expr.cpp:                                                           (right -> value &
expr.cpp:        else if (expr -> Type() == control.int_type)
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value = control.int_pool.FindOrInsert(left -> value >>
expr.cpp:                                                          (right -> value &
expr.cpp:    if (expr -> left_expression -> IsConstant() &&
expr.cpp:        expr -> right_expression -> IsConstant())
expr.cpp:        if (expr -> Type() == control.long_type)
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value = control.long_pool.FindOrInsert((LongInt)
expr.cpp:                ((ULongInt) left -> value >> (right -> value & LONG_SHIFT_MASK)));
expr.cpp:        else if (expr -> Type() == control.int_type)
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value = control.int_pool.FindOrInsert((i4)
expr.cpp:                ((u4) left -> value >> (right -> value & INT_SHIFT_MASK)));
expr.cpp:    ProcessExpression(expr -> left_expression);
expr.cpp:    ProcessExpression(expr -> right_expression);
expr.cpp:    TypeSymbol* left_type = expr -> left_expression -> Type();
expr.cpp:    TypeSymbol* right_type = expr -> right_expression -> Type();
expr.cpp:    expr -> symbol = (left_type == control.no_type ||
expr.cpp:    if (expr -> left_expression -> IsConstant() &&
expr.cpp:        expr -> right_expression -> IsConstant())
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value <
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value <
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value <
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value <
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:    ProcessExpression(expr -> left_expression);
expr.cpp:    ProcessExpression(expr -> right_expression);
expr.cpp:    TypeSymbol* left_type = expr -> left_expression -> Type();
expr.cpp:    TypeSymbol* right_type = expr -> right_expression -> Type();
expr.cpp:    expr -> symbol = (left_type == control.no_type ||
expr.cpp:    if (expr -> left_expression -> IsConstant() &&
expr.cpp:        expr -> right_expression -> IsConstant())
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value >
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value >
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value >
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value >
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:    ProcessExpression(expr -> left_expression);
expr.cpp:    ProcessExpression(expr -> right_expression);
expr.cpp:    TypeSymbol* left_type = expr -> left_expression -> Type();
expr.cpp:    TypeSymbol* right_type = expr -> right_expression -> Type();
expr.cpp:    expr -> symbol = (left_type == control.no_type ||
expr.cpp:    if (expr -> left_expression -> IsConstant() &&
expr.cpp:        expr -> right_expression -> IsConstant())
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value <=
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value <=
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value <=
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value <=
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:    ProcessExpression(expr -> left_expression);
expr.cpp:    ProcessExpression(expr -> right_expression);
expr.cpp:    TypeSymbol* left_type = expr -> left_expression -> Type();
expr.cpp:    TypeSymbol* right_type = expr -> right_expression -> Type();
expr.cpp:    expr -> symbol = (left_type == control.no_type ||
expr.cpp:    if (expr -> left_expression -> IsConstant() &&
expr.cpp:        expr -> right_expression -> IsConstant())
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value >=
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value >=
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value >=
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value >=
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:    ProcessExpression(expr -> left_expression);
expr.cpp:    ProcessExpression(expr -> right_expression);
expr.cpp:    TypeSymbol* left_type = expr -> left_expression -> Type();
expr.cpp:    TypeSymbol* right_type = expr -> right_expression -> Type();
expr.cpp:                               expr -> left_expression,
expr.cpp:                               left_type -> ContainingPackageName(),
expr.cpp:                               left_type -> ExternalName());
expr.cpp:            expr -> symbol = control.no_type;
expr.cpp:                               expr -> right_expression,
expr.cpp:                               right_type -> ContainingPackageName(),
expr.cpp:                               right_type -> ExternalName());
expr.cpp:            expr -> symbol = control.no_type;
expr.cpp:        else expr -> symbol = control.boolean_type;
expr.cpp:        if (expr -> left_expression -> IsConstant() &&
expr.cpp:            expr -> right_expression -> IsConstant())
expr.cpp:            expr -> value = control.int_pool
expr.cpp:                .FindOrInsert((IsConstantTrue(expr -> left_expression) &&
expr.cpp:                               IsConstantTrue(expr -> right_expression))
expr.cpp:        TypeSymbol* expr_type = expr -> Type();
expr.cpp:                               expr -> left_expression,
expr.cpp:                               left_type -> ContainingPackageName(),
expr.cpp:                               left_type -> ExternalName());
expr.cpp:                               expr -> right_expression,
expr.cpp:                               right_type -> ContainingPackageName(),
expr.cpp:                               right_type -> ExternalName());
expr.cpp:            expr -> symbol = control.no_type;
expr.cpp:        if (expr -> left_expression -> IsConstant() &&
expr.cpp:            expr -> right_expression -> IsConstant())
expr.cpp:                    (expr -> left_expression -> value);
expr.cpp:                    (expr -> right_expression -> value);
expr.cpp:                expr -> value = control.long_pool.FindOrInsert(left -> value &
expr.cpp:                                                               right -> value);
expr.cpp:                    (expr -> left_expression -> value);
expr.cpp:                    (expr -> right_expression -> value);
expr.cpp:                expr -> value = control.int_pool.FindOrInsert(left -> value &
expr.cpp:                                                              right -> value);
expr.cpp:    ProcessExpression(expr -> left_expression);
expr.cpp:    ProcessExpression(expr -> right_expression);
expr.cpp:    TypeSymbol* left_type = expr -> left_expression -> Type();
expr.cpp:    TypeSymbol* right_type = expr -> right_expression -> Type();
expr.cpp:                               expr -> left_expression,
expr.cpp:                               left_type -> ContainingPackageName(),
expr.cpp:                               left_type -> ExternalName());
expr.cpp:            expr -> symbol = control.no_type;
expr.cpp:                               expr -> right_expression,
expr.cpp:                               right_type -> ContainingPackageName(),
expr.cpp:                               right_type -> ExternalName());
expr.cpp:            expr -> symbol = control.no_type;
expr.cpp:        else expr -> symbol = control.boolean_type;
expr.cpp:        if (expr -> left_expression -> IsConstant() &&
expr.cpp:            expr -> right_expression -> IsConstant())
expr.cpp:            expr -> value = control.int_pool
expr.cpp:                .FindOrInsert((IsConstantTrue(expr -> left_expression) !=
expr.cpp:                               IsConstantTrue(expr -> right_expression))
expr.cpp:        TypeSymbol* expr_type = expr -> Type();
expr.cpp:                               expr -> left_expression,
expr.cpp:                               left_type -> ContainingPackageName(),
expr.cpp:                               left_type -> ExternalName());
expr.cpp:                               expr -> right_expression,
expr.cpp:                               right_type -> ContainingPackageName(),
expr.cpp:                               right_type -> ExternalName());
expr.cpp:            expr -> symbol = control.no_type;
expr.cpp:        if (expr -> left_expression -> IsConstant() &&
expr.cpp:            expr -> right_expression -> IsConstant())
expr.cpp:                    (expr -> left_expression -> value);
expr.cpp:                    (expr -> right_expression -> value);
expr.cpp:                expr -> value = control.long_pool.FindOrInsert(left -> value ^
expr.cpp:                                                               right -> value);
expr.cpp:                    (expr -> left_expression -> value);
expr.cpp:                    (expr -> right_expression -> value);
expr.cpp:                expr -> value = control.int_pool.FindOrInsert(left -> value ^
expr.cpp:                                                              right -> value);
expr.cpp:    ProcessExpression(expr -> left_expression);
expr.cpp:    ProcessExpression(expr -> right_expression);
expr.cpp:    TypeSymbol* left_type = expr -> left_expression -> Type();
expr.cpp:    TypeSymbol* right_type = expr -> right_expression -> Type();
expr.cpp:                               expr -> left_expression,
expr.cpp:                               left_type -> ContainingPackageName(),
expr.cpp:                               left_type -> ExternalName());
expr.cpp:            expr -> symbol = control.no_type;
expr.cpp:                               expr -> right_expression,
expr.cpp:                               right_type -> ContainingPackageName(),
expr.cpp:                               right_type -> ExternalName());
expr.cpp:            expr -> symbol = control.no_type;
expr.cpp:        else expr -> symbol = control.boolean_type;
expr.cpp:        if (expr -> left_expression -> IsConstant() &&
expr.cpp:            expr -> right_expression -> IsConstant())
expr.cpp:            expr -> value = control.int_pool
expr.cpp:                .FindOrInsert((IsConstantTrue(expr -> left_expression) ||
expr.cpp:                               IsConstantTrue(expr -> right_expression))
expr.cpp:        TypeSymbol* expr_type = expr -> Type();
expr.cpp:                               expr -> left_expression,
expr.cpp:                               left_type -> ContainingPackageName(),
expr.cpp:                               left_type -> ExternalName());
expr.cpp:                               expr -> right_expression,
expr.cpp:                               right_type -> ContainingPackageName(),
expr.cpp:                               right_type -> ExternalName());
expr.cpp:            expr -> symbol = control.no_type;
expr.cpp:        if (expr -> left_expression -> IsConstant() &&
expr.cpp:            expr -> right_expression -> IsConstant())
expr.cpp:                    (expr -> left_expression -> value);
expr.cpp:                    (expr -> right_expression -> value);
expr.cpp:                expr -> value = control.long_pool.FindOrInsert(left -> value |
expr.cpp:                                                               right -> value);
expr.cpp:                    (expr -> left_expression -> value);
expr.cpp:                    (expr -> right_expression -> value);
expr.cpp:                expr -> value = control.int_pool.FindOrInsert(left -> value |
expr.cpp:                                                              right -> value);
expr.cpp:    ProcessExpression(expr -> left_expression);
expr.cpp:    ProcessExpression(expr -> right_expression);
expr.cpp:    TypeSymbol* left_type = expr -> left_expression -> Type();
expr.cpp:    TypeSymbol* right_type = expr -> right_expression -> Type();
expr.cpp:                           expr -> left_expression,
expr.cpp:                           left_type -> ContainingPackageName(),
expr.cpp:                           left_type -> ExternalName());
expr.cpp:        expr -> symbol = control.no_type;
expr.cpp:                           expr -> right_expression,
expr.cpp:                           right_type -> ContainingPackageName(),
expr.cpp:                           right_type -> ExternalName());
expr.cpp:        expr -> symbol = control.no_type;
expr.cpp:    if (expr -> left_expression -> IsConstant() &&
expr.cpp:        expr -> right_expression -> IsConstant())
expr.cpp:        expr -> value = control.int_pool.
expr.cpp:            FindOrInsert((IsConstantTrue(expr -> left_expression) &&
expr.cpp:                          IsConstantTrue(expr -> right_expression))
expr.cpp:    if (expr -> symbol != control.no_type)
expr.cpp:        expr -> symbol = control.boolean_type;
expr.cpp:    ProcessExpression(expr -> left_expression);
expr.cpp:    ProcessExpression(expr -> right_expression);
expr.cpp:    TypeSymbol* left_type = expr -> left_expression -> Type();
expr.cpp:    TypeSymbol* right_type = expr -> right_expression -> Type();
expr.cpp:                           expr -> left_expression,
expr.cpp:                           left_type -> ContainingPackageName(),
expr.cpp:                           left_type -> ExternalName());
expr.cpp:        expr -> symbol = control.no_type;
expr.cpp:                           expr -> right_expression,
expr.cpp:                           right_type -> ContainingPackageName(),
expr.cpp:                           right_type -> ExternalName());
expr.cpp:        expr -> symbol = control.no_type;
expr.cpp:    if (expr -> left_expression -> IsConstant() &&
expr.cpp:        expr -> right_expression -> IsConstant())
expr.cpp:        expr -> value = control.int_pool.
expr.cpp:            FindOrInsert((IsConstantTrue(expr -> left_expression) ||
expr.cpp:                          IsConstantTrue(expr -> right_expression))
expr.cpp:    if (expr -> symbol != control.no_type)
expr.cpp:        expr -> symbol = control.boolean_type;
expr.cpp:    ProcessExpressionOrStringConstant(expr -> left_expression);
expr.cpp:    ProcessExpressionOrStringConstant(expr -> right_expression);
expr.cpp:    TypeSymbol* left_type = expr -> left_expression -> Type();
expr.cpp:    TypeSymbol* right_type = expr -> right_expression -> Type();
expr.cpp:                           expr -> left_expression,
expr.cpp:                           left_type -> Name());
expr.cpp:                           expr -> right_expression,
expr.cpp:                           right_type -> Name());
expr.cpp:        expr -> symbol = control.no_type;
expr.cpp:    else if (left_type -> Primitive() && right_type -> Primitive())
expr.cpp:                               expr, left_type -> ContainingPackageName(),
expr.cpp:                               left_type -> ExternalName(),
expr.cpp:                               right_type -> ContainingPackageName(),
expr.cpp:                               right_type -> ExternalName());
expr.cpp:                expr -> symbol = control.no_type;
expr.cpp:        if (expr -> symbol != control.no_type)
expr.cpp:            expr -> symbol = control.boolean_type;
expr.cpp:                            expr -> binary_operator_token) ||
expr.cpp:               right_type -> IsSubclass(control.Object()))))
expr.cpp:        expr -> symbol = control.boolean_type;
expr.cpp:                       expr, left_type -> ContainingPackageName(),
expr.cpp:                       left_type -> ExternalName(),
expr.cpp:                       right_type -> ContainingPackageName(),
expr.cpp:                       right_type -> ExternalName());
expr.cpp:        expr -> symbol = control.no_type;
expr.cpp:    if (expr -> left_expression -> IsConstant() &&
expr.cpp:        expr -> right_expression -> IsConstant())
expr.cpp:        LiteralValue* left = expr -> left_expression -> value;
expr.cpp:        LiteralValue* right = expr -> right_expression -> value;
expr.cpp:        if (expr -> left_expression -> Type() == control.double_type)
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value ==
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:        else if (expr -> left_expression -> Type() == control.float_type)
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value ==
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:        else expr -> value =
expr.cpp:    ProcessExpressionOrStringConstant(expr -> left_expression);
expr.cpp:    ProcessExpressionOrStringConstant(expr -> right_expression);
expr.cpp:    TypeSymbol* left_type = expr -> left_expression -> Type();
expr.cpp:    TypeSymbol* right_type = expr -> right_expression -> Type();
expr.cpp:                           expr -> left_expression,
expr.cpp:                           left_type -> Name());
expr.cpp:                           expr -> right_expression,
expr.cpp:                           right_type -> Name());
expr.cpp:        expr -> symbol = control.no_type;
expr.cpp:    else if (left_type -> Primitive() && right_type -> Primitive())
expr.cpp:                               expr, left_type -> ContainingPackageName(),
expr.cpp:                               left_type -> ExternalName(),
expr.cpp:                               right_type -> ContainingPackageName(),
expr.cpp:                               right_type -> ExternalName());
expr.cpp:                expr -> symbol = control.no_type;
expr.cpp:        if (expr -> symbol != control.no_type)
expr.cpp:            expr -> symbol = control.boolean_type;
expr.cpp:                            expr -> binary_operator_token) ||
expr.cpp:               right_type -> IsSubclass(control.Object()))))
expr.cpp:        expr -> symbol = control.boolean_type;
expr.cpp:                       expr, left_type -> ContainingPackageName(),
expr.cpp:                       left_type -> ExternalName(),
expr.cpp:                       right_type -> ContainingPackageName(),
expr.cpp:                       right_type -> ExternalName());
expr.cpp:        expr -> symbol = control.no_type;
expr.cpp:    if (expr -> left_expression -> IsConstant() &&
expr.cpp:        expr -> right_expression -> IsConstant())
expr.cpp:        LiteralValue* left = expr -> left_expression -> value;
expr.cpp:        LiteralValue* right = expr -> right_expression -> value;
expr.cpp:        if (expr -> left_expression -> Type() == control.double_type)
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value !=
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:        else if (expr -> left_expression -> Type() == control.float_type)
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value !=
expr.cpp:                                              right -> value ? 1 : 0);
expr.cpp:        else expr -> value =
expr.cpp:    ProcessExpression(expr -> left_expression);
expr.cpp:    ProcessExpression(expr -> right_expression);
expr.cpp:    if (expr -> left_expression -> IsConstant() &&
expr.cpp:        expr -> right_expression -> IsConstant())
expr.cpp:        if (expr -> Type() == control.double_type)
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.double_pool.FindOrInsert(left -> value *
expr.cpp:                                                 right -> value);
expr.cpp:        else if (expr -> Type() == control.float_type)
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.float_pool.FindOrInsert(left -> value *
expr.cpp:                                                right -> value);
expr.cpp:        else if (expr -> Type() == control.long_type)
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:                                       left -> value, right -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.long_pool.FindOrInsert(left -> value *
expr.cpp:                                               right -> value);
expr.cpp:        else if (expr -> Type() == control.int_type)
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:                                       left -> value, right -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value *
expr.cpp:                                              right -> value);
expr.cpp:    ProcessExpression(expr -> left_expression);
expr.cpp:    ProcessExpression(expr -> right_expression);
expr.cpp:    if (expr -> left_expression -> IsConstant() &&
expr.cpp:        expr -> right_expression -> IsConstant())
expr.cpp:        if (expr -> Type() == control.double_type)
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.double_pool.FindOrInsert(left -> value -
expr.cpp:                                                 right -> value);
expr.cpp:        else if (expr -> Type() == control.float_type)
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.float_pool.FindOrInsert(left -> value -
expr.cpp:                                                right -> value);
expr.cpp:        else if (expr -> Type() == control.long_type)
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            CheckIntegerSubtraction(this, expr, left -> value, right -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.long_pool.FindOrInsert(left -> value -
expr.cpp:                                               right -> value);
expr.cpp:        else if (expr -> Type() == control.int_type)
expr.cpp:                (expr -> left_expression -> value);
expr.cpp:                (expr -> right_expression -> value);
expr.cpp:            CheckIntegerSubtraction(this, expr, left -> value, right -> value);
expr.cpp:            expr -> value =
expr.cpp:                control.int_pool.FindOrInsert(left -> value - right -> value);
expr.cpp:    ProcessExpression(expr -> left_expression);
expr.cpp:    ProcessExpression(expr -> right_expression);
expr.cpp:    AstExpression* left_expression = expr -> left_expression;
expr.cpp:    AstExpression* right_expression = expr -> right_expression;
expr.cpp:    if (right_expression -> IsConstant())
expr.cpp:        // If the type of the expression is int or long and the right-hand
expr.cpp:        if ((expr -> Type() == control.int_type &&
expr.cpp:             DYNAMIC_CAST<IntLiteralValue*> (right_expression -> value) -> value == 0) ||
expr.cpp:            (expr -> Type() == control.long_type &&
expr.cpp:             DYNAMIC_CAST<LongLiteralValue*> (right_expression -> value) -> value == 0))
expr.cpp:        else if (left_expression -> IsConstant())
expr.cpp:            if (expr -> Type() == control.double_type)
expr.cpp:                    (left_expression -> value);
expr.cpp:                    (right_expression -> value);
expr.cpp:                expr -> value =
expr.cpp:                    control.double_pool.FindOrInsert(left -> value /
expr.cpp:                                                     right -> value);
expr.cpp:            else if (expr -> Type() == control.float_type)
expr.cpp:                    (left_expression -> value);
expr.cpp:                    (right_expression -> value);
expr.cpp:                expr -> value =
expr.cpp:                    control.float_pool.FindOrInsert(left -> value /
expr.cpp:                                                    right -> value);
expr.cpp:            else if (expr -> Type() == control.long_type)
expr.cpp:                    (left_expression -> value);
expr.cpp:                    (right_expression -> value);
expr.cpp:                CheckIntegerDivision(this, expr, left -> value,
expr.cpp:                                     right -> value);
expr.cpp:                expr -> value =
expr.cpp:                    control.long_pool.FindOrInsert(left -> value /
expr.cpp:                                                   right -> value);
expr.cpp:            else if (expr -> Type() == control.int_type)
expr.cpp:                    (left_expression -> value);
expr.cpp:                    (right_expression -> value);
expr.cpp:                CheckIntegerDivision(this, expr, left -> value,
expr.cpp:                                     right -> value);
expr.cpp:                // to compute ((2**32-1) / -1), he gets a ZeroDivide
expr.cpp:                // code below, we use the short-circuited one that follows:
expr.cpp:                //  expr -> value = control.int_pool
expr.cpp:                //      .FindOrInsert(left -> value / right -> value);
expr.cpp:                expr -> value = control.int_pool
expr.cpp:                    .FindOrInsert(right -> value == -1
expr.cpp:                                  ? -(left -> value)
expr.cpp:                                  : left -> value / right -> value);
expr.cpp:    ProcessExpression(expr -> left_expression);
expr.cpp:    ProcessExpression(expr -> right_expression);
expr.cpp:    AstExpression* left_expression = expr -> left_expression;
expr.cpp:    AstExpression* right_expression = expr -> right_expression;
expr.cpp:    if (right_expression -> IsConstant())
expr.cpp:        // If the type of the expression is int or long and the right-hand
expr.cpp:        if ((expr -> Type() == control.int_type &&
expr.cpp:             DYNAMIC_CAST<IntLiteralValue*> (right_expression -> value) -> value == 0) ||
expr.cpp:            (expr -> Type() == control.long_type &&
expr.cpp:             DYNAMIC_CAST<LongLiteralValue*> (right_expression -> value) -> value == 0))
expr.cpp:        else if (left_expression -> IsConstant())
expr.cpp:            if (expr -> Type() == control.double_type)
expr.cpp:                    (left_expression -> value);
expr.cpp:                    (right_expression -> value);
expr.cpp:                expr -> value =
expr.cpp:                    control.double_pool.FindOrInsert(left -> value %
expr.cpp:                                                     right -> value);
expr.cpp:            else if (expr -> Type() == control.float_type)
expr.cpp:                    (left_expression -> value);
expr.cpp:                    (right_expression -> value);
expr.cpp:                expr -> value =
expr.cpp:                    control.float_pool.FindOrInsert(left -> value %
expr.cpp:                                                    right -> value);
expr.cpp:            else if (expr -> Type() == control.long_type)
expr.cpp:                    (left_expression -> value);
expr.cpp:                    (right_expression -> value);
expr.cpp:                expr -> value =
expr.cpp:                    control.long_pool.FindOrInsert(left -> value %
expr.cpp:                                                   right -> value);
expr.cpp:            else if (expr -> Type() == control.int_type)
expr.cpp:                    (left_expression -> value);
expr.cpp:                    (right_expression -> value);
expr.cpp:                // to compute ((2**32-1) / -1), he gets a ZeroDivide
expr.cpp:                // code below, we use the short-circuited one that follows:
expr.cpp:                // expr -> value = control.int_pool
expr.cpp:                //     .FindOrInsert(left -> value % right -> value);
expr.cpp:                expr -> value = control.int_pool
expr.cpp:                    .FindOrInsert((left -> value  == (signed) 0x80000000 &&
expr.cpp:                                   right -> value == (signed) 0xffffffff)
expr.cpp:                                  ? 0 : left -> value % right -> value);
expr.cpp:    (this ->* ProcessBinaryExpr[binary_expression -> Tag()])
expr.cpp:    ProcessExpressionOrStringConstant(instanceof -> expression);
expr.cpp:    ProcessType(instanceof -> type);
expr.cpp:    TypeSymbol* left_type = instanceof -> expression -> Type();
expr.cpp:    TypeSymbol* right_type = instanceof -> type -> symbol;
expr.cpp:    if (left_type -> Primitive())
expr.cpp:                       instanceof -> expression,
expr.cpp:                       left_type -> Name());
expr.cpp:        instanceof -> symbol = control.no_type;
expr.cpp:                              instanceof -> instanceof_token))
expr.cpp:                       expr, left_type -> ContainingPackageName(),
expr.cpp:                       left_type -> ExternalName(),
expr.cpp:                       right_type -> ContainingPackageName(),
expr.cpp:                       right_type -> ExternalName());
expr.cpp:        instanceof -> symbol = control.no_type;
expr.cpp:    else instanceof -> symbol = control.boolean_type;
expr.cpp:    ProcessExpression(conditional_expression -> test_expression);
expr.cpp:    ProcessExpressionOrStringConstant(conditional_expression ->
expr.cpp:    ProcessExpressionOrStringConstant(conditional_expression ->
expr.cpp:        conditional_expression -> test_expression -> Type();
expr.cpp:        conditional_expression -> true_expression -> Type();
expr.cpp:        conditional_expression -> false_expression -> Type();
expr.cpp:                           conditional_expression -> test_expression,
expr.cpp:                           test_type -> ContainingPackageName(),
expr.cpp:                           test_type -> ExternalName());
expr.cpp:        conditional_expression -> symbol = control.no_type;
expr.cpp:                       conditional_expression -> true_expression,
expr.cpp:                       true_type -> Name());
expr.cpp:                       conditional_expression -> false_expression,
expr.cpp:                       false_type -> Name());
expr.cpp:        conditional_expression -> symbol = control.no_type;
expr.cpp:    else if (true_type -> Primitive())
expr.cpp:        if (! false_type -> Primitive() ||
expr.cpp:                           conditional_expression -> true_expression -> LeftToken(),
expr.cpp:                           conditional_expression -> false_expression -> RightToken(),
expr.cpp:                           true_type -> ContainingPackageName(),
expr.cpp:                           true_type -> ExternalName(),
expr.cpp:                           false_type -> ContainingPackageName(),
expr.cpp:                           false_type -> ExternalName());
expr.cpp:            conditional_expression -> symbol = control.no_type;
expr.cpp:                if (conditional_expression -> symbol != control.no_type)
expr.cpp:                    conditional_expression -> symbol = true_type;
expr.cpp:                    conditional_expression -> true_expression =
expr.cpp:                        ConvertToType(conditional_expression -> true_expression,
expr.cpp:                    conditional_expression -> symbol = control.short_type;
expr.cpp:                    conditional_expression -> false_expression =
expr.cpp:                        ConvertToType(conditional_expression -> false_expression,
expr.cpp:                    conditional_expression -> symbol = control.short_type;
expr.cpp:                         IsIntValueRepresentableInType(conditional_expression -> true_expression,
expr.cpp:                    conditional_expression -> true_expression =
expr.cpp:                        ConvertToType(conditional_expression -> true_expression,
expr.cpp:                    conditional_expression -> symbol = false_type;
expr.cpp:                         IsIntValueRepresentableInType(conditional_expression -> false_expression,
expr.cpp:                    conditional_expression -> false_expression =
expr.cpp:                        ConvertToType(conditional_expression -> false_expression,
expr.cpp:                    conditional_expression -> symbol = true_type;
expr.cpp:            if (conditional_expression -> true_expression -> IsConstant() &&
expr.cpp:                conditional_expression -> false_expression -> IsConstant())
expr.cpp:                if (IsConstantTrue(conditional_expression -> test_expression))
expr.cpp:                    conditional_expression -> value =
expr.cpp:                        conditional_expression -> true_expression -> value;
expr.cpp:                else if (IsConstantFalse(conditional_expression -> test_expression))
expr.cpp:                    conditional_expression -> value =
expr.cpp:                        conditional_expression -> false_expression -> value;
expr.cpp:                                 conditional_expression -> true_expression))
expr.cpp:            conditional_expression -> true_expression =
expr.cpp:                ConvertToType(conditional_expression -> true_expression,
expr.cpp:            conditional_expression -> symbol = false_type;
expr.cpp:                                      conditional_expression -> false_expression))
expr.cpp:            conditional_expression -> false_expression =
expr.cpp:                ConvertToType(conditional_expression -> false_expression,
expr.cpp:            conditional_expression -> symbol = true_type;
expr.cpp:                           conditional_expression -> true_expression -> LeftToken(),
expr.cpp:                           conditional_expression -> false_expression -> RightToken(),
expr.cpp:                           true_type -> ContainingPackageName(),
expr.cpp:                           true_type -> ExternalName(),
expr.cpp:                           false_type -> ContainingPackageName(),
expr.cpp:                           false_type -> ExternalName());
expr.cpp:            conditional_expression -> symbol = control.no_type;
expr.cpp:        // Since null should not be a compile-time constant, the assert
expr.cpp:        if (conditional_expression -> true_expression -> IsConstant() &&
expr.cpp:            conditional_expression -> false_expression -> IsConstant())
expr.cpp:            assert(conditional_expression -> symbol == control.String() ||
expr.cpp:                   conditional_expression -> symbol == control.no_type);
expr.cpp:            if (IsConstantTrue(conditional_expression -> test_expression))
expr.cpp:                conditional_expression -> value =
expr.cpp:                    conditional_expression -> true_expression -> value;
expr.cpp:            else if (IsConstantFalse(conditional_expression -> test_expression))
expr.cpp:                conditional_expression -> value =
expr.cpp:                    conditional_expression -> false_expression -> value;
expr.cpp:    ProcessExpressionOrStringConstant(assignment_expression -> expression);
expr.cpp:    AstExpression* left_hand_side = assignment_expression -> left_hand_side;
expr.cpp:    // ambiguities, and we must filter out invalid left-hand sides.
expr.cpp:    if (left_hand_side -> ParenthesizedExpressionCast())
expr.cpp:        while (left_hand_side -> ParenthesizedExpressionCast())
expr.cpp:            left_hand_side = ((AstParenthesizedExpression*) left_hand_side) ->
expr.cpp:    if ((assignment_expression -> Tag() ==
expr.cpp:        left_hand_side -> NameCast() &&
expr.cpp:        ! left_hand_side -> NameCast() -> base_opt)
expr.cpp:    if (! left_hand_side -> IsLeftHandSide())
expr.cpp:        left_hand_side -> symbol = control.no_type;
expr.cpp:        assignment_expression -> symbol = control.no_type;
expr.cpp:    TypeSymbol* left_type = left_hand_side -> Type();
expr.cpp:    TypeSymbol* right_type = assignment_expression -> expression -> Type();
expr.cpp:                           assignment_expression -> expression,
expr.cpp:                           right_type -> Name());
expr.cpp:        assignment_expression -> symbol = control.no_type;
expr.cpp:    assignment_expression -> symbol = left_type;
expr.cpp:    if (! left_hand_side -> ArrayAccessCast()) // the left-hand-side is a name
expr.cpp:        AstName* name = left_hand_side -> NameCast();
expr.cpp:        AstFieldAccess* field_access = left_hand_side -> FieldAccessCast();
expr.cpp:            if (name -> resolution_opt)
expr.cpp:                    name -> resolution_opt -> symbol -> MethodCast();
expr.cpp:            if (field_access -> resolution_opt)
expr.cpp:                    field_access -> resolution_opt -> symbol -> MethodCast();
expr.cpp:            assignment_expression -> write_method = read_method ->
expr.cpp:                containing_type -> GetWriteAccessFromReadAccess(read_method);
expr.cpp:    if (assignment_expression -> Tag() ==
expr.cpp:                                     assignment_expression -> expression))
expr.cpp:                assignment_expression -> expression =
expr.cpp:                    ConvertToType(assignment_expression -> expression,
expr.cpp:            else if (assignment_expression -> expression -> IsConstant() &&
expr.cpp:                                   assignment_expression -> expression);
expr.cpp:                                   assignment_expression -> expression);
expr.cpp:                                   assignment_expression -> expression);
expr.cpp:                assignment_expression -> symbol = control.no_type;
expr.cpp:                               left_type -> ContainingPackageName(),
expr.cpp:                               left_type -> ExternalName(),
expr.cpp:                               right_type -> ContainingPackageName(),
expr.cpp:                               right_type -> ExternalName());
expr.cpp:                assignment_expression -> symbol = control.no_type;
expr.cpp:        (assignment_expression -> Tag() ==
expr.cpp:                                assignment_expression -> expression);
expr.cpp:                 assignment_expression -> symbol = control.no_type;
expr.cpp:                assignment_expression -> expression -> value =
expr.cpp:                              assignment_expression -> expression);
expr.cpp:                if (assignment_expression -> expression -> IsConstant())
expr.cpp:                    assignment_expression -> expression -> symbol =
expr.cpp:    switch (assignment_expression -> Tag())
expr.cpp:                    assignment_expression -> expression;
expr.cpp:                if (right_expression -> IsConstant())
expr.cpp:                    if ((right_expression -> Type() == control.int_type &&
expr.cpp:                         (right_expression -> value) -> value == 0) ||
expr.cpp:                        (right_expression -> Type() == control.long_type &&
expr.cpp:                         (right_expression -> value) -> value == 0))
expr.cpp:            assignment_expression -> left_hand_side
expr.cpp:                if (assignment_expression -> left_hand_side -> symbol !=
expr.cpp:                                   assignment_expression -> left_hand_side,
expr.cpp:                                   left_type -> ContainingPackageName(),
expr.cpp:                                   left_type -> ExternalName());
expr.cpp:                assignment_expression -> symbol = control.no_type;
expr.cpp:                               assignment_expression -> expression,
expr.cpp:                               right_type -> ContainingPackageName(),
expr.cpp:                               right_type -> ExternalName());
expr.cpp:                assignment_expression -> symbol = control.no_type;
expr.cpp:            assignment_expression -> expression =
expr.cpp:                ConvertToType(assignment_expression -> expression,
expr.cpp:            ProcessShiftCount(left_type, assignment_expression -> expression);
expr.cpp:                                   assignment_expression -> expression,
expr.cpp:                                   right_type -> ContainingPackageName(),
expr.cpp:                                   right_type -> ExternalName());
expr.cpp:                    assignment_expression -> symbol = control.no_type;
expr.cpp:                                   left_type -> ContainingPackageName(),
expr.cpp:                                   left_type -> ExternalName());
expr.cpp:                    assignment_expression -> symbol = control.no_type;
expr.cpp:                                   assignment_expression -> expression,
expr.cpp:                                   right_type -> ContainingPackageName(),
expr.cpp:                                   right_type -> ExternalName());
expr.cpp:                    assignment_expression -> symbol = control.no_type;
Binary file expr.o matches
gencode.java:                numElements--;
gencode.java:            for (int j = blkSize - 1; j > 0; j--)
gencode.java:                    String tail = str.substring(str.length() - j);
gencode.java:                        blockLen -= j;
gencode.java:                        blkNum--;
gencode.java:                            String tail = merge.substring(merge.length() - j);
gencode.java:            int estimate = blockLen + (info.length >> (i - 1));
gencode.java:            assert index != -1 : "Unexpected index for " + j;
gencode.java:            blocks[j >> bestShift] = (char) (index - j);
gencode.java:        hfile.println("    // with some self-explanatory functions defined on CODE.");
gencode.java:        hfile.println("        return (hi << 10) + lo + (0x10000 - (0xd800 << 10) - 0xdc00);");
gencode.java:        hfile.println("        return c - (c <= U_9 ? U_0 : c < U_a ? U_A - 10 : U_a - 10);");
gencode.java:        file.println("// $I" + /* CVS hack */ "d$ -*- c++ -*-");
gencode.java:        file.println("// DO NOT MODIFY THIS FILE - it is generated using gencode.java.");
incrmnt.cpp:        for (parent = (TypeSymbol*) type -> static_parents -> FirstElement();
incrmnt.cpp:             parent = (TypeSymbol*) type -> static_parents -> NextElement())
incrmnt.cpp:                parent -> dependents -> RemoveElement(type);
incrmnt.cpp:                parent -> subtypes -> RemoveElement(type);
incrmnt.cpp:        for (parent = (TypeSymbol*) type -> parents -> FirstElement();
incrmnt.cpp:             parent = (TypeSymbol*) type -> parents -> NextElement())
incrmnt.cpp:                parent -> dependents -> RemoveElement(type);
incrmnt.cpp:                parent -> subtypes -> RemoveElement(type);
incrmnt.cpp:        PackageSymbol* package = type -> ContainingPackage();
incrmnt.cpp:        FileSymbol* file_symbol = type -> file_symbol;
incrmnt.cpp:        if (file_symbol && type -> Identity() == file_symbol -> Identity())
incrmnt.cpp:        package -> DeleteTypeSymbol(type);
incrmnt.cpp:        = file_symbol -> Utf8NameLength() + FileSymbol::java_suffix_length;
incrmnt.cpp:    strcpy(java_name, file_symbol -> Utf8Name());
incrmnt.cpp:        = file_symbol -> directory_symbol -> FindEntry(java_name, length);
incrmnt.cpp:        if ((! file_symbol -> IsZip()) &&
incrmnt.cpp:                if (file_symbol -> IsJava())
incrmnt.cpp:            else if (java_entry -> Mtime() > file_symbol -> mtime)
incrmnt.cpp:                file_symbol -> mtime = java_entry -> Mtime();
incrmnt.cpp:    directory_symbol -> ResetDirectory();
incrmnt.cpp:    for (unsigned i = 0; i < directory_symbol -> subdirectories.Length(); i++)
incrmnt.cpp:        RereadDirectory(directory_symbol -> subdirectories[i]);
incrmnt.cpp:        if (! path_symbol -> IsZip())
incrmnt.cpp:            RereadDirectory(path_symbol -> RootDirectory());
incrmnt.cpp:        for (unsigned i = 0; i < file_symbol -> types.Length(); i++)
incrmnt.cpp:            input_types.Next() = file_symbol -> types[i];
incrmnt.cpp:            if (type -> dependents_closure)
incrmnt.cpp:                 dependents_closure.Union(*type -> dependents_closure);
incrmnt.cpp:            for (unsigned i = 0; i < file_symbol -> types.Length(); i++)
incrmnt.cpp:                TypeSymbol* type = file_symbol -> types[i];
incrmnt.cpp:                    if (type -> dependents_closure)
incrmnt.cpp:                        dependents_closure.Union(*type -> dependents_closure);
incrmnt.cpp:                file_symbol -> Reset();
incrmnt.cpp:                file_symbol -> SetJava();
incrmnt.cpp:                scanner -> Scan(file_symbol);
incrmnt.cpp:                LexStream* lex_stream = file_symbol -> lex_stream;
incrmnt.cpp:                        = parser -> PackageHeaderParse(lex_stream, ast_pool);
incrmnt.cpp:                                                 package_declaration -> name)
incrmnt.cpp:                    ast_pool -> Reset();
incrmnt.cpp:                    for (unsigned k = 0; k < lex_stream -> NumTypes(); k++)
incrmnt.cpp:                            = lex_stream -> Next(lex_stream -> Type(k));
incrmnt.cpp:                            lex_stream -> NameSymbol(identifier_token);
incrmnt.cpp:                                = package -> FindTypeSymbol(name_symbol);
incrmnt.cpp:                                if (type -> dependents_closure)
incrmnt.cpp:                                    dependents_closure.Union(*type -> dependents_closure);
incrmnt.cpp:            FileSymbol* file_symbol = type -> file_symbol;
incrmnt.cpp:                file_symbol -> mtime = 0; // to force a reread of the file.
incrmnt.cpp:        input_types[j] -> RemoveCompilationReferences();
incrmnt.cpp:        type -> index = TypeCycleChecker::OMEGA;
incrmnt.cpp:        type -> unit_index = TypeCycleChecker::OMEGA;
incrmnt.cpp:        type -> incremental_index = TypeCycleChecker::OMEGA;
incrmnt.cpp:        delete type -> dependents_closure;
incrmnt.cpp:        type -> dependents_closure = NULL;
Binary file incrmnt.o matches
init.cpp:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $
init.cpp:    VariableSymbol* symbol = variable_declarator -> symbol;
init.cpp:    if (! variable_declarator -> variable_initializer_opt)
init.cpp:        symbol -> MarkInitialized();
init.cpp:    TypeSymbol* field_type = symbol -> Type();
init.cpp:        (AstExpression*) variable_declarator -> variable_initializer_opt;
init.cpp:    AstArrayInitializer* array_initializer = init -> ArrayInitializerCast();
init.cpp:        if (field_type != init -> Type() && init -> Type() != control.no_type)
init.cpp:                variable_declarator -> variable_initializer_opt = init;
init.cpp:            else if (init -> IsConstant() &&
init.cpp:                     control.IsSimpleIntegerValueType(init -> Type()) &&
init.cpp:                init -> value = NULL;
init.cpp:                               field_type -> ContainingPackageName(),
init.cpp:                               field_type -> ExternalName(),
init.cpp:                               init -> Type() -> ContainingPackageName(),
init.cpp:                               init -> Type() -> ExternalName());
init.cpp:                init -> value = NULL;
init.cpp:        if (symbol -> ACC_FINAL() &&
init.cpp:            (field_type -> Primitive() || field_type == control.String()))
init.cpp:            if (init -> IsConstant())
init.cpp:                symbol -> initial_value = init -> value;
init.cpp:            else if (symbol -> ACC_STATIC() && ThisType() -> IsInner())
init.cpp:                               lex_stream -> NameString(variable_declarator -> LeftToken()),
init.cpp:                               ThisType() -> Name(), ThisType() -> FileLoc());
init.cpp:    // A non-static final field initialized to a constant value wastes
init.cpp:    TypeSymbol* containing_type = symbol -> owner -> TypeCast();
init.cpp:    if (containing_type && ! containing_type -> ACC_INTERFACE() &&
init.cpp:        ! field_type -> IsArray() &&
init.cpp:        symbol -> ACC_FINAL() &&
init.cpp:        ! symbol -> ACC_STATIC() &&
init.cpp:        init && init -> IsConstant())
init.cpp:                       lex_stream ->
init.cpp:                           NameString(variable_declarator -> LeftToken()));
init.cpp:    symbol -> MarkInitialized();
init.cpp:    if (! type -> IsArray())
init.cpp:                       array_initializer, type -> Name());
init.cpp:             i < array_initializer -> NumVariableInitializers(); i++)
init.cpp:            AstArrayInitializer* sub_array_initializer = array_initializer ->
init.cpp:                VariableInitializer(i) -> ArrayInitializerCast();
init.cpp:            TypeSymbol* array_subtype = type -> ArraySubtype();
init.cpp:                AstExpression* init = (AstExpression*) array_initializer ->
init.cpp:                if (array_subtype != init -> Type())
init.cpp:                        array_initializer -> VariableInitializer(i) =
init.cpp:                    else if (array_subtype -> IsArray() &&
init.cpp:                             init -> Type() -> Primitive())
init.cpp:                                       init, array_subtype -> Name());
init.cpp:                    else if (init -> IsConstant() &&
init.cpp:                             control.IsSimpleIntegerValueType(init -> Type()) &&
init.cpp:                                       array_subtype -> ContainingPackageName(),
init.cpp:                                       array_subtype -> ExternalName(),
init.cpp:                                       init -> Type() -> ContainingPackageName(),
init.cpp:                                       init -> Type() -> ExternalName());
init.cpp:    AstVariableDeclarator* variable_declarator = variable -> declarator;
init.cpp:    assert(variable_declarator && variable -> ACC_FINAL());
init.cpp:    if (! variable -> IsInitialized())
init.cpp:        if (variable_declarator -> pending ||
init.cpp:            ! variable_declarator -> variable_initializer_opt)
init.cpp:            // Break loops, and ignore non-initialized fields.
init.cpp:            variable -> MarkInitialized();
init.cpp:        TypeSymbol* type = variable -> ContainingType();
init.cpp:        Semantic* sem = type -> semantic_environment -> sem;
init.cpp:        if (! sem -> error)
init.cpp:            sem -> error =
init.cpp:                new SemanticError(control, sem -> source_file_symbol);
init.cpp:        sem -> error -> EnteringClone();
init.cpp:        sem -> state_stack.Push(type -> semantic_environment);
init.cpp:        MethodSymbol* calling_method = sem -> ThisMethod();
init.cpp:        VariableSymbol* calling_var = sem -> ThisVariable();
init.cpp:        sem -> ThisMethod() = NULL;
init.cpp:        sem -> ThisVariable() = variable;
init.cpp:        variable_declarator -> pending = true;
init.cpp:        StoragePool pool(variable_declarator -> RightToken() -
init.cpp:                         variable_declarator -> LeftToken());
init.cpp:            variable_declarator -> Clone(&pool);
init.cpp:        clone -> symbol = variable;
init.cpp:        sem -> ProcessVariableInitializer(clone);
init.cpp:        assert(variable -> IsInitialized());
init.cpp:        variable_declarator -> pending = false;
init.cpp:        sem -> ThisMethod() = calling_method;
init.cpp:        sem -> ThisVariable() = calling_var;
init.cpp:        sem -> state_stack.Pop();
init.cpp:        sem -> error -> ExitingClone();
Binary file init.o matches
java.g:%options fp=java,escape=$,prefix=TK_,em,defer,output-size=125
java.g:%options hblockb=\:,hblocke=:\,nogoto-default,single-productions
java.g:-- $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $
java.g:-- This software is subject to the terms of the IBM Jikes Compiler
java.g:-- License Agreement available at the following URL:
java.g:-- http://ibm.com/developerworks/opensource/jikes.
java.g:-- Copyright (C) 1996, 2004 IBM Corporation and others.  All Rights Reserved.
java.g:-- You must accept the terms of that agreement to use this software.
java.g:------------------------------------------------------------------------
java.g:--
java.g:--                               J A V A
java.g:--
java.g:-- This Java grammar started from the grammar defined in chapter 19 of the
java.g:-- first edition of the Java Language Specification manual.  It has since been
java.g:-- updated with several additional rules to cover additional language features,
java.g:-- as well as simplified in places where it makes sense to share code. Comments
java.g:-- are given where this grammar differs from the original. Note that the
java.g:-- second edition JLS grammar (chapter 18) is completely broken.  This grammar
java.g:-- is in JIKES PG format with semantic actions following each rule. In
java.g:-- specifying the rules, the symbols are enclosed in single quotes, and the
java.g:-- keywords are all caps, so that they can be quickly distinguished from
java.g:-- non-terminals. Optional symbols are suffixed with "opt" and the rules
java.g:-- expanding such definitions can be found at the end. Also, some syntactic
java.g:-- markers have been added to aid the parser in skipping irrelevant
java.g:-- components during different parse phases.
java.g:--
java.g:-- The file javaact.h produced by JIKESPG from this file (java.g) contains a
java.g:-- very readable definition of the grammar rules together with their
java.g:-- associated semantic actions. That file is marked with appropriate
java.g:-- location directives (automatically generated) which instructs the C++
java.g:-- compiler to issue error messages in terms of this file (java.g).
java.g:-- Therefore, though the user is encouraged to read javaact.h, no
java.g:-- change should ever be made to that file. Instead, changes should
java.g:-- always be made in this file and javaact.h should be regenerated
java.g:-- using JIKESPG.
java.g:--
java.g:------------------------------------------------------------------------
java.g:--
java.g:-- This macro generates a header for an action function consisting
java.g:-- of the rule in question (commented) and a location directive.
java.g:--
java.g:--
java.g:-- This macro is used to initialize the rule_action array
java.g:-- to an unnamed function. A name is generated using the
java.g:-- number of the rule in question.
java.g:--
java.g:--
java.g:-- These macros are used to initialize the rule_action array
java.g:-- to a specific named function.
java.g:--
java.g:--
java.g:-- This macro is used to initialize the rule_action array
java.g:-- to the NullAction function.
java.g:--
java.g:--
java.g:-- This macro is used to initialize the rule_action array
java.g:-- to the NoAction function.
java.g:--
java.g:--
java.g:-- This macro generates a header for a named action function that is
java.g:-- already defined and will be shared.
java.g:--
java.g:--
java.g:-- This macro generates a header for a rule that invokes the
java.g:-- no_function routine.
java.g:--
java.g:--
java.g:-- This macro generates a header for a rule that invokes the
java.g:-- null_function routine.
java.g:--
java.g:--
java.g:-- This macro generates a header for a rule that invokes the
java.g:-- StartList routine.
java.g:--
java.g:--
java.g:-- This macro generates a header for a rule that invokes the
java.g:-- AddList2 routine.
java.g:--
java.g:--
java.g:-- This macro generates a header for a rule that invokes the
java.g:-- AddList3 routine.
java.g:--
java.g:--
java.g:-- This macro generates a header for MakePreUnaryExpression.
java.g:--
java.g:--
java.g:-- This macro generates a header for MakeBinaryExpression.
java.g:--
java.g:-- This is a special token that allows us to do a 2-pass parse.
java.g:-- These tokens will be used in JDK 1.5, but are not used now.
java.g:-- These remaining tokens are not used in the grammar.
java.g:    '--'   ::= MINUS_MINUS
java.g:    '-='   ::= MINUS_EQUAL
java.g:    '-'    ::= MINUS
java.g:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
java.g:// DO NOT MODIFY THIS FILE - it is generated using jikespg on java.g.
java.g:// DO NOT MODIFY THIS FILE - it is generated using jikespg on java.g.
java.g:--18.2 Productions from 2.3: The syntactic Grammar
java.g:// Do nothing - Whatever Ast was produced for x1 is inherited by A.
java.g:// parse from accepting a body as a valid input - i.e., to recognize a body
java.g:// out-of-context, the BodyMarker terminal must be inserted in front of the
java.g:--18.3 Productions from 3: Lexical Structure
java.g:    Sym(1) = ast_pool -> NewIntegerLiteral(Token(1));
java.g:    Sym(1) = ast_pool -> NewLongLiteral(Token(1));
java.g:    Sym(1) = ast_pool -> NewFloatLiteral(Token(1));
java.g:    Sym(1) = ast_pool -> NewDoubleLiteral(Token(1));
java.g:    Sym(1) = ast_pool -> NewCharacterLiteral(Token(1));
java.g:    Sym(1) = ast_pool -> NewStringLiteral(Token(1));
java.g:    Sym(1) = ast_pool -> NewNullLiteral(Token(1));
java.g:    Sym(1) = ast_pool -> NewTrueLiteral(Token(1));
java.g:    Sym(1) = ast_pool -> NewFalseLiteral(Token(1));
java.g:--18.4 Productions from 4: Types, Values and Variables
java.g:    Sym(1) = ast_pool -> NewPrimitiveType(Ast::BOOLEAN, Token(1));
java.g:    Sym(1) = ast_pool -> NewPrimitiveType(Ast::BYTE, Token(1));
java.g:    Sym(1) = ast_pool -> NewPrimitiveType(Ast::SHORT, Token(1));
java.g:    Sym(1) = ast_pool -> NewPrimitiveType(Ast::INT, Token(1));
java.g:    Sym(1) = ast_pool -> NewPrimitiveType(Ast::LONG, Token(1));
java.g:    Sym(1) = ast_pool -> NewPrimitiveType(Ast::CHAR, Token(1));
java.g:    Sym(1) = ast_pool -> NewPrimitiveType(Ast::FLOAT, Token(1));
java.g:    Sym(1) = ast_pool -> NewPrimitiveType(Ast::DOUBLE, Token(1));
java.g:--
java.g:-- Added rule to make parsing 'void' easier.
java.g:--
java.g:    Sym(1) = ast_pool -> NewPrimitiveType(Ast::VOID_TYPE, Token(1));
java.g:--
java.g:-- Simplify.
java.g:--
java.g:--ClassOrInterfaceType ::= ClassType
java.g:--ClassOrInterfaceType ::= InterfaceType
java.g:--ClassType ::= Name
java.g:--InterfaceType ::= Name
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:-- Use of Marker allows us to easily find the closing '>'.
java.g:--
java.g:    AstTypeName* p = Sym(tokennum) -> NameCast()
java.g:        ? ast_pool -> NewTypeName(DYNAMIC_CAST<AstName*> (Sym(tokennum)))
java.g:        ast_pool -> NewTypeArguments(Token(tokennum + 1),
java.g:                                     Token(tokennum + 3) - 1);
java.g:    q -> AllocateTypeArguments(tail -> index + 1);
java.g:        root = root -> next;
java.g:        q -> AddTypeArgument(DYNAMIC_CAST<AstType*> (root -> element));
java.g:    p -> type_arguments_opt = q;
java.g:    AstTypeName* p = ast_pool -> NewTypeName(DYNAMIC_CAST<AstName*> (Sym(1)));
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:    AstTypeName* p = ast_pool -> NewTypeName(DYNAMIC_CAST<AstName*> (Sym(5)));
java.g:    p -> base_opt = MakeTypeArguments(1);
java.g:--
java.g:-- These rules have been rewritten to avoid some conflicts introduced
java.g:-- by adding the 1.1 features, and to simplify syntax tree generation.
java.g:--
java.g:-- JLS1 lists:
java.g:--ArrayType ::= PrimitiveType '[' ']'
java.g:--ArrayType ::= Name '[' ']'
java.g:--ArrayType ::= ArrayType '[' ']'
java.g:-- JLS2 lists:
java.g:--ArrayType ::= Type '[' ']'
java.g:--
java.g:    AstType* p = Sym(tokennum) -> NameCast()
java.g:        ? ast_pool -> NewTypeName(DYNAMIC_CAST<AstName*> (Sym(tokennum)))
java.g:        : ast_pool -> NewArrayType(p, (DYNAMIC_CAST<AstBrackets*>
java.g:--ArrayType ::= ClassOrInterfaceType Dims
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:    AstTypeName* p = ast_pool -> NewTypeName(DYNAMIC_CAST<AstName*> (Sym(5)));
java.g:    p -> base_opt = MakeTypeArguments(1);
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Simplify the syntax tree.
java.g:--
java.g:--ClassType ::= ClassOrInterfaceType
java.g:--InterfaceType ::= ClassOrInterfaceType
java.g:--18.5 Productions from 6: Names
java.g:    AstName* name = ast_pool -> NewName(Token(tokennum));
java.g:--
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--Name ::= Name '.' 'Identifier'
java.g:    AstName* p = ast_pool -> NewName(Token(4));
java.g:    p -> base_opt = DYNAMIC_CAST<AstName*> (Sym(1));
java.g:--18.6 Productions from 7: Packages
java.g:--
java.g:-- Annotations were added in JSR 175. As a result, we must inline expand
java.g:-- PackageDeclaration vs. TypeDeclaration in order to resolve the ambiguity
java.g:-- between '@A' starting '@A package B;' vs. '@A B{}'.
java.g:--
java.g:--CompilationUnit ::= PackageDeclarationopt ImportDeclarationsopt
java.g:--                    TypeDeclarationsopt
java.g:    AstCompilationUnit* p = ast_pool -> NewCompilationUnit();
java.g:    p -> package_declaration_opt =
java.g:        p -> AllocateImportDeclarations(tail -> index + 1);
java.g:            root = root -> next;
java.g:            p -> AddImportDeclaration(DYNAMIC_CAST<AstImportDeclaration*>
java.g:                                      (root -> element));
java.g:        p -> AllocateTypeDeclarations(tail -> index + 1);
java.g:            root = root -> next;
java.g:            p -> AddTypeDeclaration(DYNAMIC_CAST<AstDeclaredType*>
java.g:                                    (root -> element));
java.g:--
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--
java.g:-- See comments above why this is inline expanded.
java.g:--
java.g:    p -> next = p;
java.g:    p -> element = Sym(1);
java.g:    p -> index = 0;
java.g:    p -> element = Sym(2);
java.g:    p -> index = tail -> index + 1;
java.g:    p -> next = tail -> next;
java.g:    tail -> next = p;
java.g:    p -> element = Sym(3);
java.g:    p -> index = tail -> index + 1;
java.g:    p -> next = tail -> next;
java.g:    tail -> next = p;
java.g:--
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--PackageDeclaration ::= 'package' Name PackageHeaderMarker ';'
java.g:    AstPackageDeclaration* p = ast_pool -> NewPackageDeclaration();
java.g:    p -> modifiers_opt = MakeModifiers();
java.g:    p -> package_token = Token(2);
java.g:    p -> name = DYNAMIC_CAST<AstName*> (Sym(3));
java.g:    p -> semicolon_token = Token(5);
java.g:    AstModifiers* p = ast_pool -> NewModifiers();
java.g:    p -> AllocateModifiers(tail -> index + 1);
java.g:        root = root -> next;
java.g:        if (root -> element -> ModifierKeywordCast())
java.g:            AstModifierKeyword* mod = (AstModifierKeyword*) root -> element;
java.g:            p -> AddModifier(mod);
java.g:            if (lex_stream -> Kind(mod -> modifier_token) == TK_static)
java.g:                p -> static_token_opt = mod -> modifier_token;
java.g:        else p -> AddModifier(DYNAMIC_CAST<AstAnnotation*> (root -> element));
java.g:--
java.g:-- Annotations were added in JSR 175. We must use Modifiers with a semantic
java.g:-- check that no modifier keywords appeared, because of the ambiguity between
java.g:-- '@A @B' starting '@A @B package C;' or '@A @B class C{}'.
java.g:--
java.g:--
java.g:-- Static imports were added in JSR 201.
java.g:--
java.g:--
java.g:-- Static imports were added in JSR 201.
java.g:--
java.g:--
java.g:-- Note that semantically, Name must be qualified to be valid (since simple
java.g:-- type names are not in scope). However, the grammar accepts simple names.
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--SingleTypeImportDeclaration ::= 'import' TypeName ';'
java.g:    AstImportDeclaration* p = ast_pool -> NewImportDeclaration();
java.g:    p -> import_token = Token(1);
java.g:        p -> static_token_opt = Token(2);
java.g:    p -> name = DYNAMIC_CAST<AstName*> (Sym(3));
java.g:        p -> star_token_opt = Token(5);
java.g:    p -> semicolon_token = Token(6);
java.g:--
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--TypeImportOnDemandDeclaration ::= 'import' PackageOrTypeName '.' '*' ';'
java.g:--
java.g:-- Static imports were added in JSR 201.
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--SingleStaticImportDeclaration ::= 'import' 'static' TypeName '.'
java.g:--                                  'Identifier' ';'
java.g:--
java.g:-- Static imports were added in JSR 201.
java.g:--
java.g:--StaticImportOnDemandDeclaration ::= 'import' 'static' TypeName '.' '*' ';'
java.g:--
java.g:-- Enums were added in JSR 201.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:    Sym(1) = ast_pool -> NewEmptyDeclaration(Token(1));
java.g:--18.7 Only in the LALR(1) Grammar
java.g:-- Remember that we do semantic filtering on modifiers, for every context
java.g:-- they can appear in. For better error messages, we also accept all modifiers
java.g:-- for initializer blocks, formal parameters, and local variable declarations.
java.g:--
java.g:--ClassModifiers ::= Modifiers
java.g:--FieldModifiers ::= Modifiers
java.g:--MethodModifiers ::= Modifiers
java.g:--ConstructorModifiers ::= Modifiers
java.g:--InterfaceModifiers ::= Modifiers
java.g:--ConstantModifiers ::= Modifiers
java.g:--AbstractMethodModifiers ::= Modifiers
java.g:    Sym(1) = ast_pool -> NewModifierKeyword(Token(1));
java.g:--
java.g:-- Annotations were added in JSR 175. They are valid anywhere a modifier is,
java.g:-- additionally they are valid on package declarations.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--NormalAnnotation ::= '@' TypeName '(' MemberValuePairsopt ')'
java.g:    AstAnnotation* p = ast_pool -> NewAnnotation();
java.g:    p -> at_token = Token(1);
java.g:    p -> name = DYNAMIC_CAST<AstName*> (Sym(2));
java.g:        p -> AllocateMemberValuePairs(tail -> index + 1);
java.g:            root = root -> next;
java.g:            p -> AddMemberValuePair(DYNAMIC_CAST<AstMemberValuePair*>
java.g:                                    (root -> element));
java.g:        p -> right_paren_token_opt = Token(5);
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175. We got rid of SimpleName.
java.g:--
java.g:--MemberValuePair ::= SimpleName '=' MemberValue
java.g:    AstMemberValuePair* p = ast_pool -> NewMemberValuePair();
java.g:    p -> identifier_token_opt = Token(1);
java.g:    p -> member_value = DYNAMIC_CAST<AstMemberValue*> (Sym(3));
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175. The rule was expanded inline below to
java.g:-- make the grammar LALR(1). The use of Marker allows us to share code.
java.g:--
java.g:--MemberValueArrayInitializer ::= '{' MemberValuesopt ,opt '}'
java.g:    AstArrayInitializer* p = ast_pool -> NewArrayInitializer();
java.g:    p -> left_brace_token = Token(1);
java.g:        p -> AllocateVariableInitializers(tail -> index + 1);
java.g:            root = root -> next;
java.g:            p -> AddVariableInitializer(DYNAMIC_CAST<AstMemberValue*>
java.g:                                        (root -> element));
java.g:    p -> right_brace_token = Token(4);
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--MarkerAnnotation ::= '@' TypeName
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--SingleMemberAnnotation ::= '@' TypeName '(' MemberValue ')'
java.g:    AstMemberValuePair* mvp = ast_pool -> NewMemberValuePair();
java.g:    mvp -> member_value = DYNAMIC_CAST<AstMemberValue*> (Sym(4));
java.g:    p -> next = p;
java.g:    p -> element = mvp;
java.g:    p -> index = 0;
java.g:--18.8 Productions from 8: Class Declarations
java.g:--18.8.1 Productions from 8.1: Class Declarations
java.g:--
java.g:-- Parameterized types were added in JSR 14.  We must inline expand
java.g:-- Modifiersopt to avoid ambiguity. The use of Marker allows us to share code.
java.g:--
java.g:--ClassDeclaration ::= ClassModifiersopt 'class' 'Identifier' Superopt
java.g:--                     Interfacesopt ClassBody
java.g:    AstClassDeclaration* p = ast_pool -> NewClassDeclaration();
java.g:    p -> modifiers_opt = MakeModifiers();
java.g:    p -> class_token = Token(2);
java.g:    p -> type_parameters_opt = MakeTypeParameters(4);
java.g:    p -> super_opt = DYNAMIC_CAST<AstTypeName*> (Sym(5));
java.g:        p -> AllocateInterfaces(tail -> index + 1);
java.g:            root = root -> next;
java.g:            p -> AddInterface(DYNAMIC_CAST<AstTypeName*> (root -> element));
java.g:    p -> class_body = DYNAMIC_CAST<AstClassBody*> (Sym(7));
java.g:    p -> class_body -> identifier_token = Token(3);
java.g:    p -> class_body -> owner = p;
java.g:    AstTypeParameters* p = ast_pool -> NewTypeParameters();
java.g:    p -> AllocateTypeParameters(tail -> index + 1);
java.g:        root = root -> next;
java.g:        p -> AddTypeParameter(DYNAMIC_CAST<AstTypeParameter*>
java.g:                              (root -> element));
java.g:    p -> right_angle_token = Token(tokennum + 1) - 1;
java.g:--
java.g:-- Parameterized types were added in JSR 14.  We must inline expand
java.g:-- Modifiersopt to avoid ambiguity.
java.g:--
java.g:--
java.g:-- Simplify.
java.g:--
java.g:--Super ::= 'extends' ClassType
java.g:--
java.g:-- Simplify.
java.g:--
java.g:--Interfaces ::= 'implements' InterfaceTypeList
java.g:--InterfaceTypeList ::= InterfaceType
java.g:--ClassTypeList ::= ClassType
java.g:--InterfaceTypeList ::= InterfaceTypeList ',' InterfaceType
java.g:--ClassTypeList ::= ClassTypeList ',' ClassType
java.g:    AstClassBody* p = ast_pool -> NewClassBody();
java.g:        p -> MarkUnparsed();
java.g:    p -> left_brace_token = Token(1);
java.g:        p -> AllocateClassBodyDeclarations(tail -> index + 1);
java.g:            root = root -> next;
java.g:                DYNAMIC_CAST<AstDeclared*> (root -> element);
java.g:                declaration -> FieldDeclarationCast();
java.g:                declaration -> InitializerDeclarationCast();
java.g:                if (field_declaration -> modifiers_opt &&
java.g:                    field_declaration -> modifiers_opt -> static_token_opt)
java.g:                    field_declaration -> MarkStatic();
java.g:                if (field_declaration -> StaticFieldCast())
java.g:            else if (declaration -> MethodDeclarationCast())
java.g:            else if (declaration -> ConstructorDeclarationCast())
java.g:                if (initializer -> modifiers_opt &&
java.g:                    initializer -> modifiers_opt -> static_token_opt)
java.g:                    initializer -> MarkStatic();
java.g:            else if (declaration -> ClassDeclarationCast())
java.g:            else if (declaration -> EnumDeclarationCast())
java.g:            else if (declaration -> InterfaceDeclarationCast())
java.g:            else if (declaration -> AnnotationDeclarationCast())
java.g:        p -> AllocateInstanceVariables(num_instance_variables);
java.g:        p -> AllocateClassVariables(num_class_variables);
java.g:        p -> AllocateMethods(num_methods);
java.g:        p -> AllocateConstructors(num_constructors);
java.g:        p -> AllocateStaticInitializers(num_static_initializers);
java.g:        p -> AllocateInstanceInitializers(num_instance_initializers);
java.g:        p -> AllocateNestedClasses(num_inner_classes);
java.g:        p -> AllocateNestedEnums(num_inner_enums);
java.g:        p -> AllocateNestedInterfaces(num_inner_interfaces);
java.g:        p -> AllocateNestedAnnotations(num_inner_annotations);
java.g:        p -> AllocateEmptyDeclarations(num_empty_declarations);
java.g:            root = root -> next;
java.g:            p -> AddClassBodyDeclaration(DYNAMIC_CAST<AstDeclared*>
java.g:                                         (root -> element));
java.g:    p -> right_brace_token = Token(3);
java.g:    p -> pool = body_pool;
java.g:--
java.g:-- Simplify. See below.
java.g:--
java.g:--ClassBodyDeclaration ::= ClassMemberDeclaration
java.g:--
java.g:-- For nicer semantic error messages, we lump static and instance initializers
java.g:-- together. Also, we parse arbitrary modifiers, but semantically only accept
java.g:-- static or no modifiers.
java.g:--
java.g:--ClassBodyDeclaration ::= StaticInitializer
java.g:--ClassBodyDeclaration ::= MethodBody
java.g:--
java.g:-- Simplify.
java.g:--
java.g:--ClassMemberDeclaration ::= FieldDeclaration
java.g:--
java.g:-- Simplify.
java.g:--
java.g:--ClassMemberDeclaration ::= MethodDeclaration
java.g:--1.1 feature
java.g:--
java.g:-- Consolidate and simplify.
java.g:--ClassMemberDeclaration ::= ClassDeclaration
java.g:--ClassMemberDeclaration ::= InterfaceDeclaration
java.g:--ClassMemberDeclaration ::= ';'
java.g:--
java.g:--18.8.2 Productions from 8.3: Field Declarations
java.g:--
java.g:-- The use of Marker allows us to share code.  We must inline expand
java.g:-- Modifiersopt to avoid ambiguity.
java.g:--
java.g:--FieldDeclaration ::= FieldModifiersopt Type VariableDeclarators ';'
java.g:    AstFieldDeclaration* p = ast_pool -> NewFieldDeclaration();
java.g:    p -> modifiers_opt = MakeModifiers();
java.g:    p -> type = DYNAMIC_CAST<AstType*> (Sym(3));
java.g:    p -> AllocateVariableDeclarators(tail -> index + 1);
java.g:        root = root -> next;
java.g:        p -> AddVariableDeclarator(DYNAMIC_CAST<AstVariableDeclarator*>
java.g:                                   (root -> element));
java.g:    p -> semicolon_token = Token(5);
java.g:    AstVariableDeclarator* p = ast_pool -> NewVariableDeclarator();
java.g:    p -> variable_declarator_name =
java.g:    AstVariableDeclarator* p = ast_pool -> NewVariableDeclarator();
java.g:    p -> variable_declarator_name =
java.g:    p -> variable_initializer_opt = Sym(3);
java.g:    AstVariableDeclaratorId* p = ast_pool -> NewVariableDeclaratorId();
java.g:    p -> identifier_token = Token(1);
java.g:    p -> brackets_opt = DYNAMIC_CAST<AstBrackets*> (Sym(2));
java.g:--18.8.3 Productions from 8.4: Method Declarations
java.g:--
java.g:-- We use "MethodHeaderMarker" to speed up parsing while minimizing memory.
java.g:-- During the first pass, we only care about declarations, so we skip
java.g:-- everything inside { }. On the second pass, we parse only one method at a
java.g:-- time (see the production of Goal above).
java.g:--
java.g:-- Also, we expanded MethodBody inline to enable the sharing of MethodBody
java.g:-- between methods, constructors, and initializers. Note that MethodBody
java.g:-- can support an explicit constructor call; so it requires semantic filtering.
java.g:--
java.g:--MethodDeclaration ::= MethodHeader MethodBody
java.g:        p -> method_body_opt = DYNAMIC_CAST<AstMethodBody*> (Sym(3));
java.g:    else p -> semicolon_token_opt = Token(4);
java.g:--
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--
java.g:-- The use of Marker allows us to share code.  We must inline expand
java.g:-- Modifiersopt to avoid ambiguity.
java.g:--
java.g:--MethodHeader ::= MethodModifiersopt Type MethodDeclarator Throwsopt
java.g:    AstMethodDeclaration* p = ast_pool -> NewMethodDeclaration();
java.g:    p -> modifiers_opt = MakeModifiers();
java.g:    p -> type_parameters_opt = MakeTypeParameters(2);
java.g:    p -> type = DYNAMIC_CAST<AstType*> (Sym(3));
java.g:    p -> method_declarator = DYNAMIC_CAST<AstMethodDeclarator*> (Sym(4));
java.g:        p -> AllocateThrows(tail -> index + 1);
java.g:            root = root -> next;
java.g:            p -> AddThrow(DYNAMIC_CAST<AstTypeName*> (root -> element));
java.g:--
java.g:-- The use of Marker allows us to share code.  We must inline expand
java.g:-- Modifiersopt to avoid ambiguity.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.  We must inline expand
java.g:-- Modifiersopt to avoid ambiguity. The use of Marker allows us to share code.
java.g:--
java.g:--MethodHeader ::= MethodModifiersopt Type MethodDeclarator Throwsopt
java.g:--
java.g:-- Parameterized types were added in JSR 14.  We must inline expand
java.g:-- Modifiersopt to avoid ambiguity.
java.g:--
java.g:--
java.g:-- The use of Marker allows us to share code.  We must inline expand
java.g:-- Modifiersopt to avoid ambiguity.
java.g:--
java.g:--MethodHeader ::= MethodModifiersopt 'void' MethodDeclarator Throwsopt
java.g:--
java.g:-- The use of Marker allows us to share code.  We must inline expand
java.g:-- Modifiersopt to avoid ambiguity.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.  We must inline expand
java.g:-- Modifiersopt to avoid ambiguity. The use of Marker allows us to share code.
java.g:--
java.g:--MethodHeader ::= Modifiersopt 'void' MethodDeclarator Throwsopt
java.g:--
java.g:-- Parameterized types were added in JSR 14.  We must inline expand
java.g:-- Modifiersopt to avoid ambiguity.
java.g:--
java.g:    AstMethodDeclarator* p = ast_pool -> NewMethodDeclarator();
java.g:    p -> identifier_token = Token(1);
java.g:    p -> left_parenthesis_token = Token(2);
java.g:        p -> AllocateFormalParameters(tail -> index + 1);
java.g:            root = root -> next;
java.g:            p -> AddFormalParameter(DYNAMIC_CAST<AstFormalParameter*>
java.g:                                    (root -> element));
java.g:    p -> right_parenthesis_token = Token(4);
java.g:    p -> brackets_opt = DYNAMIC_CAST<AstBrackets*> (Sym(5));
java.g:--
java.g:-- Varargs were added in JSR 201.
java.g:--
java.g:--FormalParameterList ::= FormalParameter
java.g:--
java.g:-- Varargs were added in JSR 201.
java.g:--
java.g:--FormalParameterList ::= FormalParameterList ',' FormalParameter
java.g:--
java.g:-- Varargs were added in JSR 201.
java.g:--
java.g:--
java.g:-- Varargs were added in JSR 201.
java.g:--
java.g:--
java.g:-- For nicer error messages, we accept all modifiers, even though only
java.g:-- 'final' and annotations are valid. Also, we must inline expand finalopt
java.g:-- to avoid ambiguity. The use of Marker allows us to share code.
java.g:--
java.g:--FormalParameter ::= finalopt Type VariableDeclaratorId
java.g:    AstFormalParameter* p = ast_pool -> NewFormalParameter();
java.g:        p -> modifiers_opt = MakeModifiers();
java.g:        p -> type = DYNAMIC_CAST<AstType*> (Sym(2));
java.g:    else p -> type = DYNAMIC_CAST<AstType*> (Sym(1));
java.g:        p -> ellipsis_token_opt = Token(3);
java.g:        ast_pool -> NewVariableDeclarator();
java.g:    formal_declarator -> variable_declarator_name =
java.g:    p -> formal_declarator = formal_declarator;
java.g:--1.1 feature
java.g:--
java.g:-- For nicer error messages, we accept all modifiers, even though only
java.g:-- 'final' and annotations are valid. Also, we must inline expand finalopt
java.g:-- to avoid ambiguity. The use of Marker allows us to share code.
java.g:--
java.g:--FormalParameter ::= final Type VariableDeclaratorId
java.g:--
java.g:-- Varargs were added in JSR 201. We must match the inline expansion of
java.g:-- FormalParameter to avoid ambiguity.
java.g:--
java.g:--LastFormalParameter ::= Modifiersopt Type ...opt VariableDeclaratorId
java.g:--
java.g:-- Varargs were added in JSR 201. The use of Marker allows us to share code.
java.g:--
java.g:--
java.g:-- Varargs were added in JSR 201.
java.g:-- For nicer error messages, we accept all modifiers, even though only
java.g:-- 'final' and annotations are valid.
java.g:--
java.g:--
java.g:-- Simplify.
java.g:--
java.g:--Throws ::= 'throws' ClassTypeList
java.g:--
java.g:-- Notice that we filter out an initial explicit constructor invocation,
java.g:-- since we have modified Statement to include this() and super(). Other
java.g:-- explicit constructor calls are ignored now, and flagged as errors
java.g:-- during semantic analysis.
java.g:--
java.g:    AstMethodBody* p = ast_pool -> NewMethodBody();
java.g:    p -> left_brace_token = Token(1);
java.g:    p -> right_brace_token = Token(3);
java.g:        p -> AllocateStatements(tail -> index + 2);
java.g:        AstListNode* root = tail -> next;
java.g:        if (root -> element -> IsExplicitConstructorInvocation())
java.g:            p -> explicit_constructor_opt =
java.g:                DYNAMIC_CAST<AstStatement*> (root -> element);
java.g:            p -> AddStatement(DYNAMIC_CAST<AstStatement*> (root -> element));
java.g:            root = root -> next;
java.g:            p -> AddStatement(DYNAMIC_CAST<AstStatement*> (root -> element));
java.g:    else p -> AllocateStatements(1);
java.g:--
java.g:-- Instead of directly including this rule, we have expanded it inline above.
java.g:--
java.g:--MethodBody ::= ';'
java.g:--
java.g:--18.8.4 Productions from 8.5: Static Initializers
java.g:--
java.g:-- For nicer error messages, we accept arbitrary modifiers. Thus this rule can
java.g:-- parse static and instance initializers. The use of MethodHeaderMarker
java.g:-- allows the 2-pass parsing. See comments of MethodDeclaration.
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--StaticInitializer ::= 'static' MethodBody
java.g:    AstInitializerDeclaration* p = ast_pool -> NewInitializerDeclaration();
java.g:    p -> modifiers_opt = MakeModifiers();
java.g:    p -> block = DYNAMIC_CAST<AstMethodBody*> (Sym(3));
java.g:-- For nicer error messages, we accept arbitrary modifiers. Thus this rule can
java.g:-- parse static and instance initializers. The use of MethodHeaderMarker
java.g:-- allows the 2-pass parsing. See comments of MethodDeclaration.
java.g:--
java.g:--18.8.5 Productions from 8.6: Constructor Declarations
java.g:--
java.g:-- The use of Marker allows us to share code. MethodHeaderMarker allows us to
java.g:-- do 2-pass parsing, and MethodBody was rewritten to handle constructor
java.g:-- bodies. We must inline expand Modifiersopt to avoid ambiguity.
java.g:--
java.g:--ConstructorDeclaration ::= ConstructorModifiersopt ConstructorDeclarator
java.g:--                           Throwsopt ConstructorBody
java.g:    AstConstructorDeclaration* p = ast_pool -> NewConstructorDeclaration();
java.g:    p -> modifiers_opt = MakeModifiers();
java.g:    p -> type_parameters_opt = MakeTypeParameters(2);
java.g:    p -> constructor_declarator = DYNAMIC_CAST<AstMethodDeclarator*> (Sym(3));
java.g:        p -> AllocateThrows(tail -> index + 1);
java.g:            root = root -> next;
java.g:            p -> AddThrow(DYNAMIC_CAST<AstTypeName*> (root -> element));
java.g:    p -> constructor_body = DYNAMIC_CAST<AstMethodBody*> (Sym(6));
java.g:--
java.g:-- The use of Marker allows us to share code. MethodHeaderMarker allows us to
java.g:-- do 2-pass parsing, and MethodBody was rewritten to handle constructor
java.g:-- bodies. We must inline expand Modifiersopt to avoid ambiguity.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.  We must inline expand
java.g:-- Modifiersopt to avoid ambiguity. The use of Marker allows us to share code.
java.g:--
java.g:--ConstructorDeclaration ::= ConstructorModifiersopt ConstructorDeclarator
java.g:--                           Throwsopt ConstructorBody
java.g:--
java.g:-- Parameterized types were added in JSR 14.  We must inline expand
java.g:-- Modifiersopt to avoid ambiguity.
java.g:--
java.g:--
java.g:-- The use of Marker allows us to share code. Also, we got rid of SimpleName.
java.g:--
java.g:--ConstructorDeclarator ::= SimpleName '(' FormalParameterListopt ')'
java.g:--
java.g:-- For better error reporting, we have coalesced ExplicitConstructorInvocation
java.g:-- into BlockStatement. Therefore, we do not need a rule for ConstructorBody,
java.g:-- since MethodBody does the same amount of work. During semantic analysis,
java.g:-- we then check calls of an explicit constructor invocation out of context.
java.g:--
java.g:--ConstructorBody ::= '{' ExplicitConstructorInvocationopt
java.g:--                    BlockStatementsopt '}'
java.g:--
java.g:--
java.g:-- Simplify.
java.g:--
java.g:--ExplicitConstructorInvocation ::= 'this' '(' ArgumentListopt ')' ';'
java.g:    AstThisCall* p = ast_pool -> NewThisCall();
java.g:    p -> this_token = Token(1);
java.g:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(2));
java.g:    p -> semicolon_token = Token(3);
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:    AstThisCall* p = ast_pool -> NewThisCall();
java.g:    p -> type_arguments_opt = MakeExplicitTypeArguments(1);
java.g:    p -> this_token = Token(2);
java.g:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(3));
java.g:    p -> semicolon_token = Token(4);
java.g:        ast_pool -> NewTypeArguments(Token(tokennum),
java.g:                                     Token(tokennum + 1) - 1);
java.g:    p -> AllocateTypeArguments(tail -> index + 1);
java.g:        root = root -> next;
java.g:        p -> AddTypeArgument(DYNAMIC_CAST<AstType*> (root -> element));
java.g:--
java.g:-- Simplify.
java.g:--
java.g:--ExplicitConstructorInvocation ::= 'super' '(' ArgumentListopt ')' ';'
java.g:    AstSuperCall* p = ast_pool -> NewSuperCall();
java.g:    p -> super_token = Token(1);
java.g:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(2));
java.g:    p -> semicolon_token = Token(3);
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:    AstSuperCall* p = ast_pool -> NewSuperCall();
java.g:    p -> type_arguments_opt = MakeExplicitTypeArguments(1);
java.g:    p -> super_token = Token(2);
java.g:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(3));
java.g:    p -> semicolon_token = Token(4);
java.g:--1.1 feature
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--ExplicitConstructorInvocation ::= Primary '.' 'super' '(' ArgumentListopt ')'
java.g:--                                  ';'
java.g:    AstSuperCall* p = ast_pool -> NewSuperCall();
java.g:    p -> base_opt = DYNAMIC_CAST<AstExpression*> (Sym(1));
java.g:    p -> type_arguments_opt = MakeExplicitTypeArguments(3);
java.g:    p -> super_token = Token(4);
java.g:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(5));
java.g:    p -> semicolon_token = Token(6);
java.g:--1.1 feature
java.g:--
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--ExplicitConstructorInvocation ::= Name '.' 'super' '(' ArgumentListopt ')'
java.g:--                                  ';'
java.g:--1.1 feature
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--ExplicitConstructorInvocation ::= Name '.' 'super' '(' ArgumentListopt ')'
java.g:--                                  ';'
java.g:--
java.g:-- Enums were added in JSR 201. We must inline expand Modifiersopt to avoid
java.g:-- ambiguity. The use of Marker allows us to share code.
java.g:--
java.g:--EnumDeclaration ::= ClassModifiersopt 'enum' 'Identifier' Interfacesopt
java.g:--                    EnumBody
java.g:    p -> modifiers_opt = MakeModifiers();
java.g:    p -> enum_token = Token(2);
java.g:    p -> class_body -> identifier_token = Token(3);
java.g:        p -> AllocateInterfaces(tail -> index + 1);
java.g:            root = root -> next;
java.g:            p -> AddInterface(DYNAMIC_CAST<AstTypeName*> (root -> element));
java.g:    p -> class_body -> identifier_token = Token(3);
java.g:--
java.g:-- Enums were added in JSR 201. We must inline expand Modifiersopt to avoid
java.g:-- ambiguity. The use of Marker allows us to share code.
java.g:--
java.g:--
java.g:-- Enums were added in JSR 201. The rule was expanded inline below to
java.g:-- make the grammar LALR(1). The use of Marker allows us to share code.
java.g:--
java.g:--EnumBody ::= '{' EnumConstantsopt ,opt EnumBodyDeclarationsopt '}'
java.g:    AstEnumDeclaration* p = ast_pool -> NewEnumDeclaration();
java.g:        p -> AllocateEnumConstants(tail -> index + 1);
java.g:            root = root -> next;
java.g:            p -> AddEnumConstant(DYNAMIC_CAST<AstEnumConstant*>
java.g:                                 (root -> element));
java.g:        p -> class_body = DYNAMIC_CAST<AstClassBody*> (Sym(4));
java.g:        p -> class_body = ast_pool -> NewClassBody();
java.g:        p -> class_body -> right_brace_token = Token(5);
java.g:        p -> class_body -> pool = body_pool;
java.g:    p -> class_body -> left_brace_token = Token(1);
java.g:    p -> class_body -> owner = p;
java.g:--
java.g:-- Enums were added in JSR 201.
java.g:--
java.g:--
java.g:-- Enums were added in JSR 201.
java.g:--
java.g:--
java.g:-- Enums were added in JSR 201.
java.g:--
java.g:--
java.g:-- Enums were added in JSR 201.
java.g:--
java.g:    AstEnumConstant* p = ast_pool -> NewEnumConstant(Token(2));
java.g:    p -> modifiers_opt = MakeModifiers();
java.g:    p -> arguments_opt = DYNAMIC_CAST<AstArguments*> (Sym(3));
java.g:    p -> class_body_opt = DYNAMIC_CAST<AstClassBody*> (Sym(4));
java.g:--
java.g:-- Enums were added in JSR 201. As long as enums introduce this production, we
java.g:-- use it elsewhere, too.
java.g:--
java.g:    AstArguments* p = ast_pool -> NewArguments(Token(1), Token(3));
java.g:        p -> AllocateArguments(tail -> index + 1);
java.g:            root = root -> next;
java.g:            p -> AddArgument(DYNAMIC_CAST<AstExpression*> (root -> element));
java.g:--
java.g:-- Enums were added in JSR 201.
java.g:--
java.g:--
java.g:-- Enums were added in JSR 201.
java.g:--
java.g:--
java.g:-- Enums were added in JSR 201. The use of Marker allows us to share code.
java.g:--
java.g:--EnumBodyDeclarations ::= ';' ClassBodyDeclarationsopt
java.g:--
java.g:-- Enums were added in JSR 201.
java.g:--
java.g:--
java.g:-- Enums were added in JSR 201.
java.g:--
java.g:--18.9 Productions from 9: Interface Declarations
java.g:--18.9.1 Productions from 9.1: Interface Declarations
java.g:--
java.g:-- Parameterized types were added in JSR 14.  We must inline expand
java.g:-- Modifiersopt to avoid ambiguity. The use of Marker allows us to share code.
java.g:--
java.g:--InterfaceDeclaration ::= InterfaceModifiersopt 'interface' 'Identifier'
java.g:--                         ExtendsInterfacesopt InterfaceBody
java.g:    AstInterfaceDeclaration* p = ast_pool -> NewInterfaceDeclaration();
java.g:    p -> modifiers_opt = MakeModifiers();
java.g:    p -> interface_token = Token(2);
java.g:    p -> type_parameters_opt = MakeTypeParameters(4);
java.g:        p -> AllocateInterfaces(tail -> index + 1);
java.g:            root = root -> next;
java.g:            p -> AddInterface(DYNAMIC_CAST<AstTypeName*> (root -> element));
java.g:    p -> class_body = DYNAMIC_CAST<AstClassBody*> (Sym(6));
java.g:    p -> class_body -> identifier_token = Token(3);
java.g:    p -> class_body -> owner = p;
java.g:--
java.g:-- Parameterized types were added in JSR 14.  We must inline expand
java.g:-- Modifiersopt to avoid ambiguity.
java.g:--
java.g:--
java.g:-- Simplify.
java.g:--
java.g:--ExtendsInterfaces ::= 'extends' InterfaceTypeList
java.g:--
java.g:--
java.g:-- For less code duplication and better semantic messages, we parse
java.g:-- non-abstract method bodies and non-initialized fields now, then do a
java.g:-- semantic check that this was valid.
java.g:--
java.g:--
java.g:-- Simplify. See below.
java.g:--
java.g:--InterfaceMemberDeclaration ::= AbstractMethodDeclaration
java.g:--1.1 feature
java.g:--
java.g:-- Consolidate and simplify.
java.g:--
java.g:--InterfaceMemberDeclaration ::= ClassDeclaration
java.g:--InterfaceMemberDeclaration ::= InterfaceDeclaration
java.g:--InterfaceMemberDeclaration ::= ';'
java.g:    DYNAMIC_CAST<AstFieldDeclaration*> (Sym(1)) -> MarkStatic();
java.g:--
java.g:-- Simplify.
java.g:--
java.g:--AbstractMethodDeclaration ::= MethodHeader ';'
java.g:--
java.g:-- Annotations were added in JSR 175. We must inline expand Modifiersopt to
java.g:-- avoid ambiguity: does 'public @' start 'public @A class B{}' or
java.g:-- 'public @interface A{}'. The use of Marker allows us to share code.
java.g:--
java.g:--AnnotationTypeDeclaration ::= InterfaceModifiersopt '@' 'interface'
java.g:--                              'Identifier' AnnotationTypeBody
java.g:        ast_pool -> NewAnnotationDeclaration(Token(3));
java.g:        p -> modifiers_opt = MakeModifiers();
java.g:    p -> class_body = DYNAMIC_CAST<AstClassBody*> (Sym(5));
java.g:    p -> class_body -> identifier_token = Token(4);
java.g:    p -> class_body -> owner = p;
java.g:-- Annotations were added in JSR 175. We must inline expand Modifiersopt to
java.g:-- avoid ambiguity: does 'public @' start 'public @A class B{}' or
java.g:-- 'public @interface A{}'.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175. We must inline expand Modifiersopt to
java.g:-- avoid ambiguity. The use of Marker allows us to share code.
java.g:--
java.g:--AnnotationTypeMemberDeclaration ::= AbstractMethodModifiersopt Type
java.g:--                                    'Identifier' '(' ')' DefaultValueopt ';'
java.g:    AstMethodDeclaration* p = ast_pool -> NewMethodDeclaration();
java.g:    p -> modifiers_opt = MakeModifiers();
java.g:    p -> type = DYNAMIC_CAST<AstType*> (Sym(3));
java.g:    AstMethodDeclarator* q = ast_pool -> NewMethodDeclarator();
java.g:    q -> identifier_token = Token(4);
java.g:    q -> left_parenthesis_token = Token(5);
java.g:    q -> right_parenthesis_token = Token(6);
java.g:    p -> method_declarator = q;
java.g:    p -> default_value_opt = DYNAMIC_CAST<AstMemberValue*> (Sym(7));
java.g:    p -> semicolon_token_opt = Token(8);
java.g:--
java.g:-- Annotations were added in JSR 175. We must inline expand Modifiersopt to
java.g:-- avoid ambiguity.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175. Consolidate and simplify.
java.g:--
java.g:--AnnotationTypeMemberDeclaration ::= ClassDeclaration
java.g:--AnnotationTypeMemberDeclaration ::= InterfaceDeclaration
java.g:--AnnotationTypeMemberDeclaration ::= EnumDeclaration
java.g:--AnnotationTypeMemberDeclaration ::= AnnotationTypeDeclaration
java.g:--AnnotationTypeMemberDeclaration ::= ';'
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--
java.g:-- Annotations were added in JSR 175.
java.g:--
java.g:--18.10 Productions from 10: Arrays
java.g:--
java.g:-- The rule VariableInitializersopt was expanded inline below to make the
java.g:-- grammar LALR(1). The use of Marker allows us to share code.
java.g:--
java.g:-- ArrayInitializer ::= '{' VariableInitializersopt ,opt '}'
java.g:--18.11 Productions from 13: Blocks and Statements
java.g:    AstBlock* p = ast_pool -> NewBlock();
java.g:    p -> left_brace_token = Token(1);
java.g:        p -> AllocateStatements(tail -> index + 1);
java.g:            root = root -> next;
java.g:            p -> AddStatement(DYNAMIC_CAST<AstStatement*> (root -> element));
java.g:    p -> right_brace_token = Token(3);
java.g:--1.1 feature
java.g:    Sym(1) = ast_pool ->
java.g:--
java.g:-- Enums were added in JSR 201.
java.g:--
java.g:    Sym(1) = ast_pool ->
java.g:--
java.g:-- NOTE: This rule is not in the original grammar. We added it, and changed
java.g:-- the rule for ConstructorBody, in order to issue a nicer error message
java.g:-- when this() or super() is encountered out of context.
java.g:--
java.g:    DYNAMIC_CAST<AstLocalVariableStatement*> (Sym(1)) -> semicolon_token_opt =
java.g:--
java.g:-- For nicer error messages, we accept all modifiers, even though only
java.g:-- 'final' and annotations are valid. Also, we must inline expand finalopt
java.g:-- to avoid ambiguity. The use of Marker allows us to share code.
java.g:--
java.g:--LocalVariableDeclaration ::= finalopt Type VariableDeclarators
java.g:    AstLocalVariableStatement* p = ast_pool -> NewLocalVariableStatement();
java.g:        p -> modifiers_opt = MakeModifiers();
java.g:        p -> type = DYNAMIC_CAST<AstType*> (Sym(2));
java.g:    else p -> type = DYNAMIC_CAST<AstType*> (Sym(1));
java.g:    p -> AllocateVariableDeclarators(tail -> index + 1);
java.g:        root = root -> next;
java.g:        p -> AddVariableDeclarator(DYNAMIC_CAST<AstVariableDeclarator*>
java.g:                                   (root -> element));
java.g:--1.1 feature
java.g:--
java.g:-- For nicer error messages, we accept all modifiers, even though only
java.g:-- 'final' and annotations are valid. Also, we must inline expand finalopt
java.g:-- to avoid ambiguity. The use of Marker allows us to share code.
java.g:--
java.g:--LocalVariableDeclaration ::= final Type VariableDeclarators
java.g:--
java.g:-- Enhanced for statements (also known as foreach, but without a new keyword),
java.g:-- were added in JDK 1.5, as part of JSR 201.
java.g:--
java.g:--
java.g:-- Enhanced for statements (also known as foreach, but without a new keyword),
java.g:-- were added in JDK 1.5, as part of JSR 201.
java.g:--
java.g:    Sym(1) = ast_pool -> NewEmptyStatement(Token(1));
java.g:    AstBlock* p = Sym(3) -> BlockCast();
java.g:    if (! p || p -> label_opt)
java.g:        p = ast_pool -> GenBlock();
java.g:        p -> AllocateStatements(1); // allocate 1 element
java.g:        p -> left_brace_token = Token(1);
java.g:        p -> AddStatement(DYNAMIC_CAST<AstStatement*> (Sym(3)));
java.g:        p -> right_brace_token = Sym(3) -> RightToken();
java.g:    p -> label_opt = Token(1); // add label to statement
java.g:    Sym(1) = p; // The final result is a block containing the labeled-statement
java.g:    DYNAMIC_CAST<AstExpressionStatement*> (Sym(1)) -> semicolon_token_opt =
java.g:    AstExpressionStatement* p = ast_pool -> NewExpressionStatement();
java.g:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(1));
java.g:--
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--IfThenStatement ::= 'if' '(' Expression ')' Statement
java.g:    AstIfStatement* p = ast_pool -> NewIfStatement();
java.g:    p -> if_token = Token(1);
java.g:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(3));
java.g:    p -> true_statement = MakeBlock(5);
java.g:    p -> false_statement_opt = Sym(7) ? MakeBlock(7) : NULL;
java.g:    AstBlock* block = Sym(tokennum) -> BlockCast();
java.g:        block = ast_pool -> GenBlock();
java.g:        block -> AllocateStatements(1); // allocate 1 element
java.g:        block -> left_brace_token = Token(tokennum);
java.g:        block -> AddStatement(DYNAMIC_CAST<AstStatement*> (Sym(tokennum)));
java.g:        block -> right_brace_token = Sym(tokennum) -> RightToken();
java.g:    p -> switch_token = Token(1);
java.g:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(3));
java.g:--
java.g:-- To avoid ambiguity with consecutive optional items, and to special
java.g:-- case trailing labels, we expand this inline.
java.g:--
java.g:--SwitchBlock ::= '{' SwitchBlockStatementsopt SwitchLabelsopt '}'
java.g:--
java.g:    AstSwitchStatement* p = ast_pool -> NewSwitchStatement();
java.g:    AstBlock* block = ast_pool -> NewBlock();
java.g:    block -> left_brace_token = Token(1);
java.g:    block -> AllocateStatements(tail -> index + (Sym(3) ? 2 : 1));
java.g:        root = root -> next;
java.g:        block -> AddStatement(DYNAMIC_CAST<AstStatement*> (root -> element));
java.g:        block -> AddStatement
java.g:    block -> right_brace_token = Token(4);
java.g:    block -> SetTag(AstBlock::SWITCH);
java.g:    p -> switch_block = block;
java.g:// Creates an AstSwitchBlockStatement from the given non-null labels, and
java.g:    AstSwitchBlockStatement* p = ast_pool -> NewSwitchBlockStatement();
java.g:    p -> AllocateSwitchLabels(tail -> index + 1);
java.g:        root = root -> next;
java.g:        p -> AddSwitchLabel(DYNAMIC_CAST<AstSwitchLabel*> (root -> element));
java.g:        p -> AllocateStatements(tail -> index + 1);
java.g:            root = root -> next;
java.g:            p -> AddStatement(DYNAMIC_CAST<AstStatement*> (root -> element));
java.g:        p -> AllocateStatements(1);
java.g:        p -> AddStatement(ast_pool -> GenEmptyStatement(labels ->
java.g:    p -> right_brace_token =
java.g:        p -> Statement(p -> NumStatements() - 1) -> RightToken();
java.g:    AstSwitchStatement* p = ast_pool -> NewSwitchStatement();
java.g:    AstBlock* block = ast_pool -> NewBlock();
java.g:    block -> AllocateStatements(1); // allocate 1 element
java.g:    block -> left_brace_token = Token(1);
java.g:        block -> AddStatement
java.g:    block -> right_brace_token = Token(3);
java.g:    block -> SetTag(AstBlock::SWITCH);
java.g:    p -> switch_block = block;
java.g:--
java.g:-- Simplify.
java.g:--
java.g:--SwitchLabel ::= 'case' ConstantExpression ':'
java.g:    AstSwitchLabel* p = ast_pool -> NewSwitchLabel();
java.g:    p -> case_token = Token(1);
java.g:    p -> expression_opt = DYNAMIC_CAST<AstExpression*> (Sym(2));
java.g:    p -> colon_token = Token(3);
java.g:--
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--SwitchLabel ::= 'default' ':'
java.g:    AstWhileStatement* p = ast_pool -> NewWhileStatement();
java.g:    p -> while_token = Token(1);
java.g:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(3));
java.g:    p -> statement = MakeBlock(5);
java.g:    AstBlock* block = ast_pool -> GenBlock();
java.g:    block -> AllocateStatements(1); // allocate 1 element
java.g:    block -> left_brace_token = Token(1);
java.g:    block -> AddStatement(p);
java.g:    block -> right_brace_token = Sym(5) -> RightToken();
java.g:    AstDoStatement* p = ast_pool -> NewDoStatement();
java.g:    p -> do_token = Token(1);
java.g:    p -> statement = MakeBlock(2);
java.g:    p -> while_token = Token(3);
java.g:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(5));
java.g:    p -> semicolon_token = Token(7);
java.g:    AstBlock* block = ast_pool -> GenBlock();
java.g:    block -> AllocateStatements(1); // allocate 1 element
java.g:    block -> left_brace_token = Token(1);
java.g:    block -> AddStatement(p);
java.g:    block -> right_brace_token = Token(7);
java.g:    AstForStatement* p = ast_pool -> NewForStatement();
java.g:    p -> for_token = Token(1);
java.g:        p -> AllocateForInitStatements(tail -> index + 1);
java.g:            root = root -> next;
java.g:            p -> AddForInitStatement(DYNAMIC_CAST<AstStatement*>
java.g:                                     (root -> element));
java.g:    p -> end_expression_opt = DYNAMIC_CAST<AstExpression*> (Sym(5));
java.g:        p -> AllocateForUpdateStatements(tail -> index + 1);
java.g:            root = root -> next;
java.g:            p -> AddForUpdateStatement(DYNAMIC_CAST<AstExpressionStatement*>
java.g:                                       (root -> element));
java.g:    p -> statement = MakeBlock(9);
java.g:    AstBlock* block = ast_pool -> NewBlock();
java.g:    block -> AllocateStatements(1); // allocate 1 element
java.g:    block -> left_brace_token = Token(1);
java.g:    block -> AddStatement(p);
java.g:    block -> right_brace_token = Sym(9) -> RightToken();
java.g:    block -> no_braces = true;
java.g:    AstForeachStatement* p = ast_pool -> NewForeachStatement();
java.g:    p -> for_token = Token(1);
java.g:    p -> formal_parameter = DYNAMIC_CAST<AstFormalParameter*> (Sym(3));
java.g:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(5));
java.g:    p -> statement = MakeBlock(7);
java.g:    AstBlock* block = ast_pool -> NewBlock();
java.g:    block -> AllocateStatements(1); // allocate 1 element
java.g:    block -> left_brace_token = Token(1);
java.g:    block -> AddStatement(p);
java.g:    block -> right_brace_token = Sym(7) -> RightToken();
java.g:    block -> no_braces = true;
java.g:--
java.g:-- Assert statements were added in JDK 1.4, as part of JSR 41.
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--AssertStatement ::= 'assert' Expression ';'
java.g:    AstAssertStatement* p = ast_pool -> NewAssertStatement();
java.g:    p -> assert_token = Token(1);
java.g:    p -> condition = DYNAMIC_CAST<AstExpression*> (Sym(2));
java.g:    p -> message_opt = DYNAMIC_CAST<AstExpression*> (Sym(4));
java.g:    p -> semicolon_token = Token(5);
java.g:    AstBreakStatement* p = ast_pool -> NewBreakStatement();
java.g:    p -> break_token = Token(1);
java.g:        p -> identifier_token_opt = Token(2);
java.g:    p -> semicolon_token = Token(3);
java.g:    AstContinueStatement* p = ast_pool -> NewContinueStatement();
java.g:    p -> continue_token = Token(1);
java.g:        p -> identifier_token_opt = Token(2);
java.g:    p -> semicolon_token = Token(3);
java.g:    AstReturnStatement* p = ast_pool -> NewReturnStatement();
java.g:    p -> return_token = Token(1);
java.g:    p -> expression_opt = DYNAMIC_CAST<AstExpression*> (Sym(2));
java.g:    p -> semicolon_token = Token(3);
java.g:    AstThrowStatement* p = ast_pool -> NewThrowStatement();
java.g:    p -> throw_token = Token(1);
java.g:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(2));
java.g:    p -> semicolon_token = Token(3);
java.g:    AstSynchronizedStatement* p = ast_pool -> NewSynchronizedStatement();
java.g:    p -> synchronized_token = Token(1);
java.g:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(3));
java.g:    p -> block = DYNAMIC_CAST<AstBlock*> (Sym(5));
java.g:    p -> block -> SetTag(AstBlock::SYNCHRONIZED);
java.g:--
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--TryStatement ::= 'try' Block Catches
java.g:    AstTryStatement* p = ast_pool -> NewTryStatement();
java.g:    p -> try_token = Token(1);
java.g:    p -> block = DYNAMIC_CAST<AstBlock*> (Sym(2));
java.g:        p -> AllocateCatchClauses(tail -> index + 1);
java.g:            root = root -> next;
java.g:            p -> AddCatchClause(DYNAMIC_CAST<AstCatchClause*>
java.g:                                (root -> element));
java.g:        p -> block -> SetTag(AstBlock::TRY_CLAUSE_WITH_FINALLY);
java.g:        for (unsigned i = 0; i < p -> NumCatchClauses(); i++)
java.g:            p -> CatchClause(i) -> block ->
java.g:        p -> finally_clause_opt = DYNAMIC_CAST<AstFinallyClause*> (Sym(4));
java.g:    AstCatchClause* p = ast_pool -> NewCatchClause();
java.g:    p -> catch_token = Token(1);
java.g:    p -> formal_parameter = DYNAMIC_CAST<AstFormalParameter*> (Sym(3));
java.g:    p -> block = DYNAMIC_CAST<AstBlock*> (Sym(5));
java.g:    AstFinallyClause* p = ast_pool -> NewFinallyClause();
java.g:    p -> finally_token = Token(1);
java.g:    p -> block = DYNAMIC_CAST<AstBlock*> (Sym(2));
java.g:    p -> block -> SetTag(AstBlock::FINALLY);
java.g:--18.12 Productions from 14: Expressions
java.g:--1.2 feature
java.g:--
java.g:-- It is legal to access an element of an initialized array, as in
java.g:-- new int[] {0}[0]; this requires splitting the original rule for
java.g:-- array creation into two.
java.g:--
java.g:--Primary ::= ArrayCreationExpression
java.g:    Sym(1) = ast_pool -> NewThisExpression(Token(1));
java.g:--
java.g:-- We split this into two rules to allow better parsing of parenthesized
java.g:-- expressions vs. casts.  All expressions have a dual *NotName form, so that
java.g:-- the decision of whether "(name)" starts a cast or is a primary does not
java.g:-- cause parsing ambiguities. The use of Marker allows us to share code.
java.g:-- Also note that splitting this rule aids in parsing generics.
java.g:--
java.g:--PrimaryNoNewArray ::= '(' Expression ')'
java.g:    AstParenthesizedExpression* p = ast_pool -> NewParenthesizedExpression();
java.g:    p -> left_parenthesis_token = Token(1);
java.g:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(2));
java.g:    p -> right_parenthesis_token = Token(4);
java.g:--
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--1.1 feature
java.g:--
java.g:-- Note that we had to rework this to avoid ambiguity
java.g:--
java.g:--PrimaryNoNewArray ::= ClassType '.' 'this'
java.g:    AstThisExpression* p = ast_pool -> NewThisExpression(Token(3));
java.g:    p -> base_opt = ast_pool -> NewTypeName(DYNAMIC_CAST<AstName*> (Sym(1)));
java.g:--1.1 feature
java.g:--
java.g:-- Note that we had to rework this to avoid ambiguity.
java.g:--
java.g:--PrimaryNoNewArray ::= Type '.' 'class'
java.g:    AstClassLiteral* p = ast_pool -> NewClassLiteral(Token(4));
java.g:    p -> type = MakeArrayType(1);
java.g:--
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--PrimaryNoNewArray ::= Name '.' 'class'
java.g:--
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--PrimaryNoNewArray ::= 'void' '.' 'class'
java.g:--1.1 feature
java.g:--
java.g:-- In Java 1.0 a ClassBody could not appear at all in a
java.g:-- ClassInstanceCreationExpression. Simplify.
java.g:--
java.g:--ClassInstanceCreationExpression ::= 'new' ClassOrInterfaceType '('
java.g:--                                    ArgumentListopt ')' ClassBodyopt
java.g:    AstClassCreationExpression* p = ast_pool -> NewClassCreationExpression();
java.g:    p -> new_token = Token(1);
java.g:    p -> class_type = DYNAMIC_CAST<AstTypeName*> (Sym(2));
java.g:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(3));
java.g:    p -> class_body_opt = DYNAMIC_CAST<AstClassBody*> (Sym(4));
java.g:    if (p -> class_body_opt)
java.g:        p -> class_body_opt -> identifier_token =
java.g:            p -> class_type -> IdentifierToken();
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--ClassInstanceCreationExpression ::= 'new' ClassOrInterfaceType '('
java.g:--                                    ArgumentListopt ')' ClassBodyopt
java.g:    AstClassCreationExpression* p = ast_pool -> NewClassCreationExpression();
java.g:    p -> new_token = Token(1);
java.g:    p -> type_arguments_opt = MakeExplicitTypeArguments(2);
java.g:    p -> class_type = DYNAMIC_CAST<AstTypeName*> (Sym(3));
java.g:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(4));
java.g:    p -> class_body_opt = DYNAMIC_CAST<AstClassBody*> (Sym(5));
java.g:    if (p -> class_body_opt)
java.g:        p -> class_body_opt -> identifier_token =
java.g:            p -> class_type -> IdentifierToken();
java.g:--1.1 feature
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--ClassInstanceCreationExpression ::= Primary '.' 'new' 'Identifier' '('
java.g:--                                    ArgumentListopt ')' ClassBodyopt
java.g:    AstClassCreationExpression* p = ast_pool -> NewClassCreationExpression();
java.g:    p -> base_opt = DYNAMIC_CAST<AstExpression*> (Sym(1));
java.g:    p -> new_token = Token(3);
java.g:    p -> type_arguments_opt = MakeExplicitTypeArguments(4);
java.g:    p -> class_type = ast_pool -> NewTypeName(MakeSimpleName(5));
java.g:    p -> class_type -> type_arguments_opt = MakeExplicitTypeArguments(6);
java.g:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(7));
java.g:    p -> class_body_opt = DYNAMIC_CAST<AstClassBody*> (Sym(8));
java.g:    if (p -> class_body_opt)
java.g:        p -> class_body_opt -> identifier_token = Token(5);
java.g:--1.1 feature
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--ClassInstanceCreationExpression ::= Name '.' 'new' 'Identifier' '('
java.g:--                                    ArgumentListopt ')' ClassBodyopt
java.g:--1.2 feature
java.g:--
java.g:-- ArrayCreationExpression is split into two parsing categories, to
java.g:-- allow array access on an initialized array.  See above.
java.g:--
java.g:--ArrayCreationExpression ::= 'new' PrimitiveType DimExprs Dimsopt
java.g:    AstArrayCreationExpression* p = ast_pool -> NewArrayCreationExpression();
java.g:    p -> new_token = Token(1);
java.g:    p -> array_type = DYNAMIC_CAST<AstType*> (Sym(2));
java.g:    p -> AllocateDimExprs(tail -> index + 1);
java.g:        root = root -> next;
java.g:        p -> AddDimExpr(DYNAMIC_CAST<AstDimExpr*> (root -> element));
java.g:    p -> brackets_opt = DYNAMIC_CAST<AstBrackets*> (Sym(4));
java.g:--ArrayCreationExpression ::= 'new' ClassOrInterfaceType DimExprs Dimsopt
java.g:--1.1 feature
java.g:--
java.g:--ArrayCreationExpression ::= 'new' ArrayType ArrayInitializer
java.g:    AstArrayCreationExpression* p = ast_pool -> NewArrayCreationExpression();
java.g:    p -> new_token = Token(1);
java.g:    p -> array_type = MakeArrayType(2);
java.g:    p -> array_initializer_opt = DYNAMIC_CAST<AstArrayInitializer*> (Sym(4));
java.g:    AstDimExpr* p = ast_pool -> NewDimExpr();
java.g:    p -> left_bracket_token = Token(1);
java.g:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(2));
java.g:    p -> right_bracket_token = Token(3);
java.g:    Sym(1) = ast_pool -> NewBrackets(Token(1), Token(2));
java.g:    p -> right_bracket_token = Token(2);
java.g:    p -> dims++;
java.g:--
java.g:-- Added rule to make parsing 'super' '.' easier.
java.g:--
java.g:    Sym(1) = ast_pool -> NewSuperExpression(Token(1));
java.g:--
java.g:-- Added rule to make parsing 'super' '.' easier. Technically, only ClassType
java.g:-- is allowed instead of Name, but that would be ambiguous with qualified
java.g:-- names. The use of Marker allows us to share code.
java.g:--
java.g:--SuperAccess ::= ClassType '.' 'super'
java.g:    AstSuperExpression* p = ast_pool -> NewSuperExpression(Token(4));
java.g:    p -> base_opt = ast_pool -> NewTypeName(DYNAMIC_CAST<AstName*> (Sym(1)));
java.g:--
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--FieldAccess ::= Primary '.' 'Identifier'
java.g:    AstFieldAccess* p = ast_pool -> NewFieldAccess();
java.g:    p -> base = DYNAMIC_CAST<AstExpression*> (Sym(1));
java.g:    p -> identifier_token = Token(4);
java.g:--
java.g:-- The use of Marker allows us to share code.  Likewise, SuperAccess
java.g:-- simplifies tree creation.
java.g:--
java.g:--FieldAccess ::= 'super' '.' 'Identifier'
java.g:--FieldAccess ::= ClassType '.' 'super' '.' 'Identifier'
java.g:--
java.g:-- Inline expand Name so we can distinguish the optional base from the required
java.g:-- method identifier.
java.g:--
java.g:--MethodInvocation ::= Name '(' ArgumentListopt ')'
java.g:    AstMethodInvocation* p = ast_pool -> NewMethodInvocation(Token(1));
java.g:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(2));
java.g:--
java.g:-- Inline expand Name so we can distinguish the optional base from the required
java.g:-- method identifier.  The use of Marker allows us to share code.
java.g:--
java.g:--MethodInvocation ::= Name '(' ArgumentListopt ')'
java.g:    AstMethodInvocation* p = ast_pool -> NewMethodInvocation(Token(4));
java.g:    p -> base_opt = DYNAMIC_CAST<AstExpression*> (Sym(1));
java.g:    p -> type_arguments_opt = MakeExplicitTypeArguments(3);
java.g:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(5));
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--MethodInvocation ::= Primary '.' 'Identifier' '(' ArgumentListopt ')'
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- The use of Marker allows us to share code.  Likewise, SuperAccess
java.g:-- simplifies tree creation.
java.g:--
java.g:--MethodInvocation ::= 'super' '.' 'Identifier' '(' ArgumentListopt ')'
java.g:--MethodInvocation ::= ClassType '.' 'super' '.' 'Identifier' '('
java.g:--                     ArgumentListopt ')'
java.g:--
java.g:-- Parameterized types were added in JSR 14.  Likewise, SuperAccess
java.g:-- simplifies tree creation.
java.g:--
java.g:--MethodInvocation ::= 'super' '.' TypeArguments 'Identifier' '('
java.g:--                     ArgumentListopt ')'
java.g:--MethodInvocation ::= ClassType '.' 'super' '.' TypeArguments 'Identifier' '('
java.g:--                     ArgumentListopt ')'
java.g:    AstArrayAccess* p = ast_pool -> NewArrayAccess();
java.g:    p -> base = DYNAMIC_CAST<AstExpression*> (Sym(1));
java.g:    p -> left_bracket_token = Token(2);
java.g:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(3));
java.g:    p -> right_bracket_token = Token(4);
java.g:--1.2 feature
java.g:--
java.g:-- Access of an initialized array is legal.  See above.
java.g:--
java.g:        ast_pool -> NewPostUnaryExpression(AstPostUnaryExpression::PLUSPLUS);
java.g:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(1));
java.g:    p -> post_operator_token = Token(2);
java.g:PostDecrementExpression ::= PostfixExpression '--'
java.g:        ast_pool -> NewPostUnaryExpression(AstPostUnaryExpression::MINUSMINUS);
java.g:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(1));
java.g:    p -> post_operator_token = Token(2);
java.g:    switch (lex_stream -> Kind(Token(1)))
java.g:    AstPreUnaryExpression* p = ast_pool -> NewPreUnaryExpression(tag);
java.g:    p -> pre_operator_token = Token(1);
java.g:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(2));
java.g:UnaryExpression ::= '-' UnaryExpression
java.g:UnaryExpressionNotName ::= '-' UnaryExpression
java.g:PreDecrementExpression ::= '--' UnaryExpression
java.g:--
java.g:-- Due to grammar ambiguities, we must rewrite this (otherwise, it is not
java.g:-- obvious whether "(a<b" starts a parenthesized expression or a cast). Note
java.g:-- that our rewrite guarantees that the contents of the parenthesis will
java.g:-- syntactically be a type, based on the way we factored parenthesized
java.g:-- expressions in Primary.
java.g:--
java.g:-- JLS2 15 lists:
java.g:--CastExpression ::= '(' PrimitiveType ')' UnaryExpression
java.g:--CastExpression ::= '(' ReferenceType ')' UnaryExpressionNotPlusMinus
java.g:-- JLS1 suggests:
java.g:--CastExpression ::= '(' PrimitiveType Dimsopt ')' UnaryExpression
java.g:--CastExpression ::= '(' Expression ')' UnaryExpressionNotPlusMinus
java.g:--CastExpression ::= '(' Name Dims ')' UnaryExpressionNotPlusMinus
java.g:--
java.g:    AstCastExpression* p = ast_pool -> NewCastExpression();
java.g:    p -> left_parenthesis_token = Token(1);
java.g:    p -> type = type;
java.g:    p -> right_parenthesis_token = Token(tokennum);
java.g:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(tokennum + 1));
java.g:--
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:    while (p -> base_opt)
java.g:        p = p -> base_opt;
java.g:    p -> base_opt = MakeTypeArguments(2);
java.g:    switch (lex_stream -> Kind(Token(2)))
java.g:    AstBinaryExpression* p = ast_pool -> NewBinaryExpression(tag);
java.g:    p -> left_expression = DYNAMIC_CAST<AstExpression*> (Sym(1));
java.g:    p -> binary_operator_token = Token(2);
java.g:    p -> right_expression = DYNAMIC_CAST<AstExpression*> (Sym(3));
java.g:AdditiveExpression ::= AdditiveExpression '-' MultiplicativeExpression
java.g:AdditiveExpressionNotName ::= AdditiveExpressionNotName '-'
java.g:AdditiveExpressionNotName ::= Name '-' MultiplicativeExpression
java.g:--
java.g:-- Relational expressions do not operate on boolean. Rewriting this
java.g:-- rule avoids an ambiguity in generics with no semantic penalty. The
java.g:-- alternative is to lower the precedence of instanceof.
java.g:--
java.g:--RelationalExpression ::= RelationalExpression '<' ShiftExpression
java.g:    AstInstanceofExpression* p = ast_pool -> NewInstanceofExpression();
java.g:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(1));
java.g:    p -> instanceof_token = Token(2);
java.g:    p -> type = DYNAMIC_CAST<AstType*> (Sym(3));
java.g:--RelationalExpressionNotName ::= RelationalExpressionNotName '<'
java.g:--                                ShiftExpression
java.g:--RelationalExpressionNotName ::= RelationalExpressionNotName '>'
java.g:--                                ShiftExpression
java.g:    AstConditionalExpression* p = ast_pool -> NewConditionalExpression();
java.g:    p -> test_expression = DYNAMIC_CAST<AstExpression*> (Sym(1));
java.g:    p -> question_token = Token(2);
java.g:    p -> true_expression = DYNAMIC_CAST<AstExpression*> (Sym(3));
java.g:    p -> colon_token = Token(4);
java.g:    p -> false_expression = DYNAMIC_CAST<AstExpression*> (Sym(5));
java.g:--
java.g:-- The original grammar uses LeftHandSide, instead of PostfixExpression.
java.g:-- However, parenthesized variables were added in JLS 2, and the
java.g:-- grammar is ambiguous unless we include all non-assignment
java.g:-- expressions. The semantic pass will filter out bad left-hand sides.
java.g:--
java.g:--Assignment ::= LeftHandSide AssignmentOperator AssignmentExpression
java.g:    switch (lex_stream -> Kind(Token(2)))
java.g:        ast_pool -> NewAssignmentExpression(tag, Token(2));
java.g:    p -> left_hand_side = DYNAMIC_CAST<AstExpression*> (Sym(1));
java.g:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(3));
java.g:--
java.g:-- See comments above for Assignment - LeftHandSide is now a useless rule.
java.g:--
java.g:--LeftHandSide -> Name
java.g:--LeftHandSide -> FieldAccess
java.g:--LeftHandSide -> ArrayAccess
java.g:AssignmentOperator ::= '-='
java.g:--
java.g:-- Simplify the syntax tree.
java.g:--
java.g:--ConstantExpression ::= Expression
java.g:-----------------------------------------------------------------------------
java.g:--
java.g:-- The following rules are for optional and helper productions.
java.g:--
java.g:-----------------------------------------------------------------------------
java.g:--
java.g:-- This rule exists solely to put NULL on the symbol stack, allowing us to
java.g:-- share productions that differ by the presence or absence of a rule.
java.g:--
java.g:// is turned on, we skip to the end-of-file token.
java.g:        lex_stream -> Reset(lex_stream -> NumTokens() - 1);
java.g:        if (lex_stream -> Kind(token) == TK_LBRACE)
java.g:            lex_stream -> Reset(lex_stream -> MatchingBrace(token));
java.g:-----------------------------------------------------------------------------
java.g:--
java.g:-- These rules add generics. Also search for JSR 14 in the comments above.
java.g:--
java.g:-----------------------------------------------------------------------------
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14. We inline expanded WildcardBounds
java.g:-- for simplicity. The use of Marker allows us to share code.
java.g:--
java.g:--Wildcard ::= '?' WildcardBoundsopt
java.g:--WildcardBounds ::= extends ReferenceType
java.g:--WildcardBounds ::= super ReferenceType
java.g:--
java.g:    AstWildcard* p = ast_pool -> NewWildcard(Token(1));
java.g:        p -> extends_token_opt = Token(2);
java.g:        p -> bounds_opt = DYNAMIC_CAST<AstType*> (Sym(4));
java.g:        p -> super_token_opt = Token(3);
java.g:        p -> bounds_opt = DYNAMIC_CAST<AstType*> (Sym(4));
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:-- Use of Marker allows us to easily find the closing '>>'.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:-- Use of Marker allows us to easily find the closing '>>>'.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:    AstTypeParameter* p = ast_pool -> NewTypeParameter(Token(1));
java.g:        p -> AllocateBounds(tail -> index + 1);
java.g:            p -> AddBound(DYNAMIC_CAST<AstTypeName*> (root -> element));
java.g:            root = root -> next;
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:-- The use of Marker allows us to share code.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:--
java.g:--
java.g:-- Parameterized types were added in JSR 14.
java.g:-- Use of Marker allows us to easily find the closing '>>'.
java.g:--
java.g:------ Finish off the files
java.g:-- Names allow diagnose.cpp debug output to be more legible
java.g:MINUS_MINUS ::= '--'
java.g:MINUS_EQUAL ::= '-='
java.g:MINUS ::= '-'
javaact.cpp:// DO NOT MODIFY THIS FILE - it is generated using jikespg on java.g.
javaact.cpp:// Do nothing - Whatever Ast was produced for x1 is inherited by A.
javaact.cpp:// parse from accepting a body as a valid input - i.e., to recognize a body
javaact.cpp:// out-of-context, the BodyMarker terminal must be inserted in front of the
javaact.cpp:    Sym(1) = ast_pool -> NewIntegerLiteral(Token(1));
javaact.cpp:    Sym(1) = ast_pool -> NewLongLiteral(Token(1));
javaact.cpp:    Sym(1) = ast_pool -> NewFloatLiteral(Token(1));
javaact.cpp:    Sym(1) = ast_pool -> NewDoubleLiteral(Token(1));
javaact.cpp:    Sym(1) = ast_pool -> NewCharacterLiteral(Token(1));
javaact.cpp:    Sym(1) = ast_pool -> NewStringLiteral(Token(1));
javaact.cpp:    Sym(1) = ast_pool -> NewNullLiteral(Token(1));
javaact.cpp:    Sym(1) = ast_pool -> NewTrueLiteral(Token(1));
javaact.cpp:    Sym(1) = ast_pool -> NewFalseLiteral(Token(1));
javaact.cpp:    Sym(1) = ast_pool -> NewPrimitiveType(Ast::BOOLEAN, Token(1));
javaact.cpp:    Sym(1) = ast_pool -> NewPrimitiveType(Ast::BYTE, Token(1));
javaact.cpp:    Sym(1) = ast_pool -> NewPrimitiveType(Ast::SHORT, Token(1));
javaact.cpp:    Sym(1) = ast_pool -> NewPrimitiveType(Ast::INT, Token(1));
javaact.cpp:    Sym(1) = ast_pool -> NewPrimitiveType(Ast::LONG, Token(1));
javaact.cpp:    Sym(1) = ast_pool -> NewPrimitiveType(Ast::CHAR, Token(1));
javaact.cpp:    Sym(1) = ast_pool -> NewPrimitiveType(Ast::FLOAT, Token(1));
javaact.cpp:    Sym(1) = ast_pool -> NewPrimitiveType(Ast::DOUBLE, Token(1));
javaact.cpp:    Sym(1) = ast_pool -> NewPrimitiveType(Ast::VOID_TYPE, Token(1));
javaact.cpp:    AstTypeName* p = Sym(tokennum) -> NameCast()
javaact.cpp:        ? ast_pool -> NewTypeName(DYNAMIC_CAST<AstName*> (Sym(tokennum)))
javaact.cpp:        ast_pool -> NewTypeArguments(Token(tokennum + 1),
javaact.cpp:                                     Token(tokennum + 3) - 1);
javaact.cpp:    q -> AllocateTypeArguments(tail -> index + 1);
javaact.cpp:        root = root -> next;
javaact.cpp:        q -> AddTypeArgument(DYNAMIC_CAST<AstType*> (root -> element));
javaact.cpp:    p -> type_arguments_opt = q;
javaact.cpp:    AstTypeName* p = ast_pool -> NewTypeName(DYNAMIC_CAST<AstName*> (Sym(1)));
javaact.cpp:    AstTypeName* p = ast_pool -> NewTypeName(DYNAMIC_CAST<AstName*> (Sym(5)));
javaact.cpp:    p -> base_opt = MakeTypeArguments(1);
javaact.cpp:    AstType* p = Sym(tokennum) -> NameCast()
javaact.cpp:        ? ast_pool -> NewTypeName(DYNAMIC_CAST<AstName*> (Sym(tokennum)))
javaact.cpp:        : ast_pool -> NewArrayType(p, (DYNAMIC_CAST<AstBrackets*>
javaact.cpp:    AstTypeName* p = ast_pool -> NewTypeName(DYNAMIC_CAST<AstName*> (Sym(5)));
javaact.cpp:    p -> base_opt = MakeTypeArguments(1);
javaact.cpp:    AstName* name = ast_pool -> NewName(Token(tokennum));
javaact.cpp:    AstName* p = ast_pool -> NewName(Token(4));
javaact.cpp:    p -> base_opt = DYNAMIC_CAST<AstName*> (Sym(1));
javaact.cpp:    AstCompilationUnit* p = ast_pool -> NewCompilationUnit();
javaact.cpp:    p -> package_declaration_opt =
javaact.cpp:        p -> AllocateImportDeclarations(tail -> index + 1);
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddImportDeclaration(DYNAMIC_CAST<AstImportDeclaration*>
javaact.cpp:                                      (root -> element));
javaact.cpp:        p -> AllocateTypeDeclarations(tail -> index + 1);
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddTypeDeclaration(DYNAMIC_CAST<AstDeclaredType*>
javaact.cpp:                                    (root -> element));
javaact.cpp:    p -> next = p;
javaact.cpp:    p -> element = Sym(1);
javaact.cpp:    p -> index = 0;
javaact.cpp:    p -> element = Sym(2);
javaact.cpp:    p -> index = tail -> index + 1;
javaact.cpp:    p -> next = tail -> next;
javaact.cpp:    tail -> next = p;
javaact.cpp:    p -> element = Sym(3);
javaact.cpp:    p -> index = tail -> index + 1;
javaact.cpp:    p -> next = tail -> next;
javaact.cpp:    tail -> next = p;
javaact.cpp:    AstPackageDeclaration* p = ast_pool -> NewPackageDeclaration();
javaact.cpp:    p -> modifiers_opt = MakeModifiers();
javaact.cpp:    p -> package_token = Token(2);
javaact.cpp:    p -> name = DYNAMIC_CAST<AstName*> (Sym(3));
javaact.cpp:    p -> semicolon_token = Token(5);
javaact.cpp:    AstModifiers* p = ast_pool -> NewModifiers();
javaact.cpp:    p -> AllocateModifiers(tail -> index + 1);
javaact.cpp:        root = root -> next;
javaact.cpp:        if (root -> element -> ModifierKeywordCast())
javaact.cpp:            AstModifierKeyword* mod = (AstModifierKeyword*) root -> element;
javaact.cpp:            p -> AddModifier(mod);
javaact.cpp:            if (lex_stream -> Kind(mod -> modifier_token) == TK_static)
javaact.cpp:                p -> static_token_opt = mod -> modifier_token;
javaact.cpp:        else p -> AddModifier(DYNAMIC_CAST<AstAnnotation*> (root -> element));
javaact.cpp:    AstImportDeclaration* p = ast_pool -> NewImportDeclaration();
javaact.cpp:    p -> import_token = Token(1);
javaact.cpp:        p -> static_token_opt = Token(2);
javaact.cpp:    p -> name = DYNAMIC_CAST<AstName*> (Sym(3));
javaact.cpp:        p -> star_token_opt = Token(5);
javaact.cpp:    p -> semicolon_token = Token(6);
javaact.cpp:    Sym(1) = ast_pool -> NewEmptyDeclaration(Token(1));
javaact.cpp:    Sym(1) = ast_pool -> NewModifierKeyword(Token(1));
javaact.cpp:    AstAnnotation* p = ast_pool -> NewAnnotation();
javaact.cpp:    p -> at_token = Token(1);
javaact.cpp:    p -> name = DYNAMIC_CAST<AstName*> (Sym(2));
javaact.cpp:        p -> AllocateMemberValuePairs(tail -> index + 1);
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddMemberValuePair(DYNAMIC_CAST<AstMemberValuePair*>
javaact.cpp:                                    (root -> element));
javaact.cpp:        p -> right_paren_token_opt = Token(5);
javaact.cpp:    AstMemberValuePair* p = ast_pool -> NewMemberValuePair();
javaact.cpp:    p -> identifier_token_opt = Token(1);
javaact.cpp:    p -> member_value = DYNAMIC_CAST<AstMemberValue*> (Sym(3));
javaact.cpp:    AstArrayInitializer* p = ast_pool -> NewArrayInitializer();
javaact.cpp:    p -> left_brace_token = Token(1);
javaact.cpp:        p -> AllocateVariableInitializers(tail -> index + 1);
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddVariableInitializer(DYNAMIC_CAST<AstMemberValue*>
javaact.cpp:                                        (root -> element));
javaact.cpp:    p -> right_brace_token = Token(4);
javaact.cpp:    AstMemberValuePair* mvp = ast_pool -> NewMemberValuePair();
javaact.cpp:    mvp -> member_value = DYNAMIC_CAST<AstMemberValue*> (Sym(4));
javaact.cpp:    p -> next = p;
javaact.cpp:    p -> element = mvp;
javaact.cpp:    p -> index = 0;
javaact.cpp:    AstClassDeclaration* p = ast_pool -> NewClassDeclaration();
javaact.cpp:    p -> modifiers_opt = MakeModifiers();
javaact.cpp:    p -> class_token = Token(2);
javaact.cpp:    p -> type_parameters_opt = MakeTypeParameters(4);
javaact.cpp:    p -> super_opt = DYNAMIC_CAST<AstTypeName*> (Sym(5));
javaact.cpp:        p -> AllocateInterfaces(tail -> index + 1);
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddInterface(DYNAMIC_CAST<AstTypeName*> (root -> element));
javaact.cpp:    p -> class_body = DYNAMIC_CAST<AstClassBody*> (Sym(7));
javaact.cpp:    p -> class_body -> identifier_token = Token(3);
javaact.cpp:    p -> class_body -> owner = p;
javaact.cpp:    AstTypeParameters* p = ast_pool -> NewTypeParameters();
javaact.cpp:    p -> AllocateTypeParameters(tail -> index + 1);
javaact.cpp:        root = root -> next;
javaact.cpp:        p -> AddTypeParameter(DYNAMIC_CAST<AstTypeParameter*>
javaact.cpp:                              (root -> element));
javaact.cpp:    p -> right_angle_token = Token(tokennum + 1) - 1;
javaact.cpp:    AstClassBody* p = ast_pool -> NewClassBody();
javaact.cpp:        p -> MarkUnparsed();
javaact.cpp:    p -> left_brace_token = Token(1);
javaact.cpp:        p -> AllocateClassBodyDeclarations(tail -> index + 1);
javaact.cpp:            root = root -> next;
javaact.cpp:                DYNAMIC_CAST<AstDeclared*> (root -> element);
javaact.cpp:                declaration -> FieldDeclarationCast();
javaact.cpp:                declaration -> InitializerDeclarationCast();
javaact.cpp:                if (field_declaration -> modifiers_opt &&
javaact.cpp:                    field_declaration -> modifiers_opt -> static_token_opt)
javaact.cpp:                    field_declaration -> MarkStatic();
javaact.cpp:                if (field_declaration -> StaticFieldCast())
javaact.cpp:            else if (declaration -> MethodDeclarationCast())
javaact.cpp:            else if (declaration -> ConstructorDeclarationCast())
javaact.cpp:                if (initializer -> modifiers_opt &&
javaact.cpp:                    initializer -> modifiers_opt -> static_token_opt)
javaact.cpp:                    initializer -> MarkStatic();
javaact.cpp:            else if (declaration -> ClassDeclarationCast())
javaact.cpp:            else if (declaration -> EnumDeclarationCast())
javaact.cpp:            else if (declaration -> InterfaceDeclarationCast())
javaact.cpp:            else if (declaration -> AnnotationDeclarationCast())
javaact.cpp:        p -> AllocateInstanceVariables(num_instance_variables);
javaact.cpp:        p -> AllocateClassVariables(num_class_variables);
javaact.cpp:        p -> AllocateMethods(num_methods);
javaact.cpp:        p -> AllocateConstructors(num_constructors);
javaact.cpp:        p -> AllocateStaticInitializers(num_static_initializers);
javaact.cpp:        p -> AllocateInstanceInitializers(num_instance_initializers);
javaact.cpp:        p -> AllocateNestedClasses(num_inner_classes);
javaact.cpp:        p -> AllocateNestedEnums(num_inner_enums);
javaact.cpp:        p -> AllocateNestedInterfaces(num_inner_interfaces);
javaact.cpp:        p -> AllocateNestedAnnotations(num_inner_annotations);
javaact.cpp:        p -> AllocateEmptyDeclarations(num_empty_declarations);
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddClassBodyDeclaration(DYNAMIC_CAST<AstDeclared*>
javaact.cpp:                                         (root -> element));
javaact.cpp:    p -> right_brace_token = Token(3);
javaact.cpp:    p -> pool = body_pool;
javaact.cpp:    AstFieldDeclaration* p = ast_pool -> NewFieldDeclaration();
javaact.cpp:    p -> modifiers_opt = MakeModifiers();
javaact.cpp:    p -> type = DYNAMIC_CAST<AstType*> (Sym(3));
javaact.cpp:    p -> AllocateVariableDeclarators(tail -> index + 1);
javaact.cpp:        root = root -> next;
javaact.cpp:        p -> AddVariableDeclarator(DYNAMIC_CAST<AstVariableDeclarator*>
javaact.cpp:                                   (root -> element));
javaact.cpp:    p -> semicolon_token = Token(5);
javaact.cpp:    AstVariableDeclarator* p = ast_pool -> NewVariableDeclarator();
javaact.cpp:    p -> variable_declarator_name =
javaact.cpp:    AstVariableDeclarator* p = ast_pool -> NewVariableDeclarator();
javaact.cpp:    p -> variable_declarator_name =
javaact.cpp:    p -> variable_initializer_opt = Sym(3);
javaact.cpp:    AstVariableDeclaratorId* p = ast_pool -> NewVariableDeclaratorId();
javaact.cpp:    p -> identifier_token = Token(1);
javaact.cpp:    p -> brackets_opt = DYNAMIC_CAST<AstBrackets*> (Sym(2));
javaact.cpp:        p -> method_body_opt = DYNAMIC_CAST<AstMethodBody*> (Sym(3));
javaact.cpp:    else p -> semicolon_token_opt = Token(4);
javaact.cpp:    AstMethodDeclaration* p = ast_pool -> NewMethodDeclaration();
javaact.cpp:    p -> modifiers_opt = MakeModifiers();
javaact.cpp:    p -> type_parameters_opt = MakeTypeParameters(2);
javaact.cpp:    p -> type = DYNAMIC_CAST<AstType*> (Sym(3));
javaact.cpp:    p -> method_declarator = DYNAMIC_CAST<AstMethodDeclarator*> (Sym(4));
javaact.cpp:        p -> AllocateThrows(tail -> index + 1);
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddThrow(DYNAMIC_CAST<AstTypeName*> (root -> element));
javaact.cpp:    AstMethodDeclarator* p = ast_pool -> NewMethodDeclarator();
javaact.cpp:    p -> identifier_token = Token(1);
javaact.cpp:    p -> left_parenthesis_token = Token(2);
javaact.cpp:        p -> AllocateFormalParameters(tail -> index + 1);
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddFormalParameter(DYNAMIC_CAST<AstFormalParameter*>
javaact.cpp:                                    (root -> element));
javaact.cpp:    p -> right_parenthesis_token = Token(4);
javaact.cpp:    p -> brackets_opt = DYNAMIC_CAST<AstBrackets*> (Sym(5));
javaact.cpp:    AstFormalParameter* p = ast_pool -> NewFormalParameter();
javaact.cpp:        p -> modifiers_opt = MakeModifiers();
javaact.cpp:        p -> type = DYNAMIC_CAST<AstType*> (Sym(2));
javaact.cpp:    else p -> type = DYNAMIC_CAST<AstType*> (Sym(1));
javaact.cpp:        p -> ellipsis_token_opt = Token(3);
javaact.cpp:        ast_pool -> NewVariableDeclarator();
javaact.cpp:    formal_declarator -> variable_declarator_name =
javaact.cpp:    p -> formal_declarator = formal_declarator;
javaact.cpp:    AstMethodBody* p = ast_pool -> NewMethodBody();
javaact.cpp:    p -> left_brace_token = Token(1);
javaact.cpp:    p -> right_brace_token = Token(3);
javaact.cpp:        p -> AllocateStatements(tail -> index + 2);
javaact.cpp:        AstListNode* root = tail -> next;
javaact.cpp:        if (root -> element -> IsExplicitConstructorInvocation())
javaact.cpp:            p -> explicit_constructor_opt =
javaact.cpp:                DYNAMIC_CAST<AstStatement*> (root -> element);
javaact.cpp:            p -> AddStatement(DYNAMIC_CAST<AstStatement*> (root -> element));
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddStatement(DYNAMIC_CAST<AstStatement*> (root -> element));
javaact.cpp:    else p -> AllocateStatements(1);
javaact.cpp:    AstInitializerDeclaration* p = ast_pool -> NewInitializerDeclaration();
javaact.cpp:    p -> modifiers_opt = MakeModifiers();
javaact.cpp:    p -> block = DYNAMIC_CAST<AstMethodBody*> (Sym(3));
javaact.cpp:    AstConstructorDeclaration* p = ast_pool -> NewConstructorDeclaration();
javaact.cpp:    p -> modifiers_opt = MakeModifiers();
javaact.cpp:    p -> type_parameters_opt = MakeTypeParameters(2);
javaact.cpp:    p -> constructor_declarator = DYNAMIC_CAST<AstMethodDeclarator*> (Sym(3));
javaact.cpp:        p -> AllocateThrows(tail -> index + 1);
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddThrow(DYNAMIC_CAST<AstTypeName*> (root -> element));
javaact.cpp:    p -> constructor_body = DYNAMIC_CAST<AstMethodBody*> (Sym(6));
javaact.cpp:    AstThisCall* p = ast_pool -> NewThisCall();
javaact.cpp:    p -> this_token = Token(1);
javaact.cpp:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(2));
javaact.cpp:    p -> semicolon_token = Token(3);
javaact.cpp:    AstThisCall* p = ast_pool -> NewThisCall();
javaact.cpp:    p -> type_arguments_opt = MakeExplicitTypeArguments(1);
javaact.cpp:    p -> this_token = Token(2);
javaact.cpp:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(3));
javaact.cpp:    p -> semicolon_token = Token(4);
javaact.cpp:        ast_pool -> NewTypeArguments(Token(tokennum),
javaact.cpp:                                     Token(tokennum + 1) - 1);
javaact.cpp:    p -> AllocateTypeArguments(tail -> index + 1);
javaact.cpp:        root = root -> next;
javaact.cpp:        p -> AddTypeArgument(DYNAMIC_CAST<AstType*> (root -> element));
javaact.cpp:    AstSuperCall* p = ast_pool -> NewSuperCall();
javaact.cpp:    p -> super_token = Token(1);
javaact.cpp:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(2));
javaact.cpp:    p -> semicolon_token = Token(3);
javaact.cpp:    AstSuperCall* p = ast_pool -> NewSuperCall();
javaact.cpp:    p -> type_arguments_opt = MakeExplicitTypeArguments(1);
javaact.cpp:    p -> super_token = Token(2);
javaact.cpp:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(3));
javaact.cpp:    p -> semicolon_token = Token(4);
javaact.cpp:    AstSuperCall* p = ast_pool -> NewSuperCall();
javaact.cpp:    p -> base_opt = DYNAMIC_CAST<AstExpression*> (Sym(1));
javaact.cpp:    p -> type_arguments_opt = MakeExplicitTypeArguments(3);
javaact.cpp:    p -> super_token = Token(4);
javaact.cpp:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(5));
javaact.cpp:    p -> semicolon_token = Token(6);
javaact.cpp:    p -> modifiers_opt = MakeModifiers();
javaact.cpp:    p -> enum_token = Token(2);
javaact.cpp:    p -> class_body -> identifier_token = Token(3);
javaact.cpp:        p -> AllocateInterfaces(tail -> index + 1);
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddInterface(DYNAMIC_CAST<AstTypeName*> (root -> element));
javaact.cpp:    p -> class_body -> identifier_token = Token(3);
javaact.cpp:    AstEnumDeclaration* p = ast_pool -> NewEnumDeclaration();
javaact.cpp:        p -> AllocateEnumConstants(tail -> index + 1);
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddEnumConstant(DYNAMIC_CAST<AstEnumConstant*>
javaact.cpp:                                 (root -> element));
javaact.cpp:        p -> class_body = DYNAMIC_CAST<AstClassBody*> (Sym(4));
javaact.cpp:        p -> class_body = ast_pool -> NewClassBody();
javaact.cpp:        p -> class_body -> right_brace_token = Token(5);
javaact.cpp:        p -> class_body -> pool = body_pool;
javaact.cpp:    p -> class_body -> left_brace_token = Token(1);
javaact.cpp:    p -> class_body -> owner = p;
javaact.cpp:    AstEnumConstant* p = ast_pool -> NewEnumConstant(Token(2));
javaact.cpp:    p -> modifiers_opt = MakeModifiers();
javaact.cpp:    p -> arguments_opt = DYNAMIC_CAST<AstArguments*> (Sym(3));
javaact.cpp:    p -> class_body_opt = DYNAMIC_CAST<AstClassBody*> (Sym(4));
javaact.cpp:    AstArguments* p = ast_pool -> NewArguments(Token(1), Token(3));
javaact.cpp:        p -> AllocateArguments(tail -> index + 1);
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddArgument(DYNAMIC_CAST<AstExpression*> (root -> element));
javaact.cpp:    AstInterfaceDeclaration* p = ast_pool -> NewInterfaceDeclaration();
javaact.cpp:    p -> modifiers_opt = MakeModifiers();
javaact.cpp:    p -> interface_token = Token(2);
javaact.cpp:    p -> type_parameters_opt = MakeTypeParameters(4);
javaact.cpp:        p -> AllocateInterfaces(tail -> index + 1);
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddInterface(DYNAMIC_CAST<AstTypeName*> (root -> element));
javaact.cpp:    p -> class_body = DYNAMIC_CAST<AstClassBody*> (Sym(6));
javaact.cpp:    p -> class_body -> identifier_token = Token(3);
javaact.cpp:    p -> class_body -> owner = p;
javaact.cpp:    DYNAMIC_CAST<AstFieldDeclaration*> (Sym(1)) -> MarkStatic();
javaact.cpp:        ast_pool -> NewAnnotationDeclaration(Token(3));
javaact.cpp:        p -> modifiers_opt = MakeModifiers();
javaact.cpp:    p -> class_body = DYNAMIC_CAST<AstClassBody*> (Sym(5));
javaact.cpp:    p -> class_body -> identifier_token = Token(4);
javaact.cpp:    p -> class_body -> owner = p;
javaact.cpp:    AstMethodDeclaration* p = ast_pool -> NewMethodDeclaration();
javaact.cpp:    p -> modifiers_opt = MakeModifiers();
javaact.cpp:    p -> type = DYNAMIC_CAST<AstType*> (Sym(3));
javaact.cpp:    AstMethodDeclarator* q = ast_pool -> NewMethodDeclarator();
javaact.cpp:    q -> identifier_token = Token(4);
javaact.cpp:    q -> left_parenthesis_token = Token(5);
javaact.cpp:    q -> right_parenthesis_token = Token(6);
javaact.cpp:    p -> method_declarator = q;
javaact.cpp:    p -> default_value_opt = DYNAMIC_CAST<AstMemberValue*> (Sym(7));
javaact.cpp:    p -> semicolon_token_opt = Token(8);
javaact.cpp:    AstBlock* p = ast_pool -> NewBlock();
javaact.cpp:    p -> left_brace_token = Token(1);
javaact.cpp:        p -> AllocateStatements(tail -> index + 1);
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddStatement(DYNAMIC_CAST<AstStatement*> (root -> element));
javaact.cpp:    p -> right_brace_token = Token(3);
javaact.cpp:    Sym(1) = ast_pool ->
javaact.cpp:    Sym(1) = ast_pool ->
javaact.cpp:    DYNAMIC_CAST<AstLocalVariableStatement*> (Sym(1)) -> semicolon_token_opt =
javaact.cpp:    AstLocalVariableStatement* p = ast_pool -> NewLocalVariableStatement();
javaact.cpp:        p -> modifiers_opt = MakeModifiers();
javaact.cpp:        p -> type = DYNAMIC_CAST<AstType*> (Sym(2));
javaact.cpp:    else p -> type = DYNAMIC_CAST<AstType*> (Sym(1));
javaact.cpp:    p -> AllocateVariableDeclarators(tail -> index + 1);
javaact.cpp:        root = root -> next;
javaact.cpp:        p -> AddVariableDeclarator(DYNAMIC_CAST<AstVariableDeclarator*>
javaact.cpp:                                   (root -> element));
javaact.cpp:    Sym(1) = ast_pool -> NewEmptyStatement(Token(1));
javaact.cpp:    AstBlock* p = Sym(3) -> BlockCast();
javaact.cpp:    if (! p || p -> label_opt)
javaact.cpp:        p = ast_pool -> GenBlock();
javaact.cpp:        p -> AllocateStatements(1); // allocate 1 element
javaact.cpp:        p -> left_brace_token = Token(1);
javaact.cpp:        p -> AddStatement(DYNAMIC_CAST<AstStatement*> (Sym(3)));
javaact.cpp:        p -> right_brace_token = Sym(3) -> RightToken();
javaact.cpp:    p -> label_opt = Token(1); // add label to statement
javaact.cpp:    Sym(1) = p; // The final result is a block containing the labeled-statement
javaact.cpp:    DYNAMIC_CAST<AstExpressionStatement*> (Sym(1)) -> semicolon_token_opt =
javaact.cpp:    AstExpressionStatement* p = ast_pool -> NewExpressionStatement();
javaact.cpp:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(1));
javaact.cpp:    AstIfStatement* p = ast_pool -> NewIfStatement();
javaact.cpp:    p -> if_token = Token(1);
javaact.cpp:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(3));
javaact.cpp:    p -> true_statement = MakeBlock(5);
javaact.cpp:    p -> false_statement_opt = Sym(7) ? MakeBlock(7) : NULL;
javaact.cpp:    AstBlock* block = Sym(tokennum) -> BlockCast();
javaact.cpp:        block = ast_pool -> GenBlock();
javaact.cpp:        block -> AllocateStatements(1); // allocate 1 element
javaact.cpp:        block -> left_brace_token = Token(tokennum);
javaact.cpp:        block -> AddStatement(DYNAMIC_CAST<AstStatement*> (Sym(tokennum)));
javaact.cpp:        block -> right_brace_token = Sym(tokennum) -> RightToken();
javaact.cpp:    p -> switch_token = Token(1);
javaact.cpp:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(3));
javaact.cpp:    AstSwitchStatement* p = ast_pool -> NewSwitchStatement();
javaact.cpp:    AstBlock* block = ast_pool -> NewBlock();
javaact.cpp:    block -> left_brace_token = Token(1);
javaact.cpp:    block -> AllocateStatements(tail -> index + (Sym(3) ? 2 : 1));
javaact.cpp:        root = root -> next;
javaact.cpp:        block -> AddStatement(DYNAMIC_CAST<AstStatement*> (root -> element));
javaact.cpp:        block -> AddStatement
javaact.cpp:    block -> right_brace_token = Token(4);
javaact.cpp:    block -> SetTag(AstBlock::SWITCH);
javaact.cpp:    p -> switch_block = block;
javaact.cpp:// Creates an AstSwitchBlockStatement from the given non-null labels, and
javaact.cpp:    AstSwitchBlockStatement* p = ast_pool -> NewSwitchBlockStatement();
javaact.cpp:    p -> AllocateSwitchLabels(tail -> index + 1);
javaact.cpp:        root = root -> next;
javaact.cpp:        p -> AddSwitchLabel(DYNAMIC_CAST<AstSwitchLabel*> (root -> element));
javaact.cpp:        p -> AllocateStatements(tail -> index + 1);
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddStatement(DYNAMIC_CAST<AstStatement*> (root -> element));
javaact.cpp:        p -> AllocateStatements(1);
javaact.cpp:        p -> AddStatement(ast_pool -> GenEmptyStatement(labels ->
javaact.cpp:    p -> right_brace_token =
javaact.cpp:        p -> Statement(p -> NumStatements() - 1) -> RightToken();
javaact.cpp:    AstSwitchStatement* p = ast_pool -> NewSwitchStatement();
javaact.cpp:    AstBlock* block = ast_pool -> NewBlock();
javaact.cpp:    block -> AllocateStatements(1); // allocate 1 element
javaact.cpp:    block -> left_brace_token = Token(1);
javaact.cpp:        block -> AddStatement
javaact.cpp:    block -> right_brace_token = Token(3);
javaact.cpp:    block -> SetTag(AstBlock::SWITCH);
javaact.cpp:    p -> switch_block = block;
javaact.cpp:    AstSwitchLabel* p = ast_pool -> NewSwitchLabel();
javaact.cpp:    p -> case_token = Token(1);
javaact.cpp:    p -> expression_opt = DYNAMIC_CAST<AstExpression*> (Sym(2));
javaact.cpp:    p -> colon_token = Token(3);
javaact.cpp:    AstWhileStatement* p = ast_pool -> NewWhileStatement();
javaact.cpp:    p -> while_token = Token(1);
javaact.cpp:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(3));
javaact.cpp:    p -> statement = MakeBlock(5);
javaact.cpp:    AstBlock* block = ast_pool -> GenBlock();
javaact.cpp:    block -> AllocateStatements(1); // allocate 1 element
javaact.cpp:    block -> left_brace_token = Token(1);
javaact.cpp:    block -> AddStatement(p);
javaact.cpp:    block -> right_brace_token = Sym(5) -> RightToken();
javaact.cpp:    AstDoStatement* p = ast_pool -> NewDoStatement();
javaact.cpp:    p -> do_token = Token(1);
javaact.cpp:    p -> statement = MakeBlock(2);
javaact.cpp:    p -> while_token = Token(3);
javaact.cpp:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(5));
javaact.cpp:    p -> semicolon_token = Token(7);
javaact.cpp:    AstBlock* block = ast_pool -> GenBlock();
javaact.cpp:    block -> AllocateStatements(1); // allocate 1 element
javaact.cpp:    block -> left_brace_token = Token(1);
javaact.cpp:    block -> AddStatement(p);
javaact.cpp:    block -> right_brace_token = Token(7);
javaact.cpp:    AstForStatement* p = ast_pool -> NewForStatement();
javaact.cpp:    p -> for_token = Token(1);
javaact.cpp:        p -> AllocateForInitStatements(tail -> index + 1);
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddForInitStatement(DYNAMIC_CAST<AstStatement*>
javaact.cpp:                                     (root -> element));
javaact.cpp:    p -> end_expression_opt = DYNAMIC_CAST<AstExpression*> (Sym(5));
javaact.cpp:        p -> AllocateForUpdateStatements(tail -> index + 1);
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddForUpdateStatement(DYNAMIC_CAST<AstExpressionStatement*>
javaact.cpp:                                       (root -> element));
javaact.cpp:    p -> statement = MakeBlock(9);
javaact.cpp:    AstBlock* block = ast_pool -> NewBlock();
javaact.cpp:    block -> AllocateStatements(1); // allocate 1 element
javaact.cpp:    block -> left_brace_token = Token(1);
javaact.cpp:    block -> AddStatement(p);
javaact.cpp:    block -> right_brace_token = Sym(9) -> RightToken();
javaact.cpp:    block -> no_braces = true;
javaact.cpp:    AstForeachStatement* p = ast_pool -> NewForeachStatement();
javaact.cpp:    p -> for_token = Token(1);
javaact.cpp:    p -> formal_parameter = DYNAMIC_CAST<AstFormalParameter*> (Sym(3));
javaact.cpp:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(5));
javaact.cpp:    p -> statement = MakeBlock(7);
javaact.cpp:    AstBlock* block = ast_pool -> NewBlock();
javaact.cpp:    block -> AllocateStatements(1); // allocate 1 element
javaact.cpp:    block -> left_brace_token = Token(1);
javaact.cpp:    block -> AddStatement(p);
javaact.cpp:    block -> right_brace_token = Sym(7) -> RightToken();
javaact.cpp:    block -> no_braces = true;
javaact.cpp:    AstAssertStatement* p = ast_pool -> NewAssertStatement();
javaact.cpp:    p -> assert_token = Token(1);
javaact.cpp:    p -> condition = DYNAMIC_CAST<AstExpression*> (Sym(2));
javaact.cpp:    p -> message_opt = DYNAMIC_CAST<AstExpression*> (Sym(4));
javaact.cpp:    p -> semicolon_token = Token(5);
javaact.cpp:    AstBreakStatement* p = ast_pool -> NewBreakStatement();
javaact.cpp:    p -> break_token = Token(1);
javaact.cpp:        p -> identifier_token_opt = Token(2);
javaact.cpp:    p -> semicolon_token = Token(3);
javaact.cpp:    AstContinueStatement* p = ast_pool -> NewContinueStatement();
javaact.cpp:    p -> continue_token = Token(1);
javaact.cpp:        p -> identifier_token_opt = Token(2);
javaact.cpp:    p -> semicolon_token = Token(3);
javaact.cpp:    AstReturnStatement* p = ast_pool -> NewReturnStatement();
javaact.cpp:    p -> return_token = Token(1);
javaact.cpp:    p -> expression_opt = DYNAMIC_CAST<AstExpression*> (Sym(2));
javaact.cpp:    p -> semicolon_token = Token(3);
javaact.cpp:    AstThrowStatement* p = ast_pool -> NewThrowStatement();
javaact.cpp:    p -> throw_token = Token(1);
javaact.cpp:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(2));
javaact.cpp:    p -> semicolon_token = Token(3);
javaact.cpp:    AstSynchronizedStatement* p = ast_pool -> NewSynchronizedStatement();
javaact.cpp:    p -> synchronized_token = Token(1);
javaact.cpp:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(3));
javaact.cpp:    p -> block = DYNAMIC_CAST<AstBlock*> (Sym(5));
javaact.cpp:    p -> block -> SetTag(AstBlock::SYNCHRONIZED);
javaact.cpp:    AstTryStatement* p = ast_pool -> NewTryStatement();
javaact.cpp:    p -> try_token = Token(1);
javaact.cpp:    p -> block = DYNAMIC_CAST<AstBlock*> (Sym(2));
javaact.cpp:        p -> AllocateCatchClauses(tail -> index + 1);
javaact.cpp:            root = root -> next;
javaact.cpp:            p -> AddCatchClause(DYNAMIC_CAST<AstCatchClause*>
javaact.cpp:                                (root -> element));
javaact.cpp:        p -> block -> SetTag(AstBlock::TRY_CLAUSE_WITH_FINALLY);
javaact.cpp:        for (unsigned i = 0; i < p -> NumCatchClauses(); i++)
javaact.cpp:            p -> CatchClause(i) -> block ->
javaact.cpp:        p -> finally_clause_opt = DYNAMIC_CAST<AstFinallyClause*> (Sym(4));
javaact.cpp:    AstCatchClause* p = ast_pool -> NewCatchClause();
javaact.cpp:    p -> catch_token = Token(1);
javaact.cpp:    p -> formal_parameter = DYNAMIC_CAST<AstFormalParameter*> (Sym(3));
javaact.cpp:    p -> block = DYNAMIC_CAST<AstBlock*> (Sym(5));
javaact.cpp:    AstFinallyClause* p = ast_pool -> NewFinallyClause();
javaact.cpp:    p -> finally_token = Token(1);
javaact.cpp:    p -> block = DYNAMIC_CAST<AstBlock*> (Sym(2));
javaact.cpp:    p -> block -> SetTag(AstBlock::FINALLY);
javaact.cpp:    Sym(1) = ast_pool -> NewThisExpression(Token(1));
javaact.cpp:    AstParenthesizedExpression* p = ast_pool -> NewParenthesizedExpression();
javaact.cpp:    p -> left_parenthesis_token = Token(1);
javaact.cpp:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(2));
javaact.cpp:    p -> right_parenthesis_token = Token(4);
javaact.cpp:    AstThisExpression* p = ast_pool -> NewThisExpression(Token(3));
javaact.cpp:    p -> base_opt = ast_pool -> NewTypeName(DYNAMIC_CAST<AstName*> (Sym(1)));
javaact.cpp:    AstClassLiteral* p = ast_pool -> NewClassLiteral(Token(4));
javaact.cpp:    p -> type = MakeArrayType(1);
javaact.cpp:    AstClassCreationExpression* p = ast_pool -> NewClassCreationExpression();
javaact.cpp:    p -> new_token = Token(1);
javaact.cpp:    p -> class_type = DYNAMIC_CAST<AstTypeName*> (Sym(2));
javaact.cpp:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(3));
javaact.cpp:    p -> class_body_opt = DYNAMIC_CAST<AstClassBody*> (Sym(4));
javaact.cpp:    if (p -> class_body_opt)
javaact.cpp:        p -> class_body_opt -> identifier_token =
javaact.cpp:            p -> class_type -> IdentifierToken();
javaact.cpp:    AstClassCreationExpression* p = ast_pool -> NewClassCreationExpression();
javaact.cpp:    p -> new_token = Token(1);
javaact.cpp:    p -> type_arguments_opt = MakeExplicitTypeArguments(2);
javaact.cpp:    p -> class_type = DYNAMIC_CAST<AstTypeName*> (Sym(3));
javaact.cpp:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(4));
javaact.cpp:    p -> class_body_opt = DYNAMIC_CAST<AstClassBody*> (Sym(5));
javaact.cpp:    if (p -> class_body_opt)
javaact.cpp:        p -> class_body_opt -> identifier_token =
javaact.cpp:            p -> class_type -> IdentifierToken();
javaact.cpp:    AstClassCreationExpression* p = ast_pool -> NewClassCreationExpression();
javaact.cpp:    p -> base_opt = DYNAMIC_CAST<AstExpression*> (Sym(1));
javaact.cpp:    p -> new_token = Token(3);
javaact.cpp:    p -> type_arguments_opt = MakeExplicitTypeArguments(4);
javaact.cpp:    p -> class_type = ast_pool -> NewTypeName(MakeSimpleName(5));
javaact.cpp:    p -> class_type -> type_arguments_opt = MakeExplicitTypeArguments(6);
javaact.cpp:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(7));
javaact.cpp:    p -> class_body_opt = DYNAMIC_CAST<AstClassBody*> (Sym(8));
javaact.cpp:    if (p -> class_body_opt)
javaact.cpp:        p -> class_body_opt -> identifier_token = Token(5);
javaact.cpp:    AstArrayCreationExpression* p = ast_pool -> NewArrayCreationExpression();
javaact.cpp:    p -> new_token = Token(1);
javaact.cpp:    p -> array_type = DYNAMIC_CAST<AstType*> (Sym(2));
javaact.cpp:    p -> AllocateDimExprs(tail -> index + 1);
javaact.cpp:        root = root -> next;
javaact.cpp:        p -> AddDimExpr(DYNAMIC_CAST<AstDimExpr*> (root -> element));
javaact.cpp:    p -> brackets_opt = DYNAMIC_CAST<AstBrackets*> (Sym(4));
javaact.cpp:    AstArrayCreationExpression* p = ast_pool -> NewArrayCreationExpression();
javaact.cpp:    p -> new_token = Token(1);
javaact.cpp:    p -> array_type = MakeArrayType(2);
javaact.cpp:    p -> array_initializer_opt = DYNAMIC_CAST<AstArrayInitializer*> (Sym(4));
javaact.cpp:    AstDimExpr* p = ast_pool -> NewDimExpr();
javaact.cpp:    p -> left_bracket_token = Token(1);
javaact.cpp:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(2));
javaact.cpp:    p -> right_bracket_token = Token(3);
javaact.cpp:    Sym(1) = ast_pool -> NewBrackets(Token(1), Token(2));
javaact.cpp:    p -> right_bracket_token = Token(2);
javaact.cpp:    p -> dims++;
javaact.cpp:    Sym(1) = ast_pool -> NewSuperExpression(Token(1));
javaact.cpp:    AstSuperExpression* p = ast_pool -> NewSuperExpression(Token(4));
javaact.cpp:    p -> base_opt = ast_pool -> NewTypeName(DYNAMIC_CAST<AstName*> (Sym(1)));
javaact.cpp:    AstFieldAccess* p = ast_pool -> NewFieldAccess();
javaact.cpp:    p -> base = DYNAMIC_CAST<AstExpression*> (Sym(1));
javaact.cpp:    p -> identifier_token = Token(4);
javaact.cpp:    AstMethodInvocation* p = ast_pool -> NewMethodInvocation(Token(1));
javaact.cpp:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(2));
javaact.cpp:    AstMethodInvocation* p = ast_pool -> NewMethodInvocation(Token(4));
javaact.cpp:    p -> base_opt = DYNAMIC_CAST<AstExpression*> (Sym(1));
javaact.cpp:    p -> type_arguments_opt = MakeExplicitTypeArguments(3);
javaact.cpp:    p -> arguments = DYNAMIC_CAST<AstArguments*> (Sym(5));
javaact.cpp:    AstArrayAccess* p = ast_pool -> NewArrayAccess();
javaact.cpp:    p -> base = DYNAMIC_CAST<AstExpression*> (Sym(1));
javaact.cpp:    p -> left_bracket_token = Token(2);
javaact.cpp:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(3));
javaact.cpp:    p -> right_bracket_token = Token(4);
javaact.cpp:        ast_pool -> NewPostUnaryExpression(AstPostUnaryExpression::PLUSPLUS);
javaact.cpp:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(1));
javaact.cpp:    p -> post_operator_token = Token(2);
javaact.cpp:        ast_pool -> NewPostUnaryExpression(AstPostUnaryExpression::MINUSMINUS);
javaact.cpp:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(1));
javaact.cpp:    p -> post_operator_token = Token(2);
javaact.cpp:    switch (lex_stream -> Kind(Token(1)))
javaact.cpp:    AstPreUnaryExpression* p = ast_pool -> NewPreUnaryExpression(tag);
javaact.cpp:    p -> pre_operator_token = Token(1);
javaact.cpp:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(2));
javaact.cpp:    AstCastExpression* p = ast_pool -> NewCastExpression();
javaact.cpp:    p -> left_parenthesis_token = Token(1);
javaact.cpp:    p -> type = type;
javaact.cpp:    p -> right_parenthesis_token = Token(tokennum);
javaact.cpp:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(tokennum + 1));
javaact.cpp:    while (p -> base_opt)
javaact.cpp:        p = p -> base_opt;
javaact.cpp:    p -> base_opt = MakeTypeArguments(2);
javaact.cpp:    switch (lex_stream -> Kind(Token(2)))
javaact.cpp:    AstBinaryExpression* p = ast_pool -> NewBinaryExpression(tag);
javaact.cpp:    p -> left_expression = DYNAMIC_CAST<AstExpression*> (Sym(1));
javaact.cpp:    p -> binary_operator_token = Token(2);
javaact.cpp:    p -> right_expression = DYNAMIC_CAST<AstExpression*> (Sym(3));
javaact.cpp:    AstInstanceofExpression* p = ast_pool -> NewInstanceofExpression();
javaact.cpp:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(1));
javaact.cpp:    p -> instanceof_token = Token(2);
javaact.cpp:    p -> type = DYNAMIC_CAST<AstType*> (Sym(3));
javaact.cpp:    AstConditionalExpression* p = ast_pool -> NewConditionalExpression();
javaact.cpp:    p -> test_expression = DYNAMIC_CAST<AstExpression*> (Sym(1));
javaact.cpp:    p -> question_token = Token(2);
javaact.cpp:    p -> true_expression = DYNAMIC_CAST<AstExpression*> (Sym(3));
javaact.cpp:    p -> colon_token = Token(4);
javaact.cpp:    p -> false_expression = DYNAMIC_CAST<AstExpression*> (Sym(5));
javaact.cpp:    switch (lex_stream -> Kind(Token(2)))
javaact.cpp:        ast_pool -> NewAssignmentExpression(tag, Token(2));
javaact.cpp:    p -> left_hand_side = DYNAMIC_CAST<AstExpression*> (Sym(1));
javaact.cpp:    p -> expression = DYNAMIC_CAST<AstExpression*> (Sym(3));
javaact.cpp:// is turned on, we skip to the end-of-file token.
javaact.cpp:        lex_stream -> Reset(lex_stream -> NumTokens() - 1);
javaact.cpp:        if (lex_stream -> Kind(token) == TK_LBRACE)
javaact.cpp:            lex_stream -> Reset(lex_stream -> MatchingBrace(token));
javaact.cpp:    AstWildcard* p = ast_pool -> NewWildcard(Token(1));
javaact.cpp:        p -> extends_token_opt = Token(2);
javaact.cpp:        p -> bounds_opt = DYNAMIC_CAST<AstType*> (Sym(4));
javaact.cpp:        p -> super_token_opt = Token(3);
javaact.cpp:        p -> bounds_opt = DYNAMIC_CAST<AstType*> (Sym(4));
javaact.cpp:    AstTypeParameter* p = ast_pool -> NewTypeParameter(Token(1));
javaact.cpp:        p -> AllocateBounds(tail -> index + 1);
javaact.cpp:            p -> AddBound(DYNAMIC_CAST<AstTypeName*> (root -> element));
javaact.cpp:            root = root -> next;
javaact.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
javaact.h:// DO NOT MODIFY THIS FILE - it is generated using jikespg on java.g.
Binary file javaact.o matches
javadcl.h:// DO NOT MODIFY THIS FILE - it is generated using jikespg on java.g.
javadcl.h:            -9,0,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,-146,-26,-11,0,-306,-4,0,
javadcl.h:            -590,0,0,0,-15,0,-2,0,0,-16,
javadcl.h:            0,0,0,0,0,-22,0,0,-10,0,
javadcl.h:            0,0,0,0,0,-182,0,0,0,-472,
javadcl.h:            0,0,0,0,-180,-596,0,-62,0,-187,
javadcl.h:            -54,0,0,-12,-602,-503,0,0,0,0,
javadcl.h:            0,-473,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,-75,0,0,0,0,0,0,0,
javadcl.h:            0,-214,0,0,0,0,0,-184,0,-56,
javadcl.h:            0,0,0,0,0,0,-308,-24,0,0,
javadcl.h:            -373,0,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,-581,0,
javadcl.h:            -517,0,0,-662,-501,0,-3,0,-13,0,
javadcl.h:            0,0,0,-502,0,0,0,0,0,0,
javadcl.h:            -647,0,0,0,0,0,0,0,0,0,
javadcl.h:            0,-14,0,0,0,-114,-18,0,0,0,
javadcl.h:            -242,0,0,0,0,0,-516,0,-538,0,
javadcl.h:            0,0,0,0,0,-19,-67,0,0,0,
javadcl.h:            0,0,0,-289,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,-5,0,0,-47,0,-48,
javadcl.h:            0,0,-326,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,-563,0,0,0,0,0,-51,
javadcl.h:            0,0,0,0,0,0,0,0,0,-232,
javadcl.h:            -32,0,-150,0,0,0,0,-148,0,0,
javadcl.h:            0,0,0,0,0,-74,0,-64,-76,0,
javadcl.h:            0,0,0,0,0,0,0,0,-69,0,
javadcl.h:            0,0,0,-288,-20,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-488,0,-319,
javadcl.h:            0,0,-65,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-8,0,0,
javadcl.h:            0,0,-21,0,0,-164,0,0,0,0,
javadcl.h:            0,0,-80,0,0,-35,-27,-328,0,-294,
javadcl.h:            -331,-83,0,-36,-29,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,-587,0,
javadcl.h:            0,-7,0,0,0,-30,0,-293,0,0,
javadcl.h:            0,0,-285,0,-113,0,0,0,0,0,
javadcl.h:            0,0,0,0,-449,0,0,-513,0,-38,
javadcl.h:            0,0,-41,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-325,0,0,
javadcl.h:            0,0,0,0,-189,-206,-60,-208,0,0,
javadcl.h:            0,0,-181,0,0,-42,-520,-43,0,-230,
javadcl.h:            0,0,-44,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,-441,0,0,-420,0,
javadcl.h:            0,0,0,0,0,0,0,0,-564,0,
javadcl.h:            0,0,-594,0,-518,-77,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,-45,-97,0,-84,
javadcl.h:            0,0,-49,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,-556,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,-489,-512,0,0,
javadcl.h:            0,0,0,0,0,-50,0,0,-597,-82,
javadcl.h:            -318,0,-52,0,0,0,0,-53,0,-55,
javadcl.h:            -204,0,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,-639,0,
javadcl.h:            -600,0,-623,0,-625,0,0,0,0,0,
javadcl.h:            0,0,0,-628,0,0,0,-428,0,0,
javadcl.h:            0,0,0,-640,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,-663,-543,0,0,
javadcl.h:            0,0,0,0,0,-629,0,0,-188,-632,
javadcl.h:            0,0,0,0,0,0,0,-633,-57,-569,
javadcl.h:            -470,-88,-471,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,-670,0,
javadcl.h:            -635,0,-636,-172,-322,-330,0,0,-58,0,
javadcl.h:            0,0,-437,0,-59,-580,-61,-611,0,0,
javadcl.h:            0,0,0,-672,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-71,0,0,
javadcl.h:            0,0,0,0,0,-582,0,-491,0,-583,
javadcl.h:            -677,0,0,0,0,0,0,0,-66,-68,
javadcl.h:            -70,-78,-613,0,-85,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,-681,0,
javadcl.h:            -86,0,-87,-100,0,-186,-79,-103,0,0,
javadcl.h:            -292,-417,-104,-105,-106,-107,-457,-320,0,0,
javadcl.h:            0,0,0,-39,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,-72,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,-89,0,0,0,
javadcl.h:            0,0,-574,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,-91,0,-108,-63,0,0,
javadcl.h:            0,0,0,0,-37,0,0,0,0,0,
javadcl.h:            -487,-92,-140,-588,0,0,-109,0,0,0,
javadcl.h:            0,0,0,-452,0,-544,-96,0,0,-304,
javadcl.h:            0,0,-99,0,-17,0,0,0,-178,-291,
javadcl.h:            0,0,0,0,0,0,0,-454,-163,0,
javadcl.h:            0,-302,-167,0,0,0,0,0,0,0,
javadcl.h:            0,0,-81,0,-110,0,-547,0,0,0,
javadcl.h:            0,0,0,0,0,0,-309,-482,-505,0,
javadcl.h:            -111,0,0,0,0,0,-409,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-177,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,-410,-73,
javadcl.h:            0,0,0,0,-411,-112,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,0,-371,
javadcl.h:            0,0,0,0,0,0,-421,0,0,0,
javadcl.h:            0,0,0,0,-678,-115,0,-116,-117,0,
javadcl.h:            -118,0,-370,-630,-430,-676,-413,0,0,0,
javadcl.h:            -508,0,0,0,0,0,0,0,0,0,
javadcl.h:            0,-551,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,-205,0,0,0,0,
javadcl.h:            0,0,-535,-119,0,-120,-122,-127,-128,-129,
javadcl.h:            -132,-133,-134,0,-135,-136,-137,-138,-139,-141,
javadcl.h:            -142,0,-530,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,-557,0,
javadcl.h:            0,-90,-93,-123,-124,-458,-160,0,-648,-656,
javadcl.h:            -143,0,-145,-151,-152,-156,-165,-169,-170,-171,
javadcl.h:            -174,-175,-176,-414,-433,-434,-435,0,0,0,
javadcl.h:            0,0,0,-641,0,0,0,0,0,0,
javadcl.h:            0,-162,-179,-185,-190,-195,0,-196,-199,-200,
javadcl.h:            -203,-207,-231,-233,-234,-235,-236,-276,-280,-281,
javadcl.h:            0,0,0,0,0,0,0,0,-415,0,
javadcl.h:            0,0,0,0,0,0,0,0,0,-282,
javadcl.h:            -283,0,0,0,0,-284,-453,0,0,-286,
javadcl.h:            -287,-296,-436,0,0,-498,0,0,-321,0,
javadcl.h:            0,0,0,0,-173,0,0,0,0,-570,
javadcl.h:            0,-191,0,0,0,-484,-297,0,0,0,
javadcl.h:            0,0,0,0,0,-609,0,-539,-298,0,
javadcl.h:            0,-485,-561,-591,-592,-299,-300,0,-301,-621,
javadcl.h:            0,0,0,-228,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,-303,-307,0,0,0,
javadcl.h:            -310,0,0,0,-595,-598,0,-311,0,0,
javadcl.h:            -446,0,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,-147,0,0,0,
javadcl.h:            0,-312,0,0,0,0,0,0,0,0,
javadcl.h:            -599,-627,0,-313,-314,-601,0,-674,0,0,
javadcl.h:            0,0,0,-192,0,0,0,0,0,0,
javadcl.h:            -316,0,0,0,-324,-327,0,0,0,0,
javadcl.h:            0,0,0,0,0,-337,-338,-631,-634,0,
javadcl.h:            0,0,-144,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,-197,0,
javadcl.h:            0,0,0,0,-339,-344,-345,0,0,-657,
javadcl.h:            0,0,-346,-348,0,-658,-349,0,0,-504,
javadcl.h:            0,0,0,0,0,-350,0,0,0,0,
javadcl.h:            -351,-352,0,0,0,0,0,0,0,0,
javadcl.h:            -353,-354,-355,-356,0,0,-357,0,0,-542,
javadcl.h:            0,0,0,0,0,-198,0,0,0,0,
javadcl.h:            -202,0,0,0,0,0,-358,0,0,0,
javadcl.h:            -359,-360,-361,-362,0,0,-363,0,0,-364,
javadcl.h:            -365,0,-366,-367,-368,-369,0,-477,0,0,
javadcl.h:            0,0,0,0,-46,0,0,0,0,0,
javadcl.h:            0,-183,0,-305,0,0,-374,0,0,0,
javadcl.h:            0,0,-323,0,0,0,-332,0,-375,-333,
javadcl.h:            -334,-335,-336,0,-376,-377,0,-378,-379,0,
javadcl.h:            -380,-381,0,0,-382,-383,-384,-385,-386,-387,
javadcl.h:            -388,-389,0,0,0,0,0,0,0,-390,
javadcl.h:            0,-34,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-391,0,0,
javadcl.h:            0,0,-392,-393,0,0,0,0,-394,-395,
javadcl.h:            0,0,-396,-397,-149,0,0,0,-398,0,
javadcl.h:            0,-98,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-340,-399,-343,
javadcl.h:            -400,-401,-402,-403,0,-404,-405,-406,0,-407,
javadcl.h:            -412,-416,-427,-429,-431,-432,-438,-439,-443,0,
javadcl.h:            -444,-445,-448,0,0,0,0,0,0,0,
javadcl.h:            0,-159,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,-479,-450,0,-455,-459,-419,
javadcl.h:            -425,-460,0,0,0,-461,-462,-467,0,0,
javadcl.h:            -468,-475,0,0,0,0,-478,-483,0,-486,
javadcl.h:            -492,0,-494,0,0,0,0,-423,0,0,
javadcl.h:            0,0,0,-426,0,0,0,0,-495,-496,
javadcl.h:            0,0,0,0,-497,-499,0,0,-622,0,
javadcl.h:            -500,0,0,0,-506,0,0,-329,0,0,
javadcl.h:            0,0,-507,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,-511,0,
javadcl.h:            0,-522,-523,0,-456,0,-529,-533,0,0,
javadcl.h:            -534,-553,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,-440,0,0,-540,0,-528,
javadcl.h:            0,-541,0,0,0,0,-550,0,0,0,
javadcl.h:            -559,-560,0,0,0,0,-562,-571,0,-573,
javadcl.h:            0,0,-578,0,0,0,0,0,-579,-584,
javadcl.h:            0,0,0,-638,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,0,-465,
javadcl.h:            0,0,0,0,-466,0,0,0,0,0,
javadcl.h:            -476,0,0,0,0,-493,-515,-585,0,0,
javadcl.h:            0,0,0,-586,-589,0,-593,-603,-604,-605,
javadcl.h:            0,-606,-607,-608,-610,-612,0,-614,-615,-620,
javadcl.h:            -624,0,0,0,-31,0,0,0,0,0,
javadcl.h:            -521,0,0,0,0,-524,-527,0,0,0,
javadcl.h:            0,-531,-532,0,0,0,-536,0,-552,0,
javadcl.h:            0,-576,0,0,-642,-643,0,-645,-646,-649,
javadcl.h:            -651,0,0,-654,-655,-659,-660,0,0,-661,
javadcl.h:            -665,-673,0,-675,0,-679,-680,0,0,-33,
javadcl.h:            0,0,0,0,0,0,0,0,0,-121,
javadcl.h:            0,0,0,0,0,0,0,0,0,-153,
javadcl.h:            0,0,0,0,0,0,0,0,0,-154,
javadcl.h:            0,0,0,0,0,0,0,0,0,-157,
javadcl.h:            0,0,0,0,0,0,0,0,0,-158,
javadcl.h:            0,0,0,0,0,0,0,0,0,-161,
javadcl.h:            0,0,0,0,0,0,0,0,0,-166,
javadcl.h:            0,0,0,0,0,0,0,0,0,-201,
javadcl.h:            0,0,0,0,0,0,0,0,0,-227,
javadcl.h:            0,0,0,0,0,0,0,0,0,-255,
javadcl.h:            0,0,0,0,0,0,0,0,0,-277,
javadcl.h:            0,0,0,0,0,0,0,0,0,-290,
javadcl.h:            0,0,0,0,0,0,0,0,0,-347,
javadcl.h:            0,-256,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-577,0,0,
javadcl.h:            0,0,-616,-619,0,0,0,0,-653,-664,
javadcl.h:            0,0,0,0,0,0,0,-372,0,0,
javadcl.h:            0,0,0,0,0,0,0,-408,0,0,
javadcl.h:            0,0,0,0,0,0,0,-422,0,0,
javadcl.h:            0,0,0,0,0,0,0,-537,0,0,
javadcl.h:            0,0,0,0,0,0,0,-554,0,0,
javadcl.h:            0,0,0,0,0,0,0,-555,0,0,
javadcl.h:            0,0,0,0,0,0,0,-637,0,0,
javadcl.h:            0,0,0,0,0,0,0,-155,0,0,
javadcl.h:            0,0,0,0,0,0,-474,0,0,0,
javadcl.h:            0,0,0,-480,0,0,0,0,0,0,
javadcl.h:            -481,0,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-278,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,-229,0,
javadcl.h:            0,0,0,0,0,0,0,0,-257,0,
javadcl.h:            0,0,0,0,0,0,0,0,-279,0,
javadcl.h:            0,0,0,0,0,0,0,0,-225,0,
javadcl.h:            0,0,0,0,0,-253,0,0,0,0,
javadcl.h:            0,0,-258,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,0,-226,
javadcl.h:            0,0,0,0,0,-254,0,0,0,0,
javadcl.h:            0,-259,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-222,0,0,
javadcl.h:            0,0,-250,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-260,0,0,
javadcl.h:            0,0,-223,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,-224,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,-251,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,-252,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,-261,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-262,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,-215,0,
javadcl.h:            0,0,0,0,0,0,0,0,-216,0,
javadcl.h:            0,0,0,0,0,0,0,0,-217,0,
javadcl.h:            0,0,0,0,0,0,0,0,-218,0,
javadcl.h:            0,0,0,0,0,0,0,0,-243,0,
javadcl.h:            0,0,0,0,0,0,0,0,-244,0,
javadcl.h:            0,0,0,0,0,0,0,0,-245,0,
javadcl.h:            0,0,0,0,0,0,0,0,-246,0,
javadcl.h:            0,0,0,0,0,0,0,0,-264,0,
javadcl.h:            0,0,0,0,0,0,0,0,-265,0,
javadcl.h:            0,0,0,0,0,0,0,0,-266,0,
javadcl.h:            0,0,0,0,0,0,0,0,-267,0,
javadcl.h:            0,0,0,0,0,0,0,0,-219,0,
javadcl.h:            0,0,0,0,0,0,0,-220,0,0,
javadcl.h:            0,0,0,0,0,0,-221,0,0,0,
javadcl.h:            0,0,0,0,0,-247,0,0,0,0,
javadcl.h:            0,0,0,0,-248,0,0,0,0,0,
javadcl.h:            0,0,0,-249,0,0,0,0,0,0,
javadcl.h:            0,0,-268,0,0,0,0,0,0,0,
javadcl.h:            0,-269,0,0,0,0,0,0,0,0,
javadcl.h:            -270,0,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,-666,0,0,-558,
javadcl.h:            0,0,0,0,0,0,-652,0,0,0,
javadcl.h:            0,0,0,-671,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,-315,0,0,-667,
javadcl.h:            0,-668,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,-209,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,-210,0,0,0,
javadcl.h:            0,-237,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,0,-238,
javadcl.h:            0,0,0,0,0,0,0,-271,0,0,
javadcl.h:            0,0,0,0,0,-272,0,0,0,0,
javadcl.h:            0,0,0,-40,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,0,-94,
javadcl.h:            0,0,0,0,0,-95,0,0,0,0,
javadcl.h:            0,-101,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-102,0,0,
javadcl.h:            0,0,0,-125,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,0,-126,
javadcl.h:            0,0,0,0,0,-130,0,0,0,0,
javadcl.h:            0,-131,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-211,0,0,
javadcl.h:            0,0,0,-212,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,0,-213,
javadcl.h:            0,0,0,0,0,-239,0,0,0,0,
javadcl.h:            0,-240,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-241,0,0,
javadcl.h:            0,0,0,-273,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,0,-274,
javadcl.h:            0,0,0,0,0,-275,0,0,0,0,
javadcl.h:            0,-469,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-424,0,0,
javadcl.h:            -464,0,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,-626,0,0,0,0,0,0,
javadcl.h:            0,-263,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-650,0,0,
javadcl.h:            0,0,0,0,0,0,-1,0,0,0,
javadcl.h:            0,0,0,0,0,-194,0,0,0,0,
javadcl.h:            -575,0,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,-418,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-572,0,0,
javadcl.h:            0,0,0,0,-193,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,-644,0,0,0,
javadcl.h:            0,0,0,-23,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,-447,0,0,
javadcl.h:            0,0,-545,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,-490,0,
javadcl.h:            0,0,-341,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,-669,0,0,0,
javadcl.h:            0,0,0,0,0,0,-317,0,0,0,
javadcl.h:            0,0,0,0,-514,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,0,-463,
javadcl.h:            0,0,0,0,0,0,0,0,-28,0,
javadcl.h:            0,0,0,0,0,0,0,-168,0,0,
javadcl.h:            0,-295,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,-442,0,
javadcl.h:            0,-25,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,-6,0,0,0,
javadcl.h:            0,0,0,0,-546,0,0,0,0,0,
javadcl.h:            -519,0,0,0,0,0,0,0,0,0,
javadcl.h:            0,0,0,0,0,0,0,0,-548,0,
javadcl.h:            0,0,0,0,0,0,0,-549,0,0,
javadcl.h:            0,0,0,0,0,-617,0,0,0,0,
javadcl.h:            -618,0,0,0,0,0,0,0,0,0,
javadcl.h:            -525,0,0,0,0,0,0,0,-526,0,
javadcl.h:            0,0,0,0,-565,0,0,0,0,0,
javadcl.h:            -566,0,0,0,0,0,0,0,-567,0,
javadcl.h:            0,-568,0,0,0,0,0,0,0,-342,
javadcl.h:            0,0,0,0,0,0,0,-451,0,0,
javadcl.h:            0,0,0,0,0,-509,0,0,0,0,
javadcl.h:            0,0,0,0,-510,0,0,0,0,0,
javadcl.h:const   signed short *CLASS_HEADER base_check = &(check_table[0]) - (NUM_RULES + 1);
javadcl.h:            '-','-','=','=','<','=','>','=','!','=',
javadcl.h:            '<','<','>','>','>','>','>','+','=','-',
javadcl.h:            '>','>','=','|','|','&','&','+','-','!',
javadef.h:// DO NOT MODIFY THIS FILE - it is generated using jikespg on java.g.
javaprs.h:// DO NOT MODIFY THIS FILE - it is generated using jikespg on java.g.
javaprs.h:    static int original_state(int state) { return -base_check[state]; }
javasym.h:// DO NOT MODIFY THIS FILE - it is generated using jikespg on java.g.
Binary file jikes matches
jikes.cpp:    files = compiler -> parseOptions(argc, argv);
jikes.cpp:    if (compiler -> getOptions() -> help)
jikes.cpp:               "-bootclasspath path location of system classes [default '']\n"
jikes.cpp:               "-classpath path     location of user classes and source files [default .]\n"
jikes.cpp:               "-d dir              write class files in directory dir [default .]\n"
jikes.cpp:               "-debug              no effect (ignored for compatibility)\n"
jikes.cpp:               "-depend | -Xdepend  recompile all used classes\n"
jikes.cpp:               "-deprecation        report uses of deprecated features\n"
jikes.cpp:               "-encoding encoding  use specified encoding to read source files\n"
jikes.cpp:               "-extdirs path       location of zip/jar files with platform extensions\n"
jikes.cpp:               "-g | -g:none | -g:{lines,vars,source}\n"
jikes.cpp:               "-J...               no effect (ignored for compatibility)\n"
jikes.cpp:               "-nowarn             javac-compatible equivalent of +Z0\n"
jikes.cpp:               "-nowrite            do not write any class files, useful with -verbose\n"
jikes.cpp:               "-O                  optimize bytecode (presently does nothing)\n"
jikes.cpp:               "-source release     interpret source by Java SDK release rules\n"
jikes.cpp:               "-sourcepath path    location of user source files [default '']\n"
jikes.cpp:               "-target release     output bytecode for Java SDK release rules\n"
jikes.cpp:               "-verbose            list files read and written\n"
jikes.cpp:               "-Werror             javac-compatible equivalent of +Z2\n"
jikes.cpp:               "-Xstdout            redirect output listings to stdout\n"
jikes.cpp:               "-Xswitchcheck       warn about fallthrough between switch statement cases\n"
jikes.cpp:               "+D                  report errors immediately in emacs-form without buffering\n"
jikes.cpp:               "+E                  list errors in emacs-form\n"
jikes.cpp:               "+P                  pedantic compilation - issues lots of warnings\n"
jikes.cpp:               "+O numbytes         call no-op op_trap() for bytecodes of the given length\n"
jikes.cpp:               "-help | --help      display this message and exit\n"
jikes.cpp:               "-version | --version  display version and contact information, and exit\n");
jikes.cpp:    else if (compiler -> getOptions() -> version)
jikes.cpp:        return_code = compiler -> compile(files);
jikes.cpp:        printf("For more help, try -help or -version.\n");
Binary file jikes.o matches
jikesapi.cpp:            Coutput << bad_options[i] -> GetErrorMessage() << endl;
jikesapi.cpp:        int n = args -> argc - opt -> first_file_index;
jikesapi.cpp:            const char *o = args -> argv[opt -> first_file_index + i];
jikesapi.cpp:    int return_code = control -> return_code;
jikesapi.cpp:    Coutput << error -> getErrorReport() << endl;
jikesapi.cpp:    if (result && (result->getBuffer() == NULL))
jikesapi.cpp:    if (result && (! result -> isValid()))
jikesapi.cpp:        maxSize -= size;
jikesapi.cpp:    JikesAPI::getInstance() -> stat(fileName, &status);
jikesapi.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
jikesapi.h:    char* extdirs;       // Location of external drop-in jars
jikesapi.h:    // 0 if false, non-zero if true
Binary file jikesapi.o matches
long.cpp:    // But, since not all compilers follow these rules, we special-case on
long.cpp:        return BaseLong((HighWord() << n) | (lo >> (32 - n)), lo << n);
long.cpp:    return BaseLong(LowWord() << (n - 32), 0);
long.cpp:BaseLong BaseLong::operator- () const
long.cpp:BaseLong BaseLong::operator- (const BaseLong op) const
long.cpp:    return *this + (-op);
long.cpp:BaseLong &BaseLong::operator-= (const BaseLong op)
long.cpp:    return *this = *this - op;
long.cpp:BaseLong BaseLong::operator-- (int)
long.cpp:    *this -= 1;
long.cpp:BaseLong BaseLong::operator-- ()
long.cpp:    return *this -= 1;
long.cpp:            remainder_high -= divisor.LowWord();
long.cpp:            remainder -= divisor;
long.cpp:    // But, since not all compilers follow these rules, we special-case on
long.cpp:        return ULongInt(hi >> n, (hi << (32 - n)) | (LowWord() >> n));
long.cpp:    return ULongInt(0, HighWord() >> (n - 32));
long.cpp:    u8 a = negative_dividend ? -(i8) value.words : value.words,
long.cpp:       b = negative_divisor  ? -(i8) op.value.words : op.value.words;
long.cpp:    return LongInt((negative_dividend ^ negative_divisor) ? -(a / b) : a / b);
long.cpp:    BaseLong a = (negative_dividend ? -(*this) : (BaseLong) *this),
long.cpp:             b = (negative_divisor  ? -(op)    : (BaseLong) op),
long.cpp:    return (negative_dividend ^ negative_divisor ? -quotient : quotient);
long.cpp:    u8 a = negative_dividend ? -(i8) value.words : value.words,
long.cpp:       b = negative_divisor  ? -(i8) op.value.words : op.value.words;
long.cpp:    return LongInt(negative_dividend ? -(a % b) : a % b);
long.cpp:    BaseLong a = (negative_dividend ? -(*this) : (BaseLong) *this),
long.cpp:             b = (negative_divisor  ? -(op)    : (BaseLong) op),
long.cpp:    return (negative_dividend ? -remainder : remainder);
long.cpp:    // Correct compilers treat x >> 0 as x, and x >> 32+ as x<0 ? -1 : 0.
long.cpp:    // But, since not all compilers follow these rules, we special-case on
long.cpp:         return LongInt(hi >> n, (hi << (32 - n)) | (LowWord() >> n));
long.cpp:    return LongInt(shift, hi >> (n - 32));
long.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
long.h:    BaseLong operator-(const BaseLong) const; // binary subtraction
long.h:    BaseLong operator-() const;     // unary minus
long.h:    BaseLong& operator-=(const BaseLong); // subtract and assign
long.h:    BaseLong operator--(int);      // postfix decrement
long.h:    BaseLong operator--();     // prefix decrement
long.h:    bool operator&&(const BaseLong) const; // logical AND (not short-circuit)
long.h:    bool operator<(const LongInt) const; // less-than
long.h:    bool operator>(const LongInt) const; // greater-than
long.h:    bool operator<=(const LongInt) const; // less-than or equal
long.h:    bool operator>=(const LongInt) const; // greater-than or equal
long.h:    bool operator<(const ULongInt) const; // less-than
long.h:    bool operator>(const ULongInt) const; // greater-than
long.h:    bool operator<=(const ULongInt) const; // less-than or equal
long.h:    bool operator>=(const ULongInt) const; // greater-than or equal
Binary file long.o matches
lookup.cpp:    prime_index = -1;
lookup.cpp:        int i = hash(element -> device, element -> inode);
lookup.cpp:        element -> next = base[i];
lookup.cpp:    for (Element* element = base[k]; element; element = element -> next)
lookup.cpp:        if (element -> device == device && element -> inode == inode)
lookup.cpp:            return element -> directory_symbol;
lookup.cpp:    element -> next = base[k];
lookup.cpp:    for (entry = base[k]; entry; entry = entry -> next)
lookup.cpp:        if (len == entry -> length &&
lookup.cpp:            memcmp(entry -> name, str, len * sizeof(char)) == 0)
lookup.cpp:            return entry -> IsDummy() ? (DirectoryEntry*) NULL : entry;
lookup.cpp:        int k = Hash(e -> name, e -> length) % hash_size;
lookup.cpp:        e -> next = base[k];
lookup.cpp:    for (entry = base[k]; entry; entry = entry -> next)
lookup.cpp:        if (len == entry -> length &&
lookup.cpp:            memcmp(entry -> name, str, len * sizeof(char)) == 0)
lookup.cpp:    entry -> Initialize(directory_symbol, str, len);
lookup.cpp:    entry -> next = base[k];
lookup.cpp:    return entry ? entry -> Image() : entry;
lookup.cpp:    int length = image -> length;
lookup.cpp:        lower_name[i] = Case::ToAsciiLower(image -> name[i]);
lookup.cpp:    for (entry = base[k]; entry; entry = entry -> next)
lookup.cpp:        if (length == entry -> length &&
lookup.cpp:            memcmp(entry -> name, lower_name, length * sizeof(char)) == 0)
lookup.cpp:        folded_entry -> Initialize(image, lower_name, length);
lookup.cpp:        folded_entry -> next = base[k];
lookup.cpp:        char* dirname = this -> directory -> DirectoryName();
lookup.cpp:        int length = this -> directory -> DirectoryNameLength() +
lookup.cpp:            this -> length + 1; // +1 for '/'
lookup.cpp:        if (dirname[this -> directory -> DirectoryNameLength() - 1] != U_SLASH)
lookup.cpp:        strcat(file_name, this -> name);
lookup.cpp:        if (JikesAPI::getInstance() -> stat(file_name, &status) == 0)
lookup.cpp:        int k = ns -> hash_address % hash_size;
lookup.cpp:        ns -> next = base[k];
lookup.cpp:    for (symbol = base[k]; symbol; symbol = (NameSymbol*) symbol -> next)
lookup.cpp:        if (hash_address == symbol -> hash_address &&
lookup.cpp:            len == symbol -> NameLength() &&
lookup.cpp:            memcmp(symbol -> Name(), str, len * sizeof(wchar_t)) == 0)
lookup.cpp:    symbol -> Initialize(str, len, hash_address, index);
lookup.cpp:    symbol -> next = base[k];
lookup.cpp:        int k = type -> hash_address % hash_size;
lookup.cpp:        type -> next_type = base[k];
lookup.cpp:    for (TypeSymbol* type = base[k]; type; type = type -> next_type)
lookup.cpp:        assert(type -> fully_qualified_name);
lookup.cpp:        Utf8LiteralValue* fully_qualified_name = type -> fully_qualified_name;
lookup.cpp:        if (len == fully_qualified_name -> length &&
lookup.cpp:            memcmp(fully_qualified_name -> value, str,
lookup.cpp:    assert(type && type -> fully_qualified_name);
lookup.cpp:    unsigned hash_address = Hash(type -> fully_qualified_name -> value,
lookup.cpp:                                 type -> fully_qualified_name -> length);
lookup.cpp:    for (TypeSymbol* t = base[k]; t; t = t -> next_type)
lookup.cpp:    type -> hash_address = hash_address;
lookup.cpp:    type -> next_type = base[k];
lookup.cpp:    const wchar_t* name = literal -> Name() + 1;
lookup.cpp:    int len = literal -> NameLength() - 2; // discard ''
lookup.cpp:        return literal -> value = bad_value;
lookup.cpp:        return literal -> value = FindOrInsert((i4) name[0]);
lookup.cpp:    i4 value = -1;
lookup.cpp:                    value = value * 8 + name[i] - U_0;
lookup.cpp:    return literal -> value = (value < 0 || value > 65535 ? bad_value
lookup.cpp:    const wchar_t* head = literal -> Name() + 1; // point to X
lookup.cpp:    const wchar_t* tail = &literal -> Name()[literal -> NameLength() - 1];
lookup.cpp:    head--;
lookup.cpp:    for (int i = 0; i < 32 && tail > head; i += 4, tail--)
lookup.cpp:    const wchar_t* head = literal -> Name(); // point to initial '0'
lookup.cpp:    const wchar_t* tail = &head[literal -> NameLength() - 1];
lookup.cpp:    head--;
lookup.cpp:    for (int i = 0; i < 30 && tail > head; i += 3, tail--)
lookup.cpp:        u4 d = *tail - U_0;
lookup.cpp:        u4 d = *tail - U_0;
lookup.cpp:            tail--;
lookup.cpp:    const wchar_t* name = literal -> Name();
lookup.cpp:        literal -> value = (name[1] == U_x || name[1] == U_X
lookup.cpp:            int digit = *p - U_0;
lookup.cpp:        literal -> value = (*p ? bad_value : FindOrInsert(value));
lookup.cpp:    return literal -> value;
lookup.cpp:    if (literal -> value && literal -> value != bad_value)
lookup.cpp:        IntLiteralValue* int_literal = (IntLiteralValue*) literal -> value;
lookup.cpp:        return FindOrInsert(- int_literal -> value);
lookup.cpp:    const wchar_t* name = literal -> Name();
lookup.cpp:        return FindOrInsert(- int_literal -> value);
lookup.cpp:        int digit = *p - U_0;
lookup.cpp:    return *p ? bad_value : FindOrInsert(- value);
lookup.cpp:        int k = ((unsigned) ilv -> value) % hash_size;
lookup.cpp:        ilv -> next = base[k];
lookup.cpp:    for (lit = base[k]; lit; lit = (IntLiteralValue*) lit -> next)
lookup.cpp:        if (lit -> value == value)
lookup.cpp:    for (lit = base[k]; lit; lit = (IntLiteralValue*) lit -> next)
lookup.cpp:        if (lit -> value == value)
lookup.cpp:    lit -> Initialize(value, symbol_pool.Length());
lookup.cpp:    lit -> next = base[k];
lookup.cpp:    const wchar_t* head = literal -> Name() + 1; // point to X
lookup.cpp:    // -2 to skip the 'L' suffix
lookup.cpp:    const wchar_t* tail = &literal -> Name()[literal -> NameLength() - 2];
lookup.cpp:    head--;
lookup.cpp:    for (int i = 0; i < 32 && tail > head; i += 4, tail--)
lookup.cpp:    for (int j = 0; j < 32 && tail > head; j += 4, tail--)
lookup.cpp:    const wchar_t* head = literal -> Name(); // point to initial '0'
lookup.cpp:    // -2 to skip the 'L' suffix
lookup.cpp:    const wchar_t* tail = &head[literal -> NameLength() - 2];
lookup.cpp:    head--;
lookup.cpp:    for (int i = 0; i < 63 && tail > head; i += 3, tail--)
lookup.cpp:        ULongInt d = (u4) (*tail - U_0);
lookup.cpp:        u4 d = *tail - U_0;
lookup.cpp:            tail--;
lookup.cpp:    const wchar_t* name = literal -> Name();
lookup.cpp:        literal -> value = (name[1] == U_x || name[1] == U_X
lookup.cpp:            u4 digit = *p - U_0;
lookup.cpp:        literal -> value = (*p != U_L && *p != U_l ? bad_value
lookup.cpp:    return literal -> value;
lookup.cpp:    if (literal -> value && literal -> value != bad_value)
lookup.cpp:        LongLiteralValue* long_literal = (LongLiteralValue*) literal -> value;
lookup.cpp:        return FindOrInsert(- long_literal -> value);
lookup.cpp:    const wchar_t* name = literal -> Name();
lookup.cpp:        return FindOrInsert(- long_literal -> value);
lookup.cpp:        u4 digit = *p - U_0;
lookup.cpp:    return *p != U_L && *p != U_l ? bad_value : FindOrInsert(- value);
lookup.cpp:        int k = Hash(llv -> value) % hash_size;
lookup.cpp:        llv -> next = base[k];
lookup.cpp:    for (lit = base[k]; lit; lit = (LongLiteralValue*) lit -> next)
lookup.cpp:        if (lit -> value == value)
lookup.cpp:    lit -> Initialize(value, symbol_pool.Length());
lookup.cpp:    lit -> next = base[k];
lookup.cpp:    char* name = new char[literal -> NameLength() + 1];
lookup.cpp:    for (unsigned i = 0; i < literal -> NameLength(); i++)
lookup.cpp:        name[i] = (char) literal -> Name()[i];
lookup.cpp:    name[literal -> NameLength()] = U_NULL;
lookup.cpp:    literal -> value = (value.IsNaN() ? bad_value : FindOrInsert(value));
lookup.cpp:    return literal -> value;
lookup.cpp:        int k = Hash(flv -> value) % hash_size;
lookup.cpp:        flv -> next = base[k];
lookup.cpp:    for (lit = base[k]; lit; lit = (FloatLiteralValue*) lit -> next)
lookup.cpp:        if (lit -> value.equals(value))
lookup.cpp:    lit -> Initialize(value, symbol_pool.Length());
lookup.cpp:    lit -> next = base[k];
lookup.cpp:    char* name = new char[literal -> NameLength() + 1];
lookup.cpp:    for (unsigned i = 0; i < literal -> NameLength(); i++)
lookup.cpp:        name[i] = (char) literal -> Name()[i];
lookup.cpp:    name[literal -> NameLength()] = U_NULL;
lookup.cpp:    literal -> value = (value.IsNaN() ? bad_value : FindOrInsert(value));
lookup.cpp:    return literal -> value;
lookup.cpp:        int k = Hash(dlv -> value) % hash_size;
lookup.cpp:        dlv -> next = base[k];
lookup.cpp:    for (lit = base[k]; lit; lit = (DoubleLiteralValue*) lit -> next)
lookup.cpp:        if (lit -> value.equals(value))
lookup.cpp:    lit -> Initialize(value, symbol_pool.Length());
lookup.cpp:    lit -> next = base[k];
lookup.cpp:    const wchar_t* name = literal -> Name() + 1;
lookup.cpp:    int literal_length = literal -> NameLength() - 2; // discard ""
lookup.cpp:    int i = -1;
lookup.cpp:                ch = name[i] - U_0;
lookup.cpp:                ch = ch * 8 + name[i] - U_0;
lookup.cpp:                ch = ch * 8 + name[++i] - U_0;
lookup.cpp:                ch = -1;
lookup.cpp:            ch = -1;
lookup.cpp:    literal -> value = (i < literal_length ? bad_value
lookup.cpp:    return literal -> value;
lookup.cpp:        int k = ulv -> hash_address % hash_size;
lookup.cpp:        ulv -> next = base[k];
lookup.cpp:    for (lit = base[k]; lit; lit = (Utf8LiteralValue*) lit -> next)
lookup.cpp:        if (hash_address == lit -> hash_address &&
lookup.cpp:            len == lit -> length &&
lookup.cpp:            memcmp(lit -> value, str, len * sizeof(char)) == 0)
lookup.cpp:    lit -> Initialize(str, len, hash_address, symbol_pool.Length());
lookup.cpp:    lit -> next = base[k];
lookup.cpp:    unsigned count = utf8_literals -> Length();
lookup.cpp:        if (! leftmost_constant_expr -> NullLiteralCast())
lookup.cpp:            leftmost_constant_expr -> value = (*utf8_literals)[0];
lookup.cpp:            length += (*utf8_literals)[i] -> length;
lookup.cpp:            assert(literal -> value);
lookup.cpp:            memcpy(&str[index], literal -> value,
lookup.cpp:                   literal -> length * sizeof(char));
lookup.cpp:            index += literal -> length;
lookup.cpp:        leftmost_constant_expr -> value = FindOrInsert(str, length);
lookup.cpp:    utf8_literals -> Reset();
lookup.cpp:    if (expression -> IsConstant())
lookup.cpp:        // constants with blank strings, and later we replace the left-most
lookup.cpp:            DYNAMIC_CAST<Utf8LiteralValue*> (expression -> value);
lookup.cpp:        assert(literal -> value);
lookup.cpp:        utf8_literals -> Next() = literal;
lookup.cpp:            expression -> value = FindOrInsert("", 0);
lookup.cpp:    AstBinaryExpression* binary_expr = expression -> BinaryExpressionCast();
lookup.cpp:    AstCastExpression* cast_expr = expression -> CastExpressionCast();
lookup.cpp:        expression -> ParenthesizedExpressionCast();
lookup.cpp:    AstNullLiteral* null_expr = expression -> NullLiteralCast();
lookup.cpp:        AstExpression* left  = binary_expr -> left_expression;
lookup.cpp:        AstExpression* right = binary_expr -> right_expression;
lookup.cpp:        if (left -> IsConstant() ||
lookup.cpp:            left -> Type() == expression -> Type())
lookup.cpp:        if ((right -> IsConstant() ||
lookup.cpp:             right -> Type() == expression -> Type()) &&
lookup.cpp:                ! left -> NullLiteralCast() && ! right -> NullLiteralCast())
lookup.cpp:                right -> symbol = expression -> Type();
lookup.cpp:    else if (cast_expr && EndsInKnownString(cast_expr -> expression))
lookup.cpp:        if (leftmost_constant_expr == cast_expr -> expression &&
lookup.cpp:            cast_expr -> expression -> Type() == cast_expr -> Type())
lookup.cpp:    else if (paren_expr && EndsInKnownString(paren_expr -> expression))
lookup.cpp:        if (leftmost_constant_expr == paren_expr -> expression &&
lookup.cpp:            ! leftmost_constant_expr -> NullLiteralCast())
lookup.cpp:        // part of a chain of strings, as it is not a compile-time constant.
lookup.cpp:        utf8_literals -> Next() = FindOrInsert(null_literal, 4);
lookup.cpp:        else expression -> value = FindOrInsert("", 0);
lookup.cpp:// number of utf8 literals. Note that it even flattens non-constant expressions
lookup.cpp:// get in the way.  After this method, expression -> IsConstant() will return
lookup.cpp:        int k = ls -> hash_address % hash_size;
lookup.cpp:        ls -> next = base[k];
lookup.cpp:    for (symbol = base[k]; symbol; symbol = (LiteralSymbol*) symbol -> next)
lookup.cpp:        if (hash_address == symbol -> hash_address &&
lookup.cpp:            len == symbol -> NameLength() &&
lookup.cpp:            memcmp(symbol -> Name(), str, len * sizeof(wchar_t)) == 0)
lookup.cpp:    symbol -> Initialize(str, hash_address, len);
lookup.cpp:    symbol -> next = base[k];
lookup.cpp:// JLS2 6.8 describes the well-established Java naming conventions.
lookup.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
lookup.h:        while (--len >= 0)
lookup.h:            hash_value = (hash_value << 5) - hash_value + *head++;
lookup.h:        while (--len >= 0)
lookup.h:            hash_value = (hash_value << 5) - hash_value + *head++;
lookup.h:        Initialize(entry -> directory, name_, length_);
lookup.h:// treat filenames in a case-insensitive fashion.
lookup.h:        return Utf8_literal ? Utf8_literal -> value : (char*) NULL;
lookup.h:        return Utf8_literal ? Utf8_literal -> length : 0;
lookup.h:    return (unsigned) Identity() -> index;
Binary file lookup.o matches
lpginput.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
Binary file lpginput.o matches
modifier.cpp:// . Modifiers not in the recommended order (controlled by +Pmodifier-order).
modifier.cpp://   +Predundant-modifiers).
modifier.cpp:    for (unsigned i = 0; i < modifiers -> NumModifiers(); i++)
modifier.cpp:        Ast* mod = modifiers -> Modifier(i);
modifier.cpp:        AstAnnotation* annotation = mod -> AnnotationCast();
modifier.cpp:        AstModifierKeyword* keyword = mod -> ModifierKeywordCast();
modifier.cpp:                               lex_stream -> NameString(annotation -> name ->
modifier.cpp:        switch (lex_stream -> Kind(keyword -> modifier_token))
modifier.cpp:                           lex_stream -> NameString(keyword -> modifier_token),
modifier.cpp:                           lex_stream -> NameString(keyword ->
modifier.cpp:                               lex_stream -> NameString(keyword ->
modifier.cpp:                               lex_stream -> NameString(keyword ->
modifier.cpp:                                   lex_stream -> NameString(keyword ->
modifier.cpp:    return ProcessModifiers(package -> modifiers_opt, L"a package", 0);
modifier.cpp:// Process modifiers of top-level types.
modifier.cpp:    AstClassDeclaration* class_decl = decl -> ClassDeclarationCast();
modifier.cpp:    AstEnumDeclaration* enum_decl = decl -> EnumDeclarationCast();
modifier.cpp:        decl -> InterfaceDeclarationCast();
modifier.cpp:        decl -> AnnotationDeclarationCast();
modifier.cpp:        context = L"a top-level class";
modifier.cpp:        for (unsigned i = 0; i < enum_decl -> NumEnumConstants(); i++)
modifier.cpp:            if (enum_decl -> EnumConstant(i) -> class_body_opt)
modifier.cpp:            ? L"a top-level enumeration (all enum constants without a body)"
modifier.cpp:            : L"a top-level enumeration (some enum constants with a body)";
modifier.cpp:            context = L"a top-level interface";
modifier.cpp:            context = L"a top-level annotation type";
modifier.cpp:    return ProcessModifiers(decl -> modifiers_opt, context, valid_flags,
modifier.cpp:    AstClassDeclaration* class_decl = decl -> ClassDeclarationCast();
modifier.cpp:    AstEnumDeclaration* enum_decl = decl -> EnumDeclarationCast();
modifier.cpp:        for (unsigned i = 0; i < enum_decl -> NumEnumConstants(); i++)
modifier.cpp:            if (enum_decl -> EnumConstant(i) -> class_body_opt)
modifier.cpp:    return ProcessModifiers(decl -> modifiers_opt, context, valid_flags,
modifier.cpp:    AstClassDeclaration* class_decl = decl -> ClassDeclarationCast();
modifier.cpp:    AstEnumDeclaration* enum_decl = decl -> EnumDeclarationCast();
modifier.cpp:        decl -> InterfaceDeclarationCast();
modifier.cpp:        decl -> AnnotationDeclarationCast();
modifier.cpp:        if (containing_type -> ACC_INTERFACE())
modifier.cpp:            for (unsigned i = 0; i < enum_decl -> NumEnumConstants(); i++)
modifier.cpp:                if (enum_decl -> EnumConstant(i) -> class_body_opt)
modifier.cpp:        if (containing_type -> ACC_INTERFACE())
modifier.cpp:    return ProcessModifiers(decl -> modifiers_opt, context, valid_flags,
modifier.cpp:    return ProcessModifiers(field_declaration -> modifiers_opt,
modifier.cpp:    return ProcessModifiers(decl -> modifiers_opt, L"a local variable",
modifier.cpp:    return ProcessModifiers(decl -> modifiers_opt, L"a formal parameter",
modifier.cpp:    return ProcessModifiers(decl -> modifiers_opt, L"a class's member method",
modifier.cpp:    return ProcessModifiers(method_declaration -> modifiers_opt,
modifier.cpp:    return ProcessModifiers(constructor_declaration -> modifiers_opt,
modifier.cpp:    return ProcessModifiers(decl -> modifiers_opt,
modifier.cpp:    return ProcessModifiers(initializer -> modifiers_opt,
modifier.cpp:    return ProcessModifiers(decl -> modifiers_opt, L"an enum constant", 0,
Binary file modifier.o matches
op.cpp:        {"iconst_m1", "push int constant -1", 0},
op.cpp:        {"invokespecial", "invoke constructor, private, or superclass instance method; dispatch based on compile-time type", 2},
op.cpp:            constant_pool[info_index] -> Describe(constant_pool);
op.cpp:    assert(sizeof(int) == 4 && "Debugger must have 32-bit int");
op.cpp:                        Coutput << "       <non-zero padding: " << au1 << '>'
op.cpp:                len =  high - low + 1;
op.cpp:                    len--;
op.cpp:                        Coutput << "       <non-zero padding: " << au1 << '>'
op.cpp:                    npairs--;
op.cpp:                    Coutput << "       <non-zero padding: " << au1 << '>'
op.cpp:   -1, // OP_IALOAD
op.cpp:   -1, // OP_FALOAD
op.cpp:   -1, // OP_AALOAD
op.cpp:   -1, // OP_BALOAD
op.cpp:   -1, // OP_CALOAD
op.cpp:   -1, // OP_SALOAD
op.cpp:   -1, // OP_ISTORE
op.cpp:   -2, // OP_LSTORE
op.cpp:   -1, // OP_FSTORE
op.cpp:   -2, // OP_DSTORE
op.cpp:   -1, // OP_ASTORE
op.cpp:   -1, // OP_ISTORE_0
op.cpp:   -1, // OP_ISTORE_1
op.cpp:   -1, // OP_ISTORE_2
op.cpp:   -1, // OP_ISTORE_3
op.cpp:   -2, // OP_LSTORE_0
op.cpp:   -2, // OP_LSTORE_1
op.cpp:   -2, // OP_LSTORE_2
op.cpp:   -2, // OP_LSTORE_3
op.cpp:   -1, // OP_FSTORE_0
op.cpp:   -1, // OP_FSTORE_1
op.cpp:   -1, // OP_FSTORE_2
op.cpp:   -1, // OP_FSTORE_3
op.cpp:   -2, // OP_DSTORE_0
op.cpp:   -2, // OP_DSTORE_1
op.cpp:   -2, // OP_DSTORE_2
op.cpp:   -2, // OP_DSTORE_3
op.cpp:   -1, // OP_ASTORE_0
op.cpp:   -1, // OP_ASTORE_1
op.cpp:   -1, // OP_ASTORE_2
op.cpp:   -1, // OP_ASTORE_3
op.cpp:   -3, // OP_IASTORE
op.cpp:   -4, // OP_LASTORE
op.cpp:   -3, // OP_FASTORE
op.cpp:   -4, // OP_DASTORE
op.cpp:   -3, // OP_AASTORE
op.cpp:   -3, // OP_BASTORE
op.cpp:   -3, // OP_CASTORE
op.cpp:   -3, // OP_SASTORE
op.cpp:   -1, // OP_POP
op.cpp:   -2, // OP_POP2
op.cpp:   -1, // OP_IADD
op.cpp:   -2, // OP_LADD
op.cpp:   -1, // OP_FADD
op.cpp:   -2, // OP_DADD
op.cpp:   -1, // OP_ISUB
op.cpp:   -2, // OP_LSUB
op.cpp:   -1, // OP_FSUB
op.cpp:   -2, // OP_DSUB
op.cpp:   -1, // OP_IMUL
op.cpp:   -2, // OP_LMUL
op.cpp:   -1, // OP_FMUL
op.cpp:   -2, // OP_DMUL
op.cpp:   -1, // OP_IDIV
op.cpp:   -2, // OP_LDIV
op.cpp:   -1, // OP_FDIV
op.cpp:   -2, // OP_DDIV
op.cpp:   -1, // OP_IREM
op.cpp:   -2, // OP_LREM
op.cpp:   -1, // OP_FREM
op.cpp:   -2, // OP_DREM
op.cpp:   -1, // OP_ISHL
op.cpp:   -1, // OP_LSHL
op.cpp:   -1, // OP_ISHR
op.cpp:   -1, // OP_LSHR
op.cpp:   -1, // OP_IUSHR
op.cpp:   -1, // OP_LUSHR
op.cpp:   -1, // OP_IAND
op.cpp:   -2, // OP_LAND
op.cpp:   -1, // OP_IOR
op.cpp:   -2, // OP_LOR
op.cpp:   -1, // OP_IXOR
op.cpp:   -2, // OP_LXOR
op.cpp:   -1, // OP_L2I
op.cpp:   -1, // OP_L2F
op.cpp:   -1, // OP_D2I
op.cpp:   -1, // OP_D2F
op.cpp:   -3, // OP_LCMP
op.cpp:   -1, // OP_FCMPL
op.cpp:   -1, // OP_FCMPG
op.cpp:   -3, // OP_DCMPL
op.cpp:   -3, // OP_DCMPG
op.cpp:   -1, // OP_IFEQ
op.cpp:   -1, // OP_IFNE
op.cpp:   -1, // OP_IFLT
op.cpp:   -1, // OP_IFGE
op.cpp:   -1, // OP_IFGT
op.cpp:   -1, // OP_IFLE
op.cpp:   -2, // OP_IF_ICMPEQ
op.cpp:   -2, // OP_IF_ICMPNE
op.cpp:   -2, // OP_IF_ICMPLT
op.cpp:   -2, // OP_IF_ICMPGE
op.cpp:   -2, // OP_IF_ICMPGT
op.cpp:   -2, // OP_IF_ICMPLE
op.cpp:   -2, // OP_IF_ACMPEQ
op.cpp:   -2, // OP_IF_ACMPNE
op.cpp:   -1, // OP_TABLESWITCH
op.cpp:   -1, // OP_LOOKUPSWITCH
op.cpp:   -1, // OP_IRETURN
op.cpp:   -2, // OP_LRETURN
op.cpp:   -1, // OP_FRETURN
op.cpp:   -2, // OP_DRETURN
op.cpp:   -1, // OP_ARETURN
op.cpp:   -1, // OP_PUTSTATIC, caller must adjust -1 if long or double
op.cpp:   -2, // OP_PUTFIELD, caller must adjust -1 if long or double
op.cpp:   -1, // OP_INVOKEVIRTUAL,  caller must adjust +return-args_length
op.cpp:   -1, // OP_INVOKESPECIAL,  caller must adjust +return-args_length
op.cpp:    0, // OP_INVOKESTATIC,   caller must adjust +return-args_length
op.cpp:   -1, // OP_INVOKEINTERFACE, caller must adjust +return-args_length
op.cpp:   -1, // OP_ATHROW
op.cpp:   -1, // OP_MONITORENTER
op.cpp:   -1, // OP_MONITOREXIT
op.cpp:    0, // OP_MULTIANEWARRAY, caller must adjust 1-dims
op.cpp:   -1, // OP_IFNULL
op.cpp:   -1, // OP_IFNONNULL
op.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
Binary file op.o matches
option.cpp:                end--;
option.cpp:            s << "\"-source\" only recognizes Java releases 1.3 (JLS 2 "
option.cpp:        s << "\"-source\" only recognizes Java releases 1.3 (JLS 2 features) "
option.cpp:        s << "\"-target\" only recognizes Java releases 1.1, 1.2, 1.3, 1.4, "
option.cpp:        s << "The directory specified in the \"-d\" option, \"" << name
option.cpp:        // Under Cygwin, we convert a Windows-style path into a UNIX-style
option.cpp:        if (arguments.argv[i][0] == '-')
option.cpp:            if (strcmp(arguments.argv[i], "-bootclasspath") == 0 ||
option.cpp:                strcmp(arguments.argv[i], "--bootclasspath") == 0)
option.cpp:                // Create a clean copy of the -bootclasspath argument so we
option.cpp:            else if (strcmp(arguments.argv[i], "-classpath") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "--classpath") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "-cp") == 0)
option.cpp:                // Create a clean copy of the -classpath argument so we can
option.cpp:            else if (strcmp(arguments.argv[i], "-d") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "--target-directory") == 0)
option.cpp:            else if (strcmp(arguments.argv[i], "-debug") == 0)
option.cpp:            else if (strcmp(arguments.argv[i], "-depend") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "--depend") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "-Xdepend") == 0)
option.cpp:            else if (strcmp(arguments.argv[i], "-deprecation") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "--deprecation") == 0)
option.cpp:            else if (strcmp(arguments.argv[i], "-encoding") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "--encoding") == 0)
option.cpp:                                    "-encoding");
option.cpp:            else if (strcmp(arguments.argv[i], "-extdirs") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "--extdirs") == 0)
option.cpp:                // Create a clean copy of the -extdirs argument so we can
option.cpp:                // This defaults to SOURCE | LINES if no -g option was
option.cpp:                // explicitly specified. "-g" is equivalent to
option.cpp:                // "-g:source,lines,vars".
option.cpp:                if (! strcmp(arguments.argv[i], "-g:none"))
option.cpp:                else if (! strcmp(arguments.argv[i], "-g:source") )
option.cpp:                else if (! strcmp(arguments.argv[i], "-g:lines"))
option.cpp:                else if (! strcmp(arguments.argv[i], "-g:vars"))
option.cpp:                else if (! strcmp(arguments.argv[i], "-g:source,lines") ||
option.cpp:                         ! strcmp(arguments.argv[i], "-g:lines,source"))
option.cpp:                else if (! strcmp(arguments.argv[i], "-g:source,vars") ||
option.cpp:                         ! strcmp(arguments.argv[i], "-g:vars,source"))
option.cpp:                else if (! strcmp(arguments.argv[i], "-g:lines,vars") ||
option.cpp:                         ! strcmp(arguments.argv[i], "-g:vars,lines"))
option.cpp:                else if (! strcmp(arguments.argv[i], "-g") ||
option.cpp:                         ! strcmp(arguments.argv[i], "-g:source,lines,vars") ||
option.cpp:                         ! strcmp(arguments.argv[i], "-g:source,vars,lines") ||
option.cpp:                         ! strcmp(arguments.argv[i], "-g:lines,source,vars") ||
option.cpp:                         ! strcmp(arguments.argv[i], "-g:lines,vars,source") ||
option.cpp:                         ! strcmp(arguments.argv[i], "-g:vars,source,lines") ||
option.cpp:                         ! strcmp(arguments.argv[i], "-g:vars,lines,source"))
option.cpp:            else if (strcmp(arguments.argv[i], "-help") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "--help") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "-h") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "-?") == 0)
option.cpp:            else if (strcmp(arguments.argv[i], "-nowarn") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "--nowarn") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "-q") == 0)
option.cpp:            else if (strcmp(arguments.argv[i], "-Werror") == 0)
option.cpp:            else if (strcmp(arguments.argv[i], "-nowrite") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "--nowrite") == 0)
option.cpp:            else if (strcmp(arguments.argv[i], "-O") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "--optimize") == 0)
option.cpp:            else if (strcmp(arguments.argv[i], "-source") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "--source") == 0)
option.cpp:                                        "-source");
option.cpp:            else if (strcmp(arguments.argv[i], "-sourcepath") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "--sourcepath") == 0)
option.cpp:                // Create a clean copy of the -sourcepath argument so we can
option.cpp:            else if (strcmp(arguments.argv[i], "-target") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "--target") == 0)
option.cpp:                                        "-target");
option.cpp:            else if (strcmp(arguments.argv[i], "-verbose") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "--verbose") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "-v") == 0)
option.cpp:            else if (strcmp(arguments.argv[i], "-version") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "--version") == 0 ||
option.cpp:                     strcmp(arguments.argv[i], "-V") == 0)
option.cpp:            else if (strcmp(arguments.argv[i], "-Xstdout") == 0)
option.cpp:                // FIXME: Javac 1.3 takes an argument to -Xstdout, as the name
option.cpp:            else if (strcmp(arguments.argv[i], "-Xswitchcheck") == 0)
option.cpp:                // Note that we've already consumed -Xdepend, -Xstdout,
option.cpp:                // and -Xswitchcheck.
option.cpp:            else if (arguments.argv[i][1] != '-')
option.cpp:             (arguments.argv[i][0] == '-' && arguments.argv[i][1] == '-')))
option.cpp:                strcmp(arguments.argv[i], "--incremental") == 0)
option.cpp:                     strcmp(arguments.argv[i], "--noassert") == 0)
option.cpp:                     strcmp(arguments.argv[i], "--nobytecode") == 0)
option.cpp:                     strcmp(arguments.argv[i], "--dump-errors") == 0)
option.cpp:                     strcmp(arguments.argv[i], "--emacs") == 0)
option.cpp:                     strcmp(arguments.argv[i], "--full-dependence") == 0)
option.cpp:                        keyword_map[i].length = image - name - 1;
option.cpp:                     strcmp(arguments.argv[i], "--makefile") == 0)
option.cpp:                     strcmp(arguments.argv[i], "--pedantic") == 0)
option.cpp:                     strncmp(arguments.argv[i], "--tab", 5) == 0)
option.cpp:                if (arguments.argv[i][1] == '-')
option.cpp:                    int digit = *p - '0';
option.cpp:                     strcmp(arguments.argv[i], "--unzip-dependence") == 0)
option.cpp:            else if (strcmp(arguments.argv[i], "--zero-cautions") == 0)
option.cpp:    // Specify defaults for -source and -target.
option.cpp:    for (int k = filename_index.Length() - 1; k >= 0; k--)
option.cpp:        first_file_index--;
option.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
Binary file option.o matches
parser.cpp:        free_list_nodes = free_list_nodes -> next;
parser.cpp:    else p = list_node_pool -> NewListNode();
parser.cpp:        AstListNode* root = tail -> next;
parser.cpp:        tail -> next = free_list_nodes;
parser.cpp:    lex_stream_ -> Reset();
parser.cpp:    if (lex_stream_ -> PackageToken())
parser.cpp:        list_node_pool = new StoragePool(lex_stream_ -> NumTokens());
parser.cpp:                ast -> CompilationUnitCast();
parser.cpp:                ! compilation_unit -> BadCompilationUnitCast())
parser.cpp:                    compilation_unit -> package_declaration_opt;
parser.cpp:    lex_stream_ -> Reset();
parser.cpp:    body_pool = new StoragePool(lex_stream_ -> NumTokens());
parser.cpp:    list_node_pool = new StoragePool(lex_stream_ -> NumTokens());
parser.cpp:        compilation_unit = ast -> CompilationUnitCast();
parser.cpp:            ! compilation_unit -> BadCompilationUnitCast())
parser.cpp:            if (compilation_unit -> NumTypeDeclarations() == 0)
parser.cpp:                compilation_unit -> MarkEmpty();
parser.cpp:         compilation_unit -> ast_pool = body_pool;
parser.cpp:    TokenObject curtok = lex_stream -> Gettoken();
parser.cpp:              current_kind = lex_stream -> Kind(curtok);
parser.cpp:    state_stack_top = -1;
parser.cpp:            state_stack_top--; // make reduction look like a shift-reduce
parser.cpp:            curtok = lex_stream -> Gettoken();
parser.cpp:            current_kind = lex_stream -> Kind(curtok);
parser.cpp:            act -= ERROR_ACTION;
parser.cpp:            curtok = lex_stream -> Gettoken();
parser.cpp:            current_kind = lex_stream -> Kind(curtok);
parser.cpp:            state_stack_top -= (rhs[act] - 1);
parser.cpp:            (this ->* rule_action[act])();
parser.cpp:        if (parse_stack[0] && parse_stack[0] -> CompilationUnitCast())
parser.cpp:            ((AstCompilationUnit*) parse_stack[0]) -> MarkBad();
parser.cpp:    assert(class_body -> UnparsedClassBodyCast());
parser.cpp:    ast_pool = class_body -> pool;
parser.cpp:    body_pool = class_body -> pool;
parser.cpp:    list_node_pool = new StoragePool(lex_stream_ -> NumTokens());
parser.cpp:    class_body -> MarkParsed();
parser.cpp:    for (i = 0; i < class_body -> NumConstructors(); i++)
parser.cpp:            class_body -> Constructor(i);
parser.cpp:        if (constructor_decl -> constructor_symbol)
parser.cpp:            AstMethodBody* block = constructor_decl -> constructor_body;
parser.cpp:            end_token = block -> right_brace_token; // last token in the body
parser.cpp:            AstMethodBody* new_body = ParseSegment(block -> left_brace_token);
parser.cpp:            else constructor_decl -> constructor_body = new_body;
parser.cpp:    for (i = 0; i < class_body -> NumMethods(); i++)
parser.cpp:        AstMethodDeclaration* method_decl = class_body -> Method(i);
parser.cpp:        if (method_decl -> method_symbol && method_decl -> method_body_opt)
parser.cpp:            AstMethodBody* block = method_decl -> method_body_opt;
parser.cpp:            end_token = block -> right_brace_token;
parser.cpp:            AstMethodBody* new_block = ParseSegment(block -> left_brace_token);
parser.cpp:            else method_decl -> method_body_opt = new_block;
parser.cpp:    for (i = 0; i < class_body -> NumNestedClasses(); i++)
parser.cpp:            ! Body(class_body -> NestedClass(i) -> class_body);
parser.cpp:    for (i = 0; i < class_body -> NumNestedInterfaces(); i++)
parser.cpp:            ! Body(class_body -> NestedInterface(i) -> class_body);
parser.cpp:    ast_pool = class_body -> pool;
parser.cpp:    body_pool = class_body -> pool;
parser.cpp:    list_node_pool = new StoragePool(stream -> NumTokens());
parser.cpp:    for (i = 0; i < class_body -> NumStaticInitializers(); i++)
parser.cpp:         AstMethodBody* block = class_body -> StaticInitializer(i) -> block;
parser.cpp:         end_token = block -> right_brace_token; // last token in the body
parser.cpp:         class_body -> StaticInitializer(i) -> block =
parser.cpp:             ParseSegment(block -> left_brace_token);
parser.cpp:        if (! class_body -> StaticInitializer(i) -> block)
parser.cpp:            class_body -> StaticInitializer(i) -> block = block;
parser.cpp:    for (i = 0; i < class_body -> NumInstanceInitializers(); i++)
parser.cpp:        AstMethodBody* block = class_body -> InstanceInitializer(i) -> block;
parser.cpp:        end_token = block -> right_brace_token; // last token in the body
parser.cpp:        class_body -> InstanceInitializer(i) -> block =
parser.cpp:            ParseSegment(block -> left_brace_token);
parser.cpp:        if (! class_body -> InstanceInitializer(i) -> block)
parser.cpp:            class_body -> InstanceInitializer(i) -> block = block;
parser.cpp:    for (i = 0; i < class_body -> NumNestedClasses(); i++)
parser.cpp:            ! Initializer(class_body -> NestedClass(i) -> class_body);
parser.cpp:    for (i = 0; i < class_body -> NumNestedInterfaces(); i++)
parser.cpp:            ! Initializer(class_body -> NestedInterface(i) -> class_body);
parser.cpp:    lex_stream -> Reset(start_token);
parser.cpp:    state_stack_top = -1;
parser.cpp:            state_stack_top--; // make reduction look like a shift-reduce
parser.cpp:            curtok = lex_stream -> Gettoken(end_token);
parser.cpp:            current_kind = lex_stream -> Kind(curtok);
parser.cpp:            act -= ERROR_ACTION;
parser.cpp:            curtok = lex_stream -> Gettoken(end_token);
parser.cpp:            current_kind = lex_stream -> Kind(curtok);
parser.cpp:            state_stack_top -= (rhs[act] - 1);
parser.cpp:            (this ->* rule_action[act])();
parser.cpp:        for (k = state_stack_top - 1;
parser.cpp:             k >= 0 && location_stack[k] == Loc(curtok); k--);
parser.cpp:        curtok = lex_stream -> Gettoken(end_token);
parser.cpp:        int act = stack[state_stack_top--];
parser.cpp:        int current_kind = lex_stream -> Kind(curtok);
parser.cpp:                state_stack_top--; // make reduction look like a shift-reduce
parser.cpp:                curtok = lex_stream -> Gettoken(end_token);
parser.cpp:                current_kind = lex_stream -> Kind(curtok);
parser.cpp:                act -= ERROR_ACTION;
parser.cpp:                curtok = lex_stream -> Gettoken(end_token);
parser.cpp:                current_kind = lex_stream -> Kind(curtok);
parser.cpp:                state_stack_top -= (rhs[act] - 1);
parser.cpp:                (this ->* rule_action[act])();
parser.cpp:        buffer[0] = lex_stream -> Previous(buffer[1]);
parser.cpp:            buffer[k] = lex_stream -> Next(buffer[k - 1]);
parser.cpp:        for (last_index = MAX_DISTANCE - 1;
parser.cpp:                 lex_stream -> Kind(buffer[last_index]) == EOFT_SYMBOL;
parser.cpp:             last_index--);
parser.cpp:        error_token = buffer[MAX_DISTANCE - MIN_DISTANCE + 2];
parser.cpp:    lex_stream -> Reset(buffer[repair.buffer_position]);
parser.cpp:         top >= 0 && repair.num_deletions >= stack_deletions; top--)
parser.cpp:                 repair.num_deletions >= (stack_deletions + i - 1); i++)
parser.cpp:            int j = ParseCheck(stck, top, lex_stream -> Kind(buffer[i]),
parser.cpp:            if ((j - i + 1) > MIN_DISTANCE)
parser.cpp:                int k = stack_deletions + i - 1;
parser.cpp:                    (j - k) > (repair.distance - repair.num_deletions))
parser.cpp:        ct = lex_stream -> Kind(buffer[indx]);
parser.cpp:        lex_stream -> Reset(lex_stream -> Next(buffer[indx]));
parser.cpp:        lhs_symbol = first_token - NT_OFFSET;
parser.cpp:        temp_stack_top = stack_top - 1;
parser.cpp:        indx = buffer_position - 1;
parser.cpp:        lex_stream -> Reset(buffer[buffer_position]);
parser.cpp:            temp_stack_top--;
parser.cpp:                 act > ERROR_ACTION)        /*shift-reduce action*/
parser.cpp:            ct = lex_stream -> Kind(buffer[indx]);
parser.cpp:            lex_stream -> Reset(lex_stream -> Next(buffer[indx]));
parser.cpp:                 act -= ERROR_ACTION;
parser.cpp:            temp_stack_top -= (rhs[act]-1);
parser.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
parser.h:        return location_stack[state_stack_top + (i - 1)];
parser.h:    inline Ast*& Sym(int i) { return parse_stack[state_stack_top + (i - 1)]; }
parser.h:    // delete AST subtrees from the parse stack - those corresponding to
Binary file parser.o matches
platform.cpp:    for (ptr = s; *ct && n-- > 0; ptr++, ct++)
platform.cpp:    while (n-- > 0)
platform.cpp:    return (*cs == *ct ? 0 : (*cs < *ct ? -1 : 1));
platform.cpp:    while (*cs == *ct && *cs && *ct && n-- > 0)
platform.cpp:    return (n <= 0 || *cs == *ct ? 0 : (*cs < *ct ? -1 : 1));
platform.cpp:        stat_struct -> st_ino += name[strlen(name) - 1];
platform.cpp:    for (int i = strlen(filename); i >= 0; i--)
platform.cpp:// Given three strings, return a newly-allocated string which is their
platform.cpp:    // The below is more efficient than this commented-out code.
platform.cpp:    u4 n = num < 0 ? - num : num;
platform.cpp:        *--str = U_0 + n % 10;
platform.cpp:        *--str = U_MINUS;
platform.cpp:        *--str = c < 10 ? U_0 + c : U_a - 10 + c;
platform.cpp:    u4 n = num < 0 ? - num : num;
platform.cpp:        *--wstr = U_0 + n % 10;
platform.cpp:        *--wstr = U_MINUS;
platform.cpp:    ULongInt n = num < 0 ? (ULongInt) - num : (ULongInt) num;
platform.cpp:        *--str = U_0 + (n % 10).LowWord();
platform.cpp:        *--str = U_MINUS;
platform.cpp:        *--str = U_0 + (n % 10).LowWord();
platform.cpp:        *--str = c < 10 ? U_0 + c : U_a - 10 + c;
platform.cpp:    base = str - 1;
platform.cpp:        *base-- = U_x;
platform.cpp:    // Therefore, f == f1 * 2**i, and i == be + bbits - 1.
platform.cpp:    denorm = i <= -IEEEfloat::Bias();
platform.cpp:    // log(x)   ~=~ log(1.5) + (x-1.5)/1.5
platform.cpp:    //          ~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10))
platform.cpp:    // k = i*0.30103 + ( 0.17609125 + (f1-1.5)*0.28952965 );
platform.cpp:    // The error in the first-order Taylor series approximation
platform.cpp:    // and 152 * 0.30103 * 2^-23 ~=~ 5.5e-6,
platform.cpp:    // adding 1e-5 to the constant term more than suffices.
platform.cpp:    fs = IEEEfloat(i) * 0.30103f + 0.1761f + (f1 - 1.5f) * 0.28952965f;
platform.cpp:    f1 = f.IsNegative() ? -f : f;
platform.cpp:        k--;
platform.cpp:            k--;
platform.cpp:            f1 -= fs * (i4) dig;
platform.cpp:        s2 = -be;
platform.cpp:        b2 -= k;
platform.cpp:        b5 = -k;
platform.cpp:               : 2 + IEEEfloat::FractSize() - bbits;
platform.cpp:        b2 -= i;
platform.cpp:        m2 -= i;
platform.cpp:        s2 -= i;
platform.cpp:        if ((j = b5 - m5) != 0)
platform.cpp:    if ((i = ((s5 ? 32 - S.hi0bits() : 1) + s2) & 0x1f) != 0)
platform.cpp:        i = 32 - i;
platform.cpp:        i -= 4;
platform.cpp:        k--;
platform.cpp:        BigInt delta = S - mhi;
platform.cpp:        while (*--s == U_9)
platform.cpp:    length = s - str + 1; // strlen(str) + '.'
platform.cpp:    case -3: case -2: case -1:
platform.cpp:        if (*(s - 1) == U_0)
platform.cpp:            length--;
platform.cpp:            s--;
platform.cpp:        s--;
platform.cpp:        length += -exp;
platform.cpp:            *(s + (neg ? 2 : 1) - exp) = *s;
platform.cpp:        while (s-- != str);
platform.cpp:        for (i = (neg ? 1 : 0); i < (neg ? 2 : 1) - exp; i++)
platform.cpp:            str[length++ - 1] = U_0;
platform.cpp:        s = &str[length - 2];
platform.cpp:        while (s-- != str + exp + 1);
platform.cpp:            while (s-- != str);
platform.cpp:            str[length++ - 1] = U_0;
platform.cpp:            length++; // exponent '-'
platform.cpp:            exp = -exp;
platform.cpp:            *--s = exp % 10 + U_0;
platform.cpp:            *--s = U_MINUS;
platform.cpp:        *--s = U_E;
platform.cpp:        --s;
platform.cpp:            *s = *(s - (neg ? 2 : 1)); // shift digits right, to add '.'
platform.cpp:        while (--s != str + (neg ? 2 : 1));
platform.cpp:    // Therefore, d == d1 * 2**i, and i == be + bbits - 1.
platform.cpp:    denorm = i <= -IEEEdouble::Bias();
platform.cpp:    // log(x)   ~=~ log(1.5) + (x-1.5)/1.5
platform.cpp:    //          ~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10))
platform.cpp:    //   + ( 0.176091259055681 + (d2-1.5)*0.289529654602168 );
platform.cpp:    // The error in the first-order Taylor series approximation
platform.cpp:    // and 1077 * 0.30103 * 2^-52 ~=~ 7.2e-14,
platform.cpp:    // adding 1e-13 to the constant term more than suffices.
platform.cpp:        + (d1 - 1.5) * 0.289529654602168;
platform.cpp:    d1 = d.IsNegative() ? -d : d;
platform.cpp:        k--;
platform.cpp:            k--;
platform.cpp:            d1 -= ds * (i4) dig;
platform.cpp:        s2 = -be;
platform.cpp:        b2 -= k;
platform.cpp:        b5 = -k;
platform.cpp:               : 2 + IEEEdouble::FractSize() - bbits;
platform.cpp:        b2 -= i;
platform.cpp:        m2 -= i;
platform.cpp:        s2 -= i;
platform.cpp:        if ((j = b5 - m5) != 0)
platform.cpp:    if ((i = ((s5 ? 32 - S.hi0bits() : 1) + s2) & 0x1f) != 0)
platform.cpp:        i = 32 - i;
platform.cpp:        i -= 4;
platform.cpp:        k--;
platform.cpp:        BigInt delta = S - mhi;
platform.cpp:        while (*--s == U_9)
platform.cpp:    length = s - str + 1; // strlen(str) + '.'
platform.cpp:    case -3: case -2: case -1:
platform.cpp:        if (*(s - 1) == U_0)
platform.cpp:            length--;
platform.cpp:            s--;
platform.cpp:        s--;
platform.cpp:        length += -exp;
platform.cpp:            *(s + (neg ? 2 : 1) - exp) = *s;
platform.cpp:        while (s-- != str);
platform.cpp:        for (i = (neg ? 1 : 0); i < (neg ? 2 : 1) - exp; i++)
platform.cpp:            str[length++ - 1] = U_0;
platform.cpp:        s = &str[length - 2];
platform.cpp:        while (s-- != str + exp + 1);
platform.cpp:            while (s-- != str);
platform.cpp:            str[length++ - 1] = U_0;
platform.cpp:            length++; // exponent '-'
platform.cpp:            exp = -exp;
platform.cpp:            *--s = exp % 10 + U_0;
platform.cpp:            *--s = U_MINUS;
platform.cpp:        *--s = U_E;
platform.cpp:        --s;
platform.cpp:            *s = *(s - (neg ? 2 : 1)); // shift digits right, to add '.'
platform.cpp:        while (--s != str + (neg ? 2 : 1));
platform.cpp:    if (os -> flags() & os -> dec)
platform.cpp:    else if (os -> flags() & os -> oct)
platform.cpp:        *os << (os -> flags() & os -> showbase
platform.cpp:    else if (os -> flags() & os -> hex)
platform.cpp:        *os << (os -> flags() & os -> showbase
platform.cpp:         os -> flush();
platform.cpp:    if (os -> flags() & os -> dec)
platform.cpp:    else if (os -> flags() & os -> oct)
platform.cpp:        *os << (os -> flags() & os -> showbase
platform.cpp:    else if (os -> flags() & os -> hex)
platform.cpp:        *os << (os -> flags() & os -> showbase
platform.cpp:        os -> flush();
platform.cpp:const wchar_t StringConstant::US_MINUS[] = {U_MI, U_NU}; // L"-"
platform.cpp:const wchar_t StringConstant::US_MINUS_EQUAL[] = {U_MI, U_EQ, U_NU}; // L"-="
platform.cpp:const wchar_t StringConstant::US_MINUS_MINUS[] = {U_MI, U_MI, U_NU}; // L"--"
platform.cpp:const wchar_t StringConstant::US_MI[] = {U_MI, U_NU}; // L"-"
platform.cpp:    "Jikes Compiler - " JIKES_VERSION_STRING
platform.cpp:    "\nCopyright (C) IBM Corporation 1997-2003, 2004.\n"
platform.cpp:    "- Licensed Materials - Program Property of IBM - All Rights Reserved.\n";
platform.cpp:    U_MINUS, U_I, U_n, U_f, U_i, U_n, U_i, U_t, U_y, U_NU}; // "-Infinity"
platform.cpp:    U_MINUS, U_0, U_DOT, U_0, U_NU}; // "-0.0"
platform.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
platform.h:// the code for non-ascii platforms. At some point we'll want to be able to
platform.h:// like, pull a cvs tree with the tag v1-06.
platform.h:// the value are 16-bits or U8S_ for 8 bits. The initial underscore is
platform.h:// All string-related values are represented internally in ASCII/UNICODE
platform.h:    U_MINUS = 45,             U_MI = U_MINUS,             // L'-'
platform.h:    static const wchar_t US_MINUS[]; // L"-"
platform.h:    static const wchar_t US_MINUS_EQUAL[]; // L"-="
platform.h:    static const wchar_t US_MINUS_MINUS[]; // L"--"
platform.h:    static const wchar_t US_MI[]; // L"-"
platform.h:    static const char U8S_neg_Infinity[]; // "-Infinity"
platform.h:    static const char U8S_neg_Zero[]; // "-0.0"
platform.h:    IntToString(u4, int width); // Unsigned zero-padded hexadecimal.
platform.h:    int Length() { return (&info[TAIL_INDEX]) - str; }
platform.h:    int Length() { return (&winfo[TAIL_INDEX]) - wstr; }
platform.h:    int Length() { return (&info[TAIL_INDEX]) - str; }
platform.h:                for (int i = 3; i >= 0; i--)
platform.h:                        str[i] = U_A - 10 + d;
platform.h:    char fill(char c) { return os -> fill(c); }
platform.h:        os -> flush();
platform.h:        return os -> width(w);
Binary file platform.o matches
scanner.cpp:    current_token_index = lex -> GetNextToken(); // Get 0th token.
scanner.cpp:    current_token = &(lex -> token_stream[current_token_index]);
scanner.cpp:    current_token -> SetKind(0);
scanner.cpp:        LexStream::Comment* current_comment = &(lex -> comment_stream.Next());
scanner.cpp:        current_comment -> string = NULL;
scanner.cpp:        current_comment -> length = 0;
scanner.cpp:        current_comment -> previous_token = BAD_TOKEN;
scanner.cpp:        current_comment -> location = 0;
scanner.cpp:    lex -> line_location.Next() = 0; // Mark starting location of line # 0
scanner.cpp:    lex -> CompressSpace();
scanner.cpp:    file_symbol -> lex_stream = lex;
scanner.cpp:    lex -> ReadInput();
scanner.cpp:    cursor = lex -> InputBuffer();
scanner.cpp:        lex -> CompressSpace();
scanner.cpp:            lex -> SortMessages();
scanner.cpp:            for (unsigned i = 0; i < lex -> bad_tokens.Length(); i++)
scanner.cpp:                JikesAPI::getInstance() ->
scanner.cpp:                    reportError(&(lex -> bad_tokens[i]));
scanner.cpp:        lex -> DestroyInput(); // get rid of input buffer
scanner.cpp:    file_symbol -> lex_stream = lex;
scanner.cpp:    input_buffer_tail = &cursor[lex -> InputBufferLength()];
scanner.cpp:        if (! current_token_index || current_token -> Kind())
scanner.cpp:                lex -> GetNextToken(cursor - lex -> InputBuffer());
scanner.cpp:            current_token = &(lex -> token_stream[current_token_index]);
scanner.cpp:            current_token -> ResetInfoAndSetLocation(cursor -
scanner.cpp:                                                     lex -> InputBuffer());
scanner.cpp:            current_token -> SetDeprecated();
scanner.cpp:        (this ->* classify_token[*cursor < 128 ? *cursor : 128])();
scanner.cpp:    lex -> line_location.Next() = input_buffer_tail - lex -> InputBuffer();
scanner.cpp:    current_token -> SetKind(TK_EOF);
scanner.cpp:    assert(current_token_index == lex -> token_stream.Length() - 1);
scanner.cpp:        lex -> token_stream[left_brace].SetRightBrace(current_token_index);
scanner.cpp:    const wchar_t* start = cursor - 1;
scanner.cpp:    current_token -> SetKind(0);
scanner.cpp:        current_comment = &(lex -> comment_stream.Next());
scanner.cpp:        current_comment -> string = NULL;
scanner.cpp:        current_comment -> previous_token = current_token_index - 1;
scanner.cpp:        current_comment -> location = start - lex -> InputBuffer();
scanner.cpp:                lex -> line_location.Next() = cursor - lex -> InputBuffer();
scanner.cpp:                        current_comment -> length = cursor - start;
scanner.cpp:                    if (cursor[-1] == U_AT &&
scanner.cpp:        if (current_token -> Deprecated())
scanner.cpp:                        current_comment -> length = cursor - start;
scanner.cpp:                lex -> line_location.Next() = cursor - lex -> InputBuffer();
scanner.cpp:    lex -> ReportMessage(StreamError::UNTERMINATED_COMMENT,
scanner.cpp:                         start - lex -> InputBuffer(),
scanner.cpp:                         cursor - lex -> InputBuffer() - 1);
scanner.cpp:        current_comment -> length = cursor - 1 - start;
scanner.cpp:    if (current_token -> Deprecated())
scanner.cpp:    current_token -> SetKind(0);
scanner.cpp:        LexStream::Comment* current_comment = &(lex -> comment_stream.Next());
scanner.cpp:        current_comment -> string = NULL;
scanner.cpp:        current_comment -> previous_token = current_token_index - 1;
scanner.cpp:        current_comment -> location = current_token -> Location();
scanner.cpp:        current_comment -> length = (cursor - lex -> InputBuffer()) -
scanner.cpp:            current_comment -> location;
scanner.cpp:// first non-space character following its initial position.
scanner.cpp:    if (current_token -> Deprecated())
scanner.cpp:    current_token -> SetKind(0);
scanner.cpp:            lex -> line_location.Next() = cursor + 1 - lex -> InputBuffer();
scanner.cpp:    current_token -> SetKind(TK_CharacterLiteral);
scanner.cpp:            lex -> ReportMessage(StreamError::ESCAPE_EXPECTED,
scanner.cpp:                                 current_token -> Location() + 1,
scanner.cpp:                                 current_token -> Location() + 1);
scanner.cpp:            lex -> ReportMessage(StreamError::EMPTY_CHARACTER_CONSTANT,
scanner.cpp:                                 current_token -> Location(),
scanner.cpp:                                 current_token -> Location() + 1);
scanner.cpp:            ptr--;
scanner.cpp:                lex -> ReportMessage(StreamError::ESCAPE_EXPECTED,
scanner.cpp:                                     current_token -> Location() + 1,
scanner.cpp:                                     current_token -> Location() + 1);
scanner.cpp:                ptr--;
scanner.cpp:            ptr--;
scanner.cpp:            lex -> ReportMessage(StreamError::INVALID_ESCAPE_SEQUENCE,
scanner.cpp:                                 current_token -> Location() + 1,
scanner.cpp:                                 current_token -> Location() + ptr - cursor);
scanner.cpp:        ptr--;
scanner.cpp:        // user tried to do a multiple character alpha-numeric string.
scanner.cpp:            ptr--;
scanner.cpp:            lex -> ReportMessage((*ptr != U_SINGLE_QUOTE || ptr == cursor
scanner.cpp:                                 current_token -> Location(),
scanner.cpp:                                 ptr - lex -> InputBuffer());
scanner.cpp:    current_token ->
scanner.cpp:                                                         ptr - cursor));
scanner.cpp:    current_token -> SetKind(TK_StringLiteral);
scanner.cpp:                ptr--;
scanner.cpp:                lex -> ReportMessage(StreamError::INVALID_ESCAPE_SEQUENCE,
scanner.cpp:                                     ptr - lex -> InputBuffer() - 1,
scanner.cpp:                                     (ptr - lex -> InputBuffer() -
scanner.cpp:        ptr--;
scanner.cpp:        lex -> ReportMessage(StreamError::UNTERMINATED_STRING_CONSTANT,
scanner.cpp:                             current_token -> Location(),
scanner.cpp:                             ptr - lex -> InputBuffer());
scanner.cpp:    current_token ->
scanner.cpp:                                                           ptr - cursor));
scanner.cpp:// Note that the use of that check is a time-optimization that is not
scanner.cpp:    int len = ptr - cursor;
scanner.cpp:    current_token -> SetKind(len < 13 ? (scan_keyword[len])(cursor)
scanner.cpp:    if (current_token -> Kind() == TK_assert &&
scanner.cpp:        lex -> ReportMessage(StreamError::DEPRECATED_IDENTIFIER_ASSERT,
scanner.cpp:                             current_token -> Location(),
scanner.cpp:                             current_token -> Location() + len - 1);
scanner.cpp:        current_token -> SetKind(TK_Identifier);
scanner.cpp:    if (current_token -> Kind() == TK_enum &&
scanner.cpp:        lex -> ReportMessage(StreamError::DEPRECATED_IDENTIFIER_ENUM,
scanner.cpp:                             current_token -> Location(),
scanner.cpp:                             current_token -> Location() + len - 1);
scanner.cpp:        current_token -> SetKind(TK_Identifier);
scanner.cpp:        lex -> ReportMessage(StreamError::DOLLAR_IN_IDENTIFIER,
scanner.cpp:                             current_token -> Location(),
scanner.cpp:                             current_token -> Location() + len - 1);
scanner.cpp:    if (current_token -> Kind() == TK_Identifier)
scanner.cpp:        current_token -> SetSymbol(control.FindOrInsertName(cursor, len));
scanner.cpp:                current_token -> SetKind(control.option.keyword_map[i].key);
scanner.cpp:    else if (current_token -> Kind() == TK_class ||
scanner.cpp:             current_token -> Kind() == TK_enum ||
scanner.cpp:             current_token -> Kind() == TK_interface)
scanner.cpp:        // If this is a top-level type keyword (not in braces), we keep track
scanner.cpp:            lex -> type_index.Next() = current_token_index;
scanner.cpp:    else if (current_token -> Kind() == TK_package && ! lex -> package)
scanner.cpp:        lex -> package = current_token_index;
scanner.cpp:    int len = ptr - cursor;
scanner.cpp:        lex -> ReportMessage(StreamError::DOLLAR_IN_IDENTIFIER,
scanner.cpp:                             current_token -> Location(),
scanner.cpp:                             current_token -> Location() + len - 1);
scanner.cpp:    current_token -> SetKind(TK_Identifier);
scanner.cpp:    current_token -> SetSymbol(control.FindOrInsertName(cursor, len));
scanner.cpp:            current_token -> SetKind(control.option.keyword_map[i].key);
scanner.cpp:// This procedure is invoked when CURSOR points directly to '0' - '9' or '.'.
scanner.cpp:    const wchar_t* ptr = cursor - 1;
scanner.cpp:    //    '.', we have a floating-point constant. We scan the sequence of
scanner.cpp:    // 2) Otherwise, we have an integer literal. If the initial (non-empty)
scanner.cpp:    //    for nicer parsing, we simply complain about non-octal digits rather
scanner.cpp:        current_token -> SetKind(TK_DoubleLiteral);
scanner.cpp:        current_token -> SetKind(TK_IntegerLiteral);
scanner.cpp:                    current_token -> SetKind(TK_DoubleLiteral);
scanner.cpp:                        lex -> ReportMessage(StreamError::INVALID_FLOATING_HEX_EXPONENT,
scanner.cpp:                                             current_token -> Location(),
scanner.cpp:                                             ptr - 1 - lex -> InputBuffer());
scanner.cpp:                            tmp++; // Skip the '+' or '-'.
scanner.cpp:                            tmp--;
scanner.cpp:                        lex -> ReportMessage(StreamError::INVALID_FLOATING_HEX_MANTISSA,
scanner.cpp:                                             current_token -> Location(),
scanner.cpp:                                             tmp - lex -> InputBuffer());
scanner.cpp:                            tmp++; // Skip the '+' or '-'.
scanner.cpp:                            tmp--;
scanner.cpp:                        lex -> ReportMessage(StreamError::INVALID_FLOATING_HEX_MANTISSA,
scanner.cpp:                                             current_token -> Location(),
scanner.cpp:                                             tmp - lex -> InputBuffer());
scanner.cpp:                        tmp = (*ptr == U_l || *ptr == U_L) ? ptr : ptr - 1;
scanner.cpp:                        lex -> ReportMessage(StreamError::INVALID_HEX_CONSTANT,
scanner.cpp:                                             current_token -> Location(),
scanner.cpp:                                             tmp - lex -> InputBuffer());
scanner.cpp:                    tmp = (*ptr == U_l || *ptr == U_L) ? ptr : ptr - 1;
scanner.cpp:                    lex -> ReportMessage(StreamError::INVALID_OCTAL_CONSTANT,
scanner.cpp:                                         current_token -> Location(),
scanner.cpp:                                         tmp - lex -> InputBuffer());
scanner.cpp:    // floating-point constant. If that's the case, the literal is
scanner.cpp:    // hexadecimal constant being used as the prefix of a floating-point
scanner.cpp:    // are both tokenized as a single floating-point constant 19.0. Note that
scanner.cpp:        current_token -> SetKind(TK_DoubleLiteral);
scanner.cpp:                tmp++; // Skip the '+' or '-'.
scanner.cpp:                tmp--;
scanner.cpp:            lex -> ReportMessage(StreamError::INVALID_FLOATING_HEX_PREFIX,
scanner.cpp:                                 current_token -> Location(),
scanner.cpp:                                 tmp - lex -> InputBuffer());
scanner.cpp:            ptr++; // Skip the '+' or '-'.
scanner.cpp:                ? ptr : ptr - 1;
scanner.cpp:            lex -> ReportMessage(StreamError::INVALID_FLOATING_EXPONENT,
scanner.cpp:                                 current_token -> Location(),
scanner.cpp:                                 tmp - lex -> InputBuffer());
scanner.cpp:        len = ++ptr - cursor;
scanner.cpp:        current_token ->
scanner.cpp:        current_token -> SetKind(TK_FloatLiteral);
scanner.cpp:        len = ++ptr - cursor;
scanner.cpp:        current_token ->
scanner.cpp:        current_token -> SetKind(TK_DoubleLiteral);
scanner.cpp:    else if (current_token -> Kind() == TK_IntegerLiteral)
scanner.cpp:                lex -> ReportMessage(StreamError::FAVOR_CAPITAL_L_SUFFIX,
scanner.cpp:                                     current_token -> Location(),
scanner.cpp:                                     ptr - lex -> InputBuffer());
scanner.cpp:            len = ++ptr - cursor;
scanner.cpp:            current_token ->
scanner.cpp:            current_token -> SetKind(TK_LongLiteral);
scanner.cpp:            len = ptr - cursor;
scanner.cpp:            current_token ->
scanner.cpp:        assert(current_token -> Kind() == TK_DoubleLiteral);
scanner.cpp:        len = ptr - cursor;
scanner.cpp:        current_token ->
scanner.cpp:    current_token -> SetKind(TK_COLON);
scanner.cpp:        current_token -> SetKind(TK_PLUS_PLUS);
scanner.cpp:        current_token -> SetKind(TK_PLUS_EQUAL);
scanner.cpp:    else current_token -> SetKind(TK_PLUS);
scanner.cpp:        current_token -> SetKind(TK_MINUS_MINUS);
scanner.cpp:        current_token -> SetKind(TK_MINUS_EQUAL);
scanner.cpp:    else current_token -> SetKind(TK_MINUS);
scanner.cpp:        current_token -> SetKind(TK_MULTIPLY_EQUAL);
scanner.cpp:    else current_token -> SetKind(TK_MULTIPLY);
scanner.cpp:        current_token -> SetKind(TK_DIVIDE_EQUAL);
scanner.cpp:    else current_token -> SetKind(TK_DIVIDE);
scanner.cpp:        current_token -> SetKind(TK_LESS_EQUAL);
scanner.cpp:            current_token -> SetKind(TK_LEFT_SHIFT_EQUAL);
scanner.cpp:        else current_token -> SetKind(TK_LEFT_SHIFT);
scanner.cpp:    else current_token -> SetKind(TK_LESS);
scanner.cpp:    current_token -> SetKind(TK_GREATER);
scanner.cpp:        current_token -> SetKind(TK_GREATER_EQUAL);
scanner.cpp:            current_token -> SetKind(TK_RIGHT_SHIFT_EQUAL);
scanner.cpp:                current_token -> SetKind(TK_UNSIGNED_RIGHT_SHIFT_EQUAL);
scanner.cpp:            else current_token -> SetKind(TK_UNSIGNED_RIGHT_SHIFT);
scanner.cpp:        else current_token -> SetKind(TK_RIGHT_SHIFT);
scanner.cpp:        current_token -> SetKind(TK_AND_AND);
scanner.cpp:        current_token -> SetKind(TK_AND_EQUAL);
scanner.cpp:    else current_token -> SetKind(TK_AND);
scanner.cpp:        current_token -> SetKind(TK_OR_OR);
scanner.cpp:        current_token -> SetKind(TK_OR_EQUAL);
scanner.cpp:    else current_token -> SetKind(TK_OR);
scanner.cpp:        current_token -> SetKind(TK_XOR_EQUAL);
scanner.cpp:    else current_token -> SetKind(TK_XOR);
scanner.cpp:        current_token -> SetKind(TK_NOT_EQUAL);
scanner.cpp:    else current_token -> SetKind(TK_NOT);
scanner.cpp:        current_token -> SetKind(TK_EQUAL_EQUAL);
scanner.cpp:    else current_token -> SetKind(TK_EQUAL);
scanner.cpp:        current_token -> SetKind(TK_REMAINDER_EQUAL);
scanner.cpp:    else current_token -> SetKind(TK_REMAINDER);
scanner.cpp:        current_token -> SetKind(TK_ELLIPSIS);
scanner.cpp:        current_token -> SetKind(TK_DOT);
scanner.cpp:    current_token -> SetKind(TK_SEMICOLON);
scanner.cpp:    current_token -> SetKind(TK_COMMA);
scanner.cpp:    current_token -> SetKind(TK_LBRACE);
scanner.cpp:        lex -> token_stream[left_brace].SetRightBrace(current_token_index);
scanner.cpp:    current_token -> SetKind(TK_RBRACE);
scanner.cpp:    current_token -> SetKind(TK_LPAREN);
scanner.cpp:    current_token -> SetKind(TK_RPAREN);
scanner.cpp:    current_token -> SetKind(TK_LBRACKET);
scanner.cpp:    current_token -> SetKind(TK_RBRACKET);
scanner.cpp:    current_token -> SetKind(TK_TWIDDLE);
scanner.cpp:    current_token -> SetKind(TK_AT);
scanner.cpp:    current_token -> SetKind(TK_QUESTION);
scanner.cpp:    if (Code::IsAlpha(cursor)) // Some kind of non-ascii unicode letter
scanner.cpp:// any concluding ctrl-z, so we don't need to worry about seeing that as a
scanner.cpp:    current_token -> SetKind(0);
scanner.cpp:    lex -> ReportMessage(StreamError::BAD_TOKEN, current_token -> Location(),
scanner.cpp:                         cursor - lex -> InputBuffer() - 1);
scanner.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
scanner.h:                table.Reset(table.Length() - 1);
scanner.h:            return table.Length() > 0 ? table[table.Length() - 1] : 0;
Binary file scanner.o matches
segment.cpp:        array -= offset;
segment.cpp:               (base_size - old_base_size) * sizeof(PairSegment*));
segment.cpp:    return base[k] -> Image(target);
segment.cpp:        array -= offset;
segment.cpp:               (base_size - old_base_size) * sizeof(TripletSegment *));
segment.cpp:    return base[k] -> Image(target)[target2];
segment.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
segment.h:        MASK = ~ (BLKSIZE - 1)
segment.h:// A map of int -> u2 pairs.
segment.h:        MASK = ~ (BLKSIZE - 1)
segment.h:// A map of (int, int) -> u2 triplets.
Binary file segment.o matches
semantic.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
semantic.h:    void Pop() { if (table.Length() > 0) table.Reset(table.Length() - 1); }
semantic.h:                                ? table[table.Length() - 1] : NULL);
semantic.h:        for (int i = table.Length() - 1; i >= 0; i--)
semantic.h:                table[i] -> FindVariableSymbol(name_symbol);
semantic.h:        for (int i = table.Length() - 1; i >= 0; i--)
semantic.h:            TypeSymbol* symbol = table[i] -> FindTypeSymbol(name_symbol);
semantic.h:        for (int i = table.Length() - 1; i >= 0; i--)
semantic.h:            LabelSymbol* label = table[i] -> FindLabelSymbol(name_symbol);
semantic.h:            info.Reset(info.Length() - 1);
semantic.h:        return info.Length() ? info[info.Length() - 1] : T();
semantic.h:            block.Reset(len - 1);
semantic.h:            index.Reset(len - 1);
semantic.h:                            ? block[block.Length() - 1] : NULL);
semantic.h:        return index[index.Length() - 1];
semantic.h:            info.Reset(info.Length() - 1);
semantic.h:        return info[info.Length() - 1];
semantic.h:            top_index--;
semantic.h:        return block[top_index - 1];
semantic.h:        return break_pairs[top_index - 1];
semantic.h:        return continue_pairs[top_index - 1];
semantic.h:        clone -> this_method = this_method;
semantic.h:        clone -> this_variable = this_variable;
semantic.h:        clone -> explicit_constructor = explicit_constructor;
semantic.h:        clone -> args = args;
semantic.h:            clone -> symbol_table.Push(symbol_table[i]);
semantic.h:        clone -> next = next;
semantic.h:        return ((this_variable && this_variable -> ACC_STATIC()) ||
semantic.h:                (this_method && this_method -> ACC_STATIC()) ||
semantic.h:        info.Reset(info.Length() - 1);
semantic.h:        return info[info.Length() - 1];
semantic.h:          lex_stream(file_symbol_ -> lex_stream),
semantic.h:          compilation_unit(file_symbol_ -> compilation_unit),
semantic.h:          directory_symbol(file_symbol_ -> directory_symbol),
semantic.h:          this_package(file_symbol_ -> package)
semantic.h:        // DefiniteStatement. Therefore, they are diverted to the no-op
semantic.h:    // Report a multi-token semantic warning or error.
semantic.h:        error -> Report(kind, ltok, rtok, s1, s2, s3, s4, s5, s6, s7, s8, s9);
semantic.h:        error -> Report(kind, ast -> LeftToken(), ast -> RightToken(),
semantic.h:    // Report a single-token semantic warning or error.
semantic.h:        error -> Report(kind, tok, tok, s1, s2, s3, s4, s5, s6, s7, s8, s9);
semantic.h:    unsigned NumErrors() { return (error ? error -> num_errors : 0); }
semantic.h:    // Implemented in decl.cpp - performs first pass over .java file.
semantic.h:    // Implemented in init.cpp - determines values of final fields.
semantic.h:    // Implemented in class.cpp - reads in a .class file.
semantic.h:    // Implemented in expr.cpp - semantic checks of expressions
semantic.h:    // Implemented in decl.cpp - clean up after parsing
semantic.h:    // Implemented in decl.cpp - process a .java file for declarations
semantic.h:    // Implemented in body.cpp - process method bodies and field initializers
semantic.h:    // Used in the handling of imports - see decl.cpp
semantic.h:        return ThisType() -> IsDeprecated() ||
semantic.h:            (ThisMethod() && ThisMethod() -> IsDeprecated()) ||
semantic.h:            (ThisVariable() && ThisVariable() -> IsDeprecated());
semantic.h:    TypeSymbol* ThisType() { return state_stack.Top() -> Type(); }
semantic.h:    MethodSymbol*& ThisMethod() { return state_stack.Top() -> this_method; }
semantic.h:        return state_stack.Top() -> this_variable;
semantic.h:        return state_stack.Top() -> explicit_constructor;
semantic.h:        return state_stack.Top() -> symbol_table;
semantic.h:        return state_stack.Top() -> try_exception_table_stack;
semantic.h:        return state_stack.Top() -> try_statement_stack;
semantic.h:        return state_stack.Top() -> breakable_statement_stack;
semantic.h:        return state_stack.Top() -> continuable_statement_stack;
semantic.h:        return state_stack.Top() -> abrupt_finally_stack;
semantic.h:        return state_stack.Top() -> block_stack;
semantic.h:        return state_stack.Top() -> GetEnvironment(ast);
semantic.h:        return state_stack.Top() -> StaticRegion();
semantic.h:        return state_stack.Top() -> definitely_assigned_variables;
semantic.h:    DefinitePair*& Universe() { return state_stack.Top() -> universe; }
semantic.h:    BitSet*& BlankFinals() { return state_stack.Top() -> blank_finals; }
semantic.h:        return state_stack.Top() -> reachable_assignments;
semantic.h:        return state_stack.Top() -> definite_block_stack;
semantic.h:        return state_stack.Top() -> definite_final_assignment_stack;
semantic.h:        return state_stack.Top() -> final_fields;
semantic.h:        return state_stack.Top() -> processing_simple_assignment;
semantic.h:    // Implemented in expr.cpp - semantic checks of expressions
semantic.h:    // Implemented in decl.cpp - nested class processing
semantic.h:        ReportTypeInaccessible(ast -> LeftToken(), ast -> RightToken(), type);
semantic.h:    // Implemented in modifier.cpp - process declaration modifiers
semantic.h:    // Implemented in decl.cpp - process declarations
semantic.h:    // Implemented in decl.cpp - process initializers
semantic.h:    // Implemented in expr.cpp - expression processing
semantic.h:    // Implemented in definite.cpp - definite (un)assignment analysis
semantic.h:    // Implemented in body.cpp - method bodies and statements
semantic.h:    // Implemented in expr.cpp - expression processing
semantic.h:        (this ->* ProcessExprOrStmt[stmt -> kind])(stmt);
semantic.h:        if (expr -> symbol)
semantic.h:            // already processed, make sure it was compiler-generated
semantic.h:            assert(expr -> generated);
semantic.h:        else (this ->* ProcessExprOrStmt[expr -> kind])(expr);
semantic.h:    // Implemented in body.cpp - statement processing
semantic.h:        assert(ast -> IsExplicitConstructorInvocation());
semantic.h:        statement -> can_complete_normally = statement -> is_reachable;
semantic.h:                       statement -> LeftToken(),
semantic.h:                       statement -> RightToken());
semantic.h:    // Implemented in expr.cpp - expression processing
semantic.h:    // Implemented in decl.cpp - inheritance of declared members
semantic.h:    // Implemented in class.cpp - reads in a .class file.
semantic.h:    // Implemented in depend.cpp - class dependence tracking.
set.cpp:        unsigned i = shadow -> Identity() -> index % hash_size;
set.cpp:        shadow -> next = base[i];
set.cpp:            Symbol* symbol = shadow -> symbol;
set.cpp:                 symbol = (Symbol*) (k < shadow -> NumConflicts()
set.cpp:                                     ? shadow -> Conflict(k++) : NULL))
set.cpp:            Symbol* symbol = shadow -> symbol;
set.cpp:                 symbol = (Symbol*) (k < shadow -> NumConflicts()
set.cpp:                                     ? shadow -> Conflict(k++) : NULL))
set.cpp:            Symbol* symbol = shadow -> symbol;
set.cpp:                 symbol = (Symbol*) (k < shadow -> NumConflicts()
set.cpp:                                     ? shadow -> Conflict(k++) : NULL))
set.cpp:        Symbol* symbol = shadow -> symbol;
set.cpp:             symbol = (Symbol*) (k < shadow -> NumConflicts()
set.cpp:                                 ? shadow -> Conflict(k++) : NULL))
set.cpp:    const NameSymbol* name_symbol = element -> Identity();
set.cpp:    unsigned i = name_symbol -> index % hash_size;
set.cpp:    for (shadow = base[i]; shadow; previous = shadow, shadow = shadow -> next)
set.cpp:        if (shadow -> Identity() == name_symbol)
set.cpp:            Symbol* symbol = shadow -> symbol;
set.cpp:                 symbol = (Symbol*) (k < shadow -> NumConflicts()
set.cpp:                                     ? shadow -> Conflict(k++) : NULL))
set.cpp:                if (shadow -> NumConflicts() == 0)
set.cpp:                shadow -> RemoveConflict(k - 1);
set.cpp:             base[i] = shadow -> next;
set.cpp:        else previous -> next = shadow -> next;
set.cpp:        unsigned last_index = symbol_pool.Length() - 1;
set.cpp:        if (shadow -> pool_index != last_index)
set.cpp:            symbol_pool[last_index] -> pool_index = shadow -> pool_index;
set.cpp:            symbol_pool[shadow -> pool_index] = symbol_pool[last_index];
set.cpp:            element -> domain_element -> Identity() -> index % hash_size;
set.cpp:        element -> next = base[k];
set.cpp:    unsigned k = symbol -> Identity() -> index % hash_size;
set.cpp:    for (element = base[k]; element; element = element -> next)
set.cpp:        if (element -> domain_element == symbol)
set.cpp:        element -> domain_element = symbol;
set.cpp:        element -> next = base[k];
set.cpp:    element -> image = image;
set.cpp:    prime_index = -1;
set.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
set.h:    inline const NameSymbol* Identity() { return symbol -> Identity(); }
set.h:        return conflict ? conflict -> Length() : 0;
set.h:            conflict -> Next() = conflict_symbol;
set.h:        unsigned last_index = conflict -> Length() - 1;
set.h:        conflict -> Reset(last_index);
set.h:        for (unsigned k = 0; k < conflict -> Length(); k++)
set.h:        prime_index = -1;
set.h:            Symbol* symbol = shadow -> symbol;
set.h:                 symbol = (Symbol*) (k < shadow -> NumConflicts()
set.h:                                     ? shadow -> Conflict(k++) : NULL))
set.h:    // Empty out the set in question - i.e., remove all its elements
set.h:            this -> SetEmpty();
set.h:            this -> Union(rhs);
set.h:        const NameSymbol* name_symbol = element -> Identity();
set.h:        for (ShadowSymbol* shadow = base[name_symbol -> index % hash_size];
set.h:             shadow; shadow = shadow -> next)
set.h:            if (shadow -> Identity() == name_symbol)
set.h:                return shadow -> NumConflicts() + 1;
set.h:        const NameSymbol* name_symbol = element -> Identity();
set.h:        for (ShadowSymbol* shadow = base[name_symbol -> index % hash_size];
set.h:             shadow; shadow = shadow -> next)
set.h:            if (shadow -> Identity() == name_symbol)
set.h:                Symbol* symbol = shadow -> symbol;
set.h:                     symbol = (Symbol*) (k < shadow -> NumConflicts()
set.h:                                         ? shadow -> Conflict(k++) : NULL))
set.h:        const NameSymbol* name_symbol = element -> Identity();
set.h:        unsigned i = name_symbol -> index % hash_size;
set.h:        for (shadow = base[i]; shadow; shadow = shadow -> next)
set.h:            if (shadow -> Identity() == name_symbol)
set.h:                shadow -> AddConflict(element);
set.h:        shadow -> pool_index = symbol_pool.Length();
set.h:        shadow -> next = base[i];
set.h:            ? symbol_pool[main_index] -> symbol : (Symbol*) NULL;
set.h:             if (sub_index < symbol_pool[main_index] -> NumConflicts())
set.h:                 symbol = symbol_pool[main_index] -> Conflict(sub_index++);
set.h:                           ? symbol_pool[main_index] -> symbol
set.h:// Single-value Mapping from a name_symbol into a symbol with that name.
set.h:        for (ShadowSymbol* shadow = base[name_symbol -> index % hash_size];
set.h:             shadow; shadow = shadow -> next)
set.h:            if (shadow -> Identity() == name_symbol)
set.h:                return shadow -> symbol;
set.h:        for (shadow = base[element -> Identity() -> index % hash_size];
set.h:             shadow; shadow = shadow -> next)
set.h:            if (shadow -> Identity() == element -> Identity())
set.h:            shadow -> symbol = element;
set.h:// Single-value Mapping from an arbitrary key to an arbitrary value, based
set.h:        unsigned k = key -> HashCode() % hash_size;
set.h:        for (Element* element = base[k]; element; element = element -> next)
set.h:            if (element -> key == key)
set.h:                return element -> value;
set.h:// Single-value Mapping from an arbitrary symbol into another arbitrary symbol.
set.h:        unsigned k = symbol -> Identity() -> index % hash_size;
set.h:        for (Element* element = base[k]; element; element = element -> next)
set.h:            if (element -> domain_element == symbol)
set.h:                return element -> image;
set.h:        memset(s, 0, (set_size + cell_size - 1) / cell_size * sizeof(CELL));
set.h:               (set_size + cell_size - 1) / cell_size * sizeof(CELL));
set.h:    // It hashes a bitset into a location within the range <1..table_size-1>.
set.h:        for (int i = ((int) set_size - 1) / cell_size; i >= 0; i--)
set.h:                   (set_size + cell_size - 1) / cell_size * sizeof(CELL));
set.h:        int num_cells = (set_size + cell_size - 1) / cell_size;
set.h:        int num_cells = (set_size + cell_size - 1) / cell_size;
set.h:        int num_cells = (set_size + cell_size - 1) / cell_size;
set.h:        int i = ((int) set_size - 1) / cell_size;
set.h:             (i % cell_size ? ((CELL) 1 << (i % cell_size)) - (CELL) 1
set.h:        while (--i >= 0)
set.h:        for (int i = ((int) set_size - 1) / cell_size; i >= 0; i--)
set.h:        for (int i = ((int) set_size - 1) / cell_size; i >= 0; i--)
set.h:    BitSet operator-(const BitSet& rhs) const
set.h:        return BitSet(*this) -= rhs;
set.h:    BitSet& operator-=(const BitSet& rhs)
set.h:        for (int i = ((int) set_size - 1) / cell_size; i >= 0; i--)
set.h:            int new_cell_count = (new_size + cell_size - 1) / cell_size;
set.h:            int old_cell_count = (max_set_size + cell_size - 1) / cell_size;
set.h:            int i = (new_size - 1) / cell_size;
set.h:            while (i > ((int) set_size + cell_size - 1) / cell_size - 1)
set.h:                s[i--] = init == EMPTY ? (CELL) 0 : ~((CELL) 0);
set.h:                             ? ((CELL) 1 << (set_size % cell_size)) - (CELL) 1
set.h:                                 - (CELL) 1)
set.h:    inline DefinitePair operator-(const DefinitePair& rhs) const
set.h:        return DefinitePair(*this) -= rhs;
set.h:    inline DefinitePair& operator-=(const DefinitePair& rhs)
set.h:        da_set -= rhs.da_set;
set.h:        du_set -= rhs.du_set;
set.h:        unsigned k = element -> key -> HashCode() % hash_size;
set.h:        element -> next = base[k];
set.h:    unsigned k = key -> HashCode() % hash_size;
set.h:    for (element = base[k]; element; element = element -> next)
set.h:        if (element -> key == key)
set.h:        element -> key = key;
set.h:        element -> next = base[k];
set.h:    element -> value = value;
set.h:    static int prime_index = -1;
Binary file set.o matches
spell.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
spell.h:            //  ;      <---->     ,
spell.h:            //  ;      <---->     :
spell.h:            //  .      <---->     ,
spell.h:            //  '      <---->     "
spell.h:                if ((len1 - i1) > (len2 - i2))
spell.h:                else if ((len2 - i2) > (len1 - i1))
stream.cpp:    return lex_stream -> FileName();
stream.cpp:            L"as it is now a keyword. Use -source 1.4 if you intended "
stream.cpp:            L"as it will be a keyword once -source 1.5 is implemented.";
stream.cpp:            L"discouraged, since it can conflict with compiler-generated "
stream.cpp:        left_line_no = lex_stream -> FindLine(start_location);
stream.cpp:        left_column_no = lex_stream -> FindColumn(start_location - 1) + 1;
stream.cpp:        right_line_no = lex_stream -> FindLine(end_location);
stream.cpp:        right_column_no = lex_stream -> FindColumn(end_location);
stream.cpp:    lex_stream -> OutputSource(this, s);
stream.cpp:    , _decoder((iconv_t) - 1)
stream.cpp:    bool supported = tmp -> SetEncoding(encoding);
stream.cpp:        _decoder = (iconv_t)-1;
stream.cpp:            int(before - data_buffer)
stream.cpp:    if (n == (size_t) -1)
stream.cpp:                    (int) (before - data_buffer));
stream.cpp:        control.line_count += (line_location.Length() - 3);
stream.cpp:    unsigned location = tokens[i].Location() - 1 +
stream.cpp:         ? tokens[i].additional_info.symbol -> NameLength()
stream.cpp:        ? tokens[i].additional_info.symbol -> Name()
stream.cpp:        ? tokens[i].additional_info.symbol -> NameLength()
stream.cpp:                       locations[line_no + 1] - 2); // ignore the \n
stream.cpp:        ? symbol -> LiteralCast() : (class LiteralSymbol*) NULL;
stream.cpp:        ? symbol -> NameCast() : (class NameSymbol*) NULL;
stream.cpp:char* LexStream::FileName() { return file_symbol -> FileName(); }
stream.cpp:    return file_symbol -> FileNameLength();
stream.cpp:            s.width(Tab::TabSize() - offset % Tab::TabSize());
stream.cpp:            offset = Tab::TabSize() - 1;
stream.cpp:    int left_line_no = err -> getLeftLineNo();
stream.cpp:    int left_column_no = err -> getLeftColumnNo();
stream.cpp:    int right_line_no = err -> getRightLineNo();
stream.cpp:    int right_column_no = err -> getRightColumnNo();
stream.cpp:            s.width(right_column_no - left_column_no);
stream.cpp:            s.fill('-');
stream.cpp:    else // multi-line
stream.cpp:        s.width(LineLength(left_line_no) - left_column_no);
stream.cpp:        s.fill('-');
stream.cpp:        s.fill('-');
stream.cpp:    int hi = comment_stream.Length() - 1;
stream.cpp:            else hi = mid - 1;
stream.cpp:    int hi = line_location.Length() - 1;
stream.cpp:        else hi = mid - 1;
stream.cpp:    return locations[lo] > location ? lo - 1 : lo;
stream.cpp:    if (file_symbol -> IsZip())
stream.cpp:        if (zipfile -> Buffer() == NULL)
stream.cpp:        else if (! file_symbol -> lex_stream)
stream.cpp:            file_symbol -> lex_stream = this;
stream.cpp:            ProcessInput(zipfile -> Buffer(),
stream.cpp:                         file_symbol -> uncompressed_size);
stream.cpp:        JikesAPI::getInstance() -> stat(FileName(), &status);
stream.cpp:        file_symbol -> mtime = status.st_mtime; // actual time stamp of file read
stream.cpp:        file_symbol -> lex_stream = this;
stream.cpp:            JikesAPI::getInstance() -> read(FileName());
stream.cpp:            ProcessInput(file -> getBuffer(), file -> getBufferSize());
stream.cpp:    else if (file_symbol -> IsZip())
stream.cpp:        if (zipfile -> Buffer() == NULL)
stream.cpp:        else ProcessInput(zipfile -> Buffer(),
stream.cpp:                          file_symbol -> uncompressed_size);
stream.cpp:        JikesAPI::getInstance() -> stat(FileName(), &status);
stream.cpp:        if (status.st_mtime == file_symbol -> mtime)
stream.cpp:               JikesAPI::getInstance() -> read(FileName());
stream.cpp:               ProcessInput(file -> getBuffer(), file -> getBufferSize());
stream.cpp:        return ch - U_0;
stream.cpp:                            *input_ptr = (*input_ptr << 4) + (ch - (U_a - 10));
stream.cpp:                            *input_ptr = (*input_ptr << 4) + (ch - (U_A - 10));
stream.cpp:                            *input_ptr = (*input_ptr << 4) + (ch - U_0);
stream.cpp:                                          (unsigned) (input_ptr - input_buffer),
stream.cpp:                                          (unsigned) (input_ptr - input_buffer) + (source_ptr - u_ptr));
stream.cpp:        input_ptr--;
stream.cpp:                      (unsigned) (input_ptr - input_buffer),
stream.cpp:                      (unsigned) (input_ptr - input_buffer));
stream.cpp:    input_buffer_length = input_ptr - input_buffer;
stream.cpp:                size_t cursize = input_ptr - input_buffer;
stream.cpp:                input_tail = input_buffer + newsize - 1;
stream.cpp:                                      (unsigned) (escape_ptr - input_buffer),
stream.cpp:                                      ((unsigned) (input_ptr - input_buffer) -
stream.cpp:                                      (unsigned) (escape_ptr - input_buffer),
stream.cpp:                                      ((unsigned) (input_ptr - input_buffer) -
stream.cpp:                                      (unsigned) (escape_ptr - input_buffer),
stream.cpp:                                      ((unsigned) (input_ptr - input_buffer) -
stream.cpp:                    input_ptr = escape_ptr - 1; // Back up - see case QUOTE.
stream.cpp:                                      (unsigned) (escape_ptr - input_buffer),
stream.cpp:                                      ((unsigned) (input_ptr - input_buffer) -
stream.cpp:                    // so that CR-CR-LF will be handled correctly.
stream.cpp:                              (unsigned) (escape_ptr - input_buffer),
stream.cpp:                              (unsigned) (input_ptr - input_buffer));
stream.cpp:        input_ptr--;
stream.cpp:                      (unsigned) (input_ptr - input_buffer),
stream.cpp:                      (unsigned) (input_ptr - input_buffer));
stream.cpp:    input_buffer_length = input_ptr - input_buffer;
stream.cpp:     histack[top] = bad_tokens.Length() - 1;
stream.cpp:         top--;
stream.cpp:             // The array is most-likely almost sorted. Therefore,
stream.cpp:             if ((i - lower) < (upper - i))
stream.cpp:                 upper = i - 1;
stream.cpp:                 histack[top] = i - 1;
stream.cpp:                control.system_semantic ->
stream.cpp:                    JikesAPI::getInstance() -> reportError(&bad_tokens[i]);
stream.cpp:                JikesAPI::getInstance() -> reportError(&bad_tokens[i]);
stream.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
stream.h:        return _decoder != (iconv_t) -1;
stream.h:        source_tail = data_buffer + size - 1;
stream.h:        return ++i < token_stream.Length() ? i : token_stream.Length() - 1;
stream.h:    inline TokenIndex Previous(TokenIndex i) { return i <= 0 ? 0 : i - 1; }
stream.h:                        : token_stream.Length() - 1);
stream.h:        return tokens[i >= NumTokens() ? NumTokens() - 1 : i].Kind();
stream.h:        return input_buffer ? FindColumn(tokens[i].Location() - 1) + 1 : 0;
stream.h:        return i < 1 ? true : Line(i - 1) < Line(i);
stream.h:        return locations[line_no + 1] - 1;
stream.h:        while (Line(--start) == the_line);
stream.h:        return bad_tokens.Length() - NumBadTokens();
Binary file stream.o matches
symbol.cpp:        int length = (Type() -> ContainingPackage() -> PackageNameLength() +
symbol.cpp:                      Type() -> ExternalNameLength() +
symbol.cpp:                      (is_constructor ? containing_type -> NameLength()
symbol.cpp:            length += (formal -> Type() -> ContainingPackage() -> PackageNameLength() +
symbol.cpp:                       formal -> Type() -> ExternalNameLength() +
symbol.cpp:                       formal -> NameLength() + 4);
symbol.cpp:                length += (exception -> ContainingPackage() ->
symbol.cpp:                           exception -> ExternalNameLength() + 3);
symbol.cpp:            for (s2 = containing_type -> Name(); *s2; s2++)
symbol.cpp:            PackageSymbol* package = Type() -> ContainingPackage();
symbol.cpp:            wchar_t* package_name = package -> PackageName();
symbol.cpp:            if (package -> PackageNameLength() > 0 &&
symbol.cpp:            for (s2 = Type() -> ExternalName(); *s2; s2++)
symbol.cpp:                    formal -> Type() -> ContainingPackage();
symbol.cpp:                wchar_t* package_name = package -> PackageName();
symbol.cpp:                if (package -> PackageNameLength() > 0 &&
symbol.cpp:                for (s2 = formal -> Type() -> ExternalName(); *s2; s2++)
symbol.cpp:                if (k == num_parameters - 1 && ACC_VARARGS())
symbol.cpp:                    assert(s[-2] == U_LB && s[-1] == U_RB);
symbol.cpp:                    s[-2] = U_DOT;
symbol.cpp:                    s[-1] = U_DOT;
symbol.cpp:                for (s2 = formal -> Name(); *s2; s2++)
symbol.cpp:            s -= 2; // remove the last ',' and ' '
symbol.cpp:            s--; // remove the last ','
symbol.cpp:                PackageSymbol* package = exception -> ContainingPackage();
symbol.cpp:                wchar_t* package_name = package -> PackageName();
symbol.cpp:                if (package -> PackageNameLength() > 0 &&
symbol.cpp:                for (s2 = exception -> ExternalName(); *s2; s2++)
symbol.cpp:            s--; // remove the last ','
symbol.cpp:        assert((s - header) <= length);
symbol.cpp:        file_location = new FileLocation(containing_type -> file_symbol);
symbol.cpp:            declaration -> MethodDeclarationCast();
symbol.cpp:            declaration -> ConstructorDeclarationCast();
symbol.cpp:            new FileLocation((containing_type -> semantic_environment ->
symbol.cpp:                              sem -> lex_stream),
symbol.cpp:                              ? method_declaration -> LeftToken()
symbol.cpp:                              : constructor_declaration -> LeftToken()));
symbol.cpp:         method = method -> next_method)
symbol.cpp:        assert(method -> IsTyped());
symbol.cpp:        if (method -> NumFormalParameters() ==
symbol.cpp:            method_declarator -> NumFormalParameters())
symbol.cpp:            for (i = method -> NumFormalParameters() - 1; i >= 0; i--)
symbol.cpp:                    method_declarator -> FormalParameter(i);
symbol.cpp:                if (method -> FormalParameter(i) -> Type() !=
symbol.cpp:                    parameter -> formal_declarator -> symbol -> Type())
symbol.cpp:    semantic_environment -> sem -> ProcessTypeHeaders(declaration);
symbol.cpp:    semantic_environment -> sem -> ProcessMembers(declaration);
symbol.cpp:    semantic_environment -> sem -> CompleteSymbolTable(declaration);
symbol.cpp:    semantic_environment -> sem -> ProcessExecutableBodies(declaration);
symbol.cpp:            for (i = 0; i < table -> NumVariableSymbols(); i++)
symbol.cpp:                table -> VariableSym(i) -> declarator = NULL;
symbol.cpp:            for (i = 0; i < table -> NumMethodSymbols(); i++)
symbol.cpp:                table -> MethodSym(i) -> declaration = NULL;
symbol.cpp:            for (i = 0; i < table -> NumTypeSymbols(); i++)
symbol.cpp:                table -> TypeSym(i) -> declaration = NULL;
symbol.cpp:            for (i = 0; i < table -> NumAnonymousSymbols(); i++)
symbol.cpp:                table -> AnonymousSym(i) -> declaration = NULL;
symbol.cpp:        return base_type -> GetArrayType(sem, dims);
symbol.cpp:    TypeSymbol* previous_array_type = Array(array -> Length() - 1);
symbol.cpp:    wcscpy(name, previous_array_type -> ExternalName());
symbol.cpp:    for (unsigned num = array -> Length(),
symbol.cpp:             len = previous_array_type -> ExternalNameLength() + 2;
symbol.cpp:        NameSymbol* name_sym = sem -> control.FindOrInsertName(name, len);
symbol.cpp:        type -> MarkHeaderProcessed();
symbol.cpp:        type -> MarkConstructorMembersProcessed();
symbol.cpp:        type -> MarkMethodMembersProcessed();
symbol.cpp:        type -> MarkFieldMembersProcessed();
symbol.cpp:        type -> MarkLocalClassProcessingCompleted();
symbol.cpp:        type -> MarkSourceNoLongerPending();
symbol.cpp:        type -> outermost_type = type;
symbol.cpp:          type -> SetACC_PUBLIC();
symbol.cpp:          type -> SetACC_PROTECTED();
symbol.cpp:          type -> SetACC_PRIVATE();
symbol.cpp:        type -> SetACC_FINAL();
symbol.cpp:        type -> super = sem -> control.Object();
symbol.cpp:        type -> AddInterface(sem -> control.Serializable());
symbol.cpp:        type -> AddInterface(sem -> control.Cloneable());
symbol.cpp:        type -> base_type = this;
symbol.cpp:        type -> num_dimensions = num;
symbol.cpp:        type -> SetOwner(ContainingPackage());
symbol.cpp:        type -> table = new SymbolTable(2);
symbol.cpp:        type -> SetSignature(sem -> control);
symbol.cpp:            type -> InsertMethodSymbol(sem -> control.clone_name_symbol);
symbol.cpp:        method -> SetType(sem -> control.Object());
symbol.cpp:        method -> SetContainingType(type);
symbol.cpp:        method -> SetFlags(ACCESS_PUBLIC | ACCESS_FINAL);
symbol.cpp:        method -> SetBlockSymbol(new BlockSymbol(1));
symbol.cpp:        method -> SetSignature(sem -> control);
symbol.cpp:            type -> InsertVariableSymbol(sem -> control.length_name_symbol);
symbol.cpp:        symbol -> SetFlags(ACCESS_PUBLIC | ACCESS_FINAL);
symbol.cpp:        symbol -> SetOwner(type);
symbol.cpp:        symbol -> SetType(sem -> control.int_type);
symbol.cpp:        symbol -> MarkComplete();
symbol.cpp:        symbol -> MarkInitialized();
symbol.cpp:        type -> CompressSpace(); // space optimization
symbol.cpp:            new FileLocation(semantic_environment -> sem -> lex_stream,
symbol.cpp:                             declaration -> identifier_token);
symbol.cpp:        int signature_len = strlen(subtype -> SignatureString()) + 1;
symbol.cpp:        strcpy(type_signature + 1, subtype -> SignatureString());
symbol.cpp:        int len = ContainingPackage() -> PackageNameLength() +
symbol.cpp:        if (ContainingPackage() -> PackageNameLength() > 0 &&
symbol.cpp:        int i = symbol -> name_symbol -> index % hash_size;
symbol.cpp:        symbol -> next = base[i];
symbol.cpp:        if (symbol -> next != symbol) // not an overload
symbol.cpp:            int i = symbol -> name_symbol -> index % hash_size;
symbol.cpp:            symbol -> next = base[i];
symbol.cpp:        int i = symbol -> name_symbol -> index % hash_size;
symbol.cpp:        symbol -> next = base[i];
symbol.cpp:        if (! symbol -> BlockCast())
symbol.cpp:            int i = symbol -> Identity() -> index % hash_size;
symbol.cpp:            symbol -> next = base[i];
symbol.cpp:    prime_index = -1;
symbol.cpp:    package_name_length = (owner ? owner -> PackageNameLength() + 1 : 0) +
symbol.cpp:        wcscpy(package_name, owner -> PackageName());
symbol.cpp:    return local ? local -> Size() : 0;
symbol.cpp:        super -> subtypes -> RemoveElement(this);
symbol.cpp:        super -> dependents -> RemoveElement(this);
symbol.cpp:            interf -> subtypes -> RemoveElement(this);
symbol.cpp:            interf -> dependents -> RemoveElement(this);
symbol.cpp:    : max_variable_index(-1)
symbol.cpp:    , helper_variable_index(-1)
symbol.cpp:    PathSymbol* path_symbol = owner -> PathCast();
symbol.cpp:        if (strcmp(path_symbol -> Utf8Name(), ".") == 0)
symbol.cpp:            directory_name_length = path_symbol -> Utf8NameLength();
symbol.cpp:            strcpy(directory_name, path_symbol -> Utf8Name());
symbol.cpp:        DirectorySymbol* owner_directory = owner -> DirectoryCast();
symbol.cpp:        if (Name()[NameLength() - 1] == U_SLASH ||
symbol.cpp:            strcmp(owner_directory -> DirectoryName(), ".") == 0)
symbol.cpp:            int owner_length = owner_directory -> DirectoryNameLength();
symbol.cpp:            char* owner_name = owner_directory -> DirectoryName();
symbol.cpp:                (owner_name[owner_length - 1] != U_SLASH ? 1 : 0); // +1: '/'
symbol.cpp:            strcpy(directory_name, owner_directory -> DirectoryName());
symbol.cpp:            if (owner_name[owner_length - 1] != U_SLASH)
symbol.cpp:                unsigned length = strlen(entry -> d_name);
symbol.cpp:                     FileSymbol::IsJavaSuffix(&entry -> d_name[length - FileSymbol::java_suffix_length])) ||
symbol.cpp:                     FileSymbol::IsClassSuffix(&entry -> d_name[length - FileSymbol::class_suffix_length])) ||
symbol.cpp:                    (Case::Index(entry -> d_name, U_DOT) < 0 &&
symbol.cpp:                     SystemIsDirectory(entry -> d_name)))
symbol.cpp:                    int len = DirectoryNameLength() + strlen(entry -> d_name);
symbol.cpp:                            entry -> d_name);
symbol.cpp:                    if(JikesAPI::getInstance() -> stat(filename, &status) == 0)
symbol.cpp:                        entries -> InsertEntry(this, entry -> d_name, length);
symbol.cpp:        if (directory_name[dir_name_len - 1] != U_SLASH)
symbol.cpp:                                FileSymbol::IsJavaSuffix(&entry.cFileName[length - FileSymbol::java_suffix_length])),
symbol.cpp:                                 FileSymbol::IsClassSuffix(&entry.cFileName[length - FileSymbol::class_suffix_length]));
symbol.cpp:                        strcpy(&clean_name[length - FileSymbol::java_suffix_length],
symbol.cpp:                        strcpy(&clean_name[length - FileSymbol::class_suffix_length],
symbol.cpp:                        entries -> InsertEntry(this, clean_name, length);
symbol.cpp:                        entries -> InsertCaseInsensitiveEntry(entry);
symbol.cpp:    char* directory_name = directory_symbol -> DirectoryName();
symbol.cpp:    size_t directory_name_length = directory_symbol -> DirectoryNameLength();
symbol.cpp:        (path_symbol -> IsZip() ? 2 // For zip files, we need "()";
symbol.cpp:            directory_name[directory_name_length - 1] == U_SLASH ? 0 : 1)) +
symbol.cpp:        strcpy(file_name, directory_symbol -> DirectoryName());
symbol.cpp:        if (path_symbol -> IsZip())
symbol.cpp:        else if (directory_name[directory_name_length - 1] != U_SLASH)
symbol.cpp:    if (path_symbol -> IsZip())
symbol.cpp:        for (i = FileNameLength() - 1; i >= 0; i--)
symbol.cpp:        int file_name_length = FileNameLength() - file_name_start;
symbol.cpp:            control -> Utf8_pool.FindOrInsert(file_name + file_name_start,
symbol.cpp:        delete compilation_unit -> ast_pool;
symbol.cpp:    char* file_name = lex_stream -> FileName();
symbol.cpp:    unsigned length = lex_stream -> FileNameLength();
symbol.cpp:    IntToWstring line_no(lex_stream -> Line(token_index));
symbol.cpp:    if (semantic_environment -> sem -> control.option.directory)
symbol.cpp:        DirectorySymbol* output_directory = file_symbol -> OutputDirectory();
symbol.cpp:        int directory_length = output_directory -> DirectoryNameLength();
symbol.cpp:        char* directory_name = output_directory -> DirectoryName();
symbol.cpp:        if (directory_name[directory_length - 1] != U_SLASH)
symbol.cpp:            semantic_environment -> sem -> lex_stream -> FileName();
symbol.cpp:        for (n = semantic_environment -> sem -> lex_stream ->
symbol.cpp:                 FileNameLength() - 1;
symbol.cpp:             n >= 0; n--)
symbol.cpp:        NameSymbol* name_symbol = sem ->
symbol.cpp:        sem -> ProcessNestedType(this, name_symbol, tok);
symbol.cpp:                sem -> ReadTypeFromSignature(containing_type,
symbol.cpp:    int len = is_constructor ? 3 : 2 + strlen(Type() -> SignatureString());
symbol.cpp:    TypeSymbol* this0_type = containing_type -> EnclosingType();
symbol.cpp:        len += strlen(this0_type -> SignatureString());
symbol.cpp:        TypeSymbol* formal_type = FormalParameter(i) -> Type();
symbol.cpp:        len += strlen(formal_type -> SignatureString());
symbol.cpp:        for (i = 0; i < containing_type -> NumConstructorParameters(); i++)
symbol.cpp:                containing_type -> ConstructorParameter(i) -> Type();
symbol.cpp:            len += strlen(shadow_type -> SignatureString());
symbol.cpp:            len += strlen(placeholder -> SignatureString());
symbol.cpp:    if (block_symbol && variable_index > block_symbol -> max_variable_index)
symbol.cpp:        block_symbol -> max_variable_index = variable_index;
symbol.cpp:        for (const char* str = this0_type -> SignatureString();
symbol.cpp:        TypeSymbol* formal_type = FormalParameter(i) -> Type();
symbol.cpp:        for (const char* str = formal_type -> SignatureString();
symbol.cpp:        for (i = 0; i < containing_type -> NumConstructorParameters(); i++)
symbol.cpp:                containing_type -> ConstructorParameter(i) -> Type();
symbol.cpp:            for (const char* str = shadow_type -> SignatureString();
symbol.cpp:            for (const char* str = placeholder -> SignatureString();
symbol.cpp:        for (const char* str = Type() -> SignatureString(); *str; str++, s++)
symbol.cpp:        if (containing_type -> EnclosingType() &&
symbol.cpp:            ! containing_type -> EnclosingType() -> ACC_PRIVATE() &&
symbol.cpp:            Identity() == sem -> control.init_name_symbol)
symbol.cpp:            TypeSymbol* enclosing = sem -> ProcessSignature(containing_type,
symbol.cpp:            assert(enclosing == containing_type -> EnclosingType());
symbol.cpp:                sem -> control.MakeParameter(++num_parameters);
symbol.cpp:            symbol -> SetType(sem -> ProcessSignature(containing_type,
symbol.cpp:            symbol -> MarkComplete();
symbol.cpp:        if (Identity() == sem -> control.init_name_symbol)
symbol.cpp:            SetType(sem -> ProcessSignature(containing_type, signature,
symbol.cpp:            block_symbol -> InsertVariableSymbol((*formal_parameters)[k]);
symbol.cpp:        block_symbol -> CompressSpace(); // space optimization
symbol.cpp:    // Make a copy of each parameter into the new pared-down symbol table and
symbol.cpp:            block -> InsertVariableSymbol(formal_parameter -> Identity());
symbol.cpp:        symbol -> SetType(formal_parameter -> Type());
symbol.cpp:        symbol -> MarkComplete();
symbol.cpp:    block -> CompressSpace(); // space optimization
symbol.cpp:    if (IsLocal(sem -> ThisMethod()))
symbol.cpp:        assert(sem -> FinalFields());
symbol.cpp:        return local_variable_index + sem -> FinalFields() -> Length();
symbol.cpp:        file_location = new FileLocation(ContainingType() -> file_symbol);
symbol.cpp:            new FileLocation((ContainingType() -> semantic_environment ->
symbol.cpp:                              sem -> lex_stream),
symbol.cpp:                             declarator -> LeftToken());
symbol.cpp:        SetType(sem -> ProcessSignature((TypeSymbol*) owner, signature,
symbol.cpp:         env; env = env -> previous)
symbol.cpp:        if (env -> Type() == type)
symbol.cpp:// be properly set. Non-static nested classes, however, could have been
symbol.cpp:         env; env = env -> previous)
symbol.cpp:        if (exact ? (env -> Type() == type)
symbol.cpp:            : (env -> Type() -> IsSubclass(type)))
symbol.cpp:            return ! env -> StaticRegion();
symbol.cpp:        if (env -> Type() -> ACC_STATIC()) // No more enclosing levels exist.
symbol.cpp:    assert(semantic_environment && ! target_type -> IsArray());
symbol.cpp:         env; env = env -> previous)
symbol.cpp:        TypeSymbol* main_type = env -> Type();
symbol.cpp:             type; type = type -> owner -> TypeCast())
symbol.cpp:            if (main_type -> IsSubclass(type))
symbol.cpp:           ! semantic_environment -> previous -> StaticRegion());
symbol.cpp:    Control& control = semantic_environment -> sem -> control;
symbol.cpp:    variable_symbol -> SetType(ContainingType());
symbol.cpp:    variable_symbol -> SetFlags(ACCESS_FINAL | ACCESS_SYNTHETIC);
symbol.cpp:    variable_symbol -> SetOwner(this);
symbol.cpp:    variable_symbol -> MarkComplete();
symbol.cpp:    variable_symbol -> MarkInitialized();
symbol.cpp:    // Normally, the place-holder type for invoking private constructors can
symbol.cpp:    // initialization. But if we use the place-holder type to store the
symbol.cpp:    if (placeholder_type && (placeholder_type -> super !=
symbol.cpp:                             semantic_environment -> sem -> control.Object()))
symbol.cpp:        block_symbol -> max_variable_index = 2;
symbol.cpp:        class_literal_method -> SetType(control.Class());
symbol.cpp:        class_literal_method -> SetFlags(ACCESS_STATIC | ACCESS_SYNTHETIC);
symbol.cpp:        class_literal_method -> SetContainingType(this);
symbol.cpp:        class_literal_method -> SetBlockSymbol(block_symbol);
symbol.cpp:            block_symbol -> InsertVariableSymbol(control.MakeParameter(1));
symbol.cpp:        variable_symbol -> SetACC_SYNTHETIC();
symbol.cpp:        variable_symbol -> SetType(control.String());
symbol.cpp:        variable_symbol -> SetOwner(class_literal_method);
symbol.cpp:        variable_symbol -> SetLocalVariableIndex(block_symbol ->
symbol.cpp:        variable_symbol -> MarkComplete();
symbol.cpp:        class_literal_method -> AddFormalParameter(variable_symbol);
symbol.cpp:            block_symbol -> InsertVariableSymbol(control.MakeParameter(2));
symbol.cpp:        variable_symbol -> SetACC_SYNTHETIC();
symbol.cpp:        variable_symbol -> SetType(control.boolean_type);
symbol.cpp:        variable_symbol -> SetOwner(class_literal_method);
symbol.cpp:        variable_symbol -> SetLocalVariableIndex(block_symbol ->
symbol.cpp:        variable_symbol -> MarkComplete();
symbol.cpp:        class_literal_method -> AddFormalParameter(variable_symbol);
symbol.cpp:        class_literal_method -> SetSignature(control);
symbol.cpp:        semantic_environment -> sem -> AddDependence(this, control.Class());
symbol.cpp:        int length = fully_qualified_name -> length;
symbol.cpp:        char* slashed_name = fully_qualified_name -> value;
symbol.cpp:    assert(! type -> Primitive() && ! type -> Anonymous());
symbol.cpp:    Semantic* sem = semantic_environment -> sem;
symbol.cpp:    Control& control = sem -> control;
symbol.cpp:    // non-public members, so if the innermost non-local type is an interface,
symbol.cpp:    while (owner -> IsInner())
symbol.cpp:        owner = owner -> ContainingType();
symbol.cpp:    if (owner -> ACC_INTERFACE())
symbol.cpp:        owner = outermost_type -> FindOrInsertClassLiteralClass();
symbol.cpp:    owner -> FindOrInsertClassLiteralMethod(control);
symbol.cpp:    const char* signature = type -> SignatureString();
symbol.cpp:        int array_length = control.array_name_symbol -> NameLength();
symbol.cpp:        wcscpy(name, control.array_name_symbol -> Name());
symbol.cpp:        int class_length = control.class_name_symbol -> NameLength();
symbol.cpp:        wcscpy(name, control.class_name_symbol -> Name());
symbol.cpp:    VariableSymbol* variable_symbol = owner -> FindVariableSymbol(name_symbol);
symbol.cpp:        variable_symbol = owner -> InsertVariableSymbol(name_symbol);
symbol.cpp:        variable_symbol -> SetType(control.Class());
symbol.cpp:        variable_symbol -> SetFlags(ACCESS_STATIC | ACCESS_SYNTHETIC);
symbol.cpp:        variable_symbol -> SetOwner(owner);
symbol.cpp:        variable_symbol -> MarkComplete();
symbol.cpp:        owner -> AddClassLiteral(variable_symbol);
symbol.cpp:        Semantic* sem = semantic_environment -> sem;
symbol.cpp:        Control& control = sem -> control;
symbol.cpp:        assert_variable -> SetType(control.boolean_type);
symbol.cpp:        assert_variable -> SetFlags(ACCESS_PRIVATE | ACCESS_STATIC |
symbol.cpp:        assert_variable -> SetOwner(this);
symbol.cpp:        assert_variable -> MarkComplete();
symbol.cpp:        assert_variable -> MarkInitialized();
symbol.cpp:        sem -> GetStaticInitializerMethod();
symbol.cpp:    assert(IsLocal() && local -> IsLocal());
symbol.cpp:    Control& control = semantic_environment -> sem -> control;
symbol.cpp:        variable = (VariableSymbol*) local_shadow_map -> Image(local);
symbol.cpp:    // In 1.5 and later, we use the prefix "-" instead of "val$".
symbol.cpp:        int length = control.val_name_symbol -> NameLength() +
symbol.cpp:            local -> NameLength();
symbol.cpp:        wcscpy(name, control.val_name_symbol -> Name());
symbol.cpp:        wcscat(name, local -> Name());
symbol.cpp:        variable -> SetType(local -> Type());
symbol.cpp:        variable -> SetFlags(ACCESS_FINAL | ACCESS_SYNTHETIC);
symbol.cpp:        variable -> SetOwner(this);
symbol.cpp:        variable -> MarkComplete();
symbol.cpp:        variable -> MarkInitialized();
symbol.cpp:        if (ContainingType() == local -> ContainingType())
symbol.cpp:            variable -> accessed_local = local;
symbol.cpp:            variable -> accessed_local = semantic_environment -> sem ->
symbol.cpp:        local_shadow_map -> Map(local, variable);
symbol.cpp:    for (accessed = variable -> accessed_local;
symbol.cpp:         accessed = accessed -> accessed_local);
symbol.cpp:    Map<TypeSymbol, MethodSymbol>* map = read_methods -> Image(symbol);
symbol.cpp:        read_methods -> Add(symbol, map);
symbol.cpp:    map -> Add(base_type, method);
symbol.cpp:        Map<TypeSymbol, MethodSymbol>* map = read_methods -> Image(symbol);
symbol.cpp:            return map -> Image(base_type);
symbol.cpp:    Map<TypeSymbol, MethodSymbol>* map = write_methods -> Image(symbol);
symbol.cpp:        write_methods -> Add(symbol, map);
symbol.cpp:    map -> Add(base_type, method);
symbol.cpp:        Map<TypeSymbol, MethodSymbol>* map = write_methods -> Image(symbol);
symbol.cpp:            return map -> Image(base_type);
symbol.cpp:    assert(member -> Identity() !=
symbol.cpp:           semantic_environment -> sem -> control.init_name_symbol);
symbol.cpp:    TypeSymbol* containing_type = member -> containing_type;
symbol.cpp:    assert((member -> ACC_PRIVATE() && this == containing_type) ||
symbol.cpp:           (member -> ACC_PROTECTED() &&
symbol.cpp:            ! semantic_environment -> sem -> ProtectedAccessCheck(containing_type)) ||
symbol.cpp:           (base_type == super && ! member -> ACC_STATIC()));
symbol.cpp:        // In 1.5 and later, we use the prefix "-" instead of "access$".
symbol.cpp:        Semantic* sem = semantic_environment -> sem;
symbol.cpp:        Control& control = sem -> control;
symbol.cpp:        StoragePool* ast_pool = sem -> compilation_unit -> ast_pool;
symbol.cpp:        int length = control.access_name_symbol -> NameLength() +
symbol.cpp:        wcscpy(name, control.access_name_symbol -> Name());
symbol.cpp:        TokenIndex loc = declaration -> identifier_token;
symbol.cpp:        unsigned parameter_count = member -> NumFormalParameters();
symbol.cpp:        Table() -> AddMethodSymbol(read_method);
symbol.cpp:        read_method -> SetType(member -> Type());
symbol.cpp:        read_method -> SetFlags(ACCESS_STATIC | ACCESS_SYNTHETIC);
symbol.cpp:        if (member -> ACC_STRICTFP())
symbol.cpp:            read_method -> SetACC_STRICTFP();
symbol.cpp:        if (member -> ACC_FINAL() || ACC_FINAL())
symbol.cpp:            read_method -> SetACC_FINAL();
symbol.cpp:        read_method -> SetContainingType(this);
symbol.cpp:                            (member -> ACC_STATIC() ? 0 : 1));
symbol.cpp:        block_symbol -> max_variable_index = 0;
symbol.cpp:        read_method -> SetBlockSymbol(block_symbol);
symbol.cpp:        for (unsigned j = 0; j < member -> NumThrows(); j++)
symbol.cpp:            read_method -> AddThrows(member -> Throws(j));
symbol.cpp:        if (! member -> ACC_STATIC() && base_type == super)
symbol.cpp:            // Special case - for Outer.super.m() where m() is an instance
symbol.cpp:            base = ast_pool -> GenSuperExpression(loc);
symbol.cpp:        else base = ast_pool -> GenName(loc);
symbol.cpp:        AstArguments* args = ast_pool -> GenArguments(loc, loc);
symbol.cpp:        args -> AllocateArguments(parameter_count);
symbol.cpp:            ast_pool -> GenMethodInvocation(loc);
symbol.cpp:        method_invocation -> base_opt = base;
symbol.cpp:        method_invocation -> arguments = args;
symbol.cpp:        method_invocation -> symbol = member;
symbol.cpp:            ast_pool -> GenMethodDeclarator();
symbol.cpp:        method_declarator -> identifier_token = loc;
symbol.cpp:        method_declarator -> left_parenthesis_token = loc;
symbol.cpp:        method_declarator -> right_parenthesis_token = loc;
symbol.cpp:        if (member -> ACC_STATIC())
symbol.cpp:            method_declarator -> AllocateFormalParameters(parameter_count);
symbol.cpp:            base -> symbol = base_type;
symbol.cpp:            method_declarator -> AllocateFormalParameters(parameter_count + 1);
symbol.cpp:                block_symbol -> InsertVariableSymbol(instance_name);
symbol.cpp:            instance -> SetACC_SYNTHETIC();
symbol.cpp:            instance -> SetType(base_type == super ? this : base_type);
symbol.cpp:            instance -> SetOwner(read_method);
symbol.cpp:            instance -> SetLocalVariableIndex(block_symbol ->
symbol.cpp:            instance -> MarkComplete();
symbol.cpp:            read_method -> AddFormalParameter(instance);
symbol.cpp:            base -> symbol = (base_type == super
symbol.cpp:            VariableSymbol* parm = block_symbol ->
symbol.cpp:                InsertVariableSymbol(member -> FormalParameter(i) -> Identity());
symbol.cpp:            parm -> SetACC_SYNTHETIC();
symbol.cpp:            parm -> SetType(member -> FormalParameter(i) -> Type());
symbol.cpp:            parm -> SetOwner(read_method);
symbol.cpp:            parm -> SetLocalVariableIndex(block_symbol ->
symbol.cpp:            parm -> MarkComplete();
symbol.cpp:            if (control.IsDoubleWordType(parm -> Type()))
symbol.cpp:                block_symbol -> max_variable_index++;
symbol.cpp:            read_method -> AddFormalParameter(parm);
symbol.cpp:            AstName* simple_name = ast_pool -> GenName(loc);
symbol.cpp:            simple_name -> symbol = parm;
symbol.cpp:            args -> AddArgument(simple_name);
symbol.cpp:        read_method -> SetSignature(control);
symbol.cpp:            ast_pool -> GenReturnStatement();
symbol.cpp:        return_statement -> return_token = loc;
symbol.cpp:        return_statement -> semicolon_token = loc;
symbol.cpp:        return_statement -> is_reachable = true;
symbol.cpp:        AstMethodBody* block = ast_pool -> GenMethodBody();
symbol.cpp:        block -> left_brace_token = loc;
symbol.cpp:        block -> right_brace_token = loc;
symbol.cpp:        block -> block_symbol = new BlockSymbol(0);
symbol.cpp:        block -> is_reachable = true;
symbol.cpp:        if (member -> Type() == control.void_type)
symbol.cpp:                ast_pool -> GenExpressionStatement();
symbol.cpp:            expression_statement -> expression = method_invocation;
symbol.cpp:            expression_statement -> semicolon_token_opt = loc;
symbol.cpp:            expression_statement -> is_reachable = true;
symbol.cpp:            expression_statement -> can_complete_normally = true;
symbol.cpp:            block -> AllocateStatements(2);
symbol.cpp:            block -> AddStatement(expression_statement);
symbol.cpp:            return_statement -> expression_opt = method_invocation;
symbol.cpp:            block -> AllocateStatements(1);
symbol.cpp:        block -> AddStatement(return_statement);
symbol.cpp:            ast_pool -> GenMethodDeclaration();
symbol.cpp:        method_declaration -> method_symbol = read_method;
symbol.cpp:        method_declaration -> method_declarator = method_declarator;
symbol.cpp:        method_declaration -> method_body_opt = block;
symbol.cpp:        read_method -> declaration = method_declaration;
symbol.cpp:        read_method -> accessed_member = member;
symbol.cpp:    assert((ctor -> Identity() ==
symbol.cpp:            semantic_environment -> sem -> control.init_name_symbol) &&
symbol.cpp:           ctor -> ACC_PRIVATE() && this == ctor -> containing_type &&
symbol.cpp:        // We must create a synthetic place-holder class, and expand this to:
symbol.cpp:        // Here again, we create a place-holder class for now.  TODO:
symbol.cpp:        Semantic* sem = semantic_environment -> sem;
symbol.cpp:        if (sem -> error && sem -> error -> InClone())
symbol.cpp:        Control& control = sem -> control;
symbol.cpp:        StoragePool* ast_pool = sem -> compilation_unit -> ast_pool;
symbol.cpp:            new BlockSymbol(ctor -> NumFormalParameters() + 3);
symbol.cpp:        Table() -> AddMethodSymbol(read_method);
symbol.cpp:        read_method -> SetType(this);
symbol.cpp:        read_method -> SetContainingType(this);
symbol.cpp:        read_method -> SetBlockSymbol(block_symbol);
symbol.cpp:        read_method -> SetACC_SYNTHETIC();
symbol.cpp:        if (ctor -> ACC_STRICTFP())
symbol.cpp:            read_method -> SetACC_STRICTFP();
symbol.cpp:        for (unsigned j = 0; j < ctor -> NumThrows(); j++)
symbol.cpp:            read_method -> AddThrows(ctor -> Throws(j));
symbol.cpp:        block_symbol -> max_variable_index = 1;
symbol.cpp:        read_method -> SetExternalIdentity(ctor -> Identity());
symbol.cpp:        Ast* declaration = ctor -> declaration;
symbol.cpp:            ((AstConstructorDeclaration*) declaration) -> constructor_declarator;
symbol.cpp:        TokenIndex loc = declarator -> identifier_token;
symbol.cpp:            ast_pool -> GenMethodDeclarator();
symbol.cpp:        method_declarator -> identifier_token = loc;
symbol.cpp:        method_declarator -> left_parenthesis_token =
symbol.cpp:            declarator -> LeftToken();
symbol.cpp:        method_declarator -> right_parenthesis_token =
symbol.cpp:            declarator -> RightToken();
symbol.cpp:        AstArguments* args = ast_pool -> GenArguments(loc, loc);
symbol.cpp:        args -> AllocateArguments(ctor -> NumFormalParameters());
symbol.cpp:        AstThisCall* this_call = ast_pool -> GenThisCall();
symbol.cpp:        this_call -> this_token = loc;
symbol.cpp:        this_call -> arguments = args;
symbol.cpp:        this_call -> semicolon_token = loc;
symbol.cpp:        this_call -> symbol = ctor;
symbol.cpp:            this0_variable = block_symbol ->
symbol.cpp:            this0_variable -> SetACC_SYNTHETIC();
symbol.cpp:            this0_variable -> SetType(ContainingType());
symbol.cpp:            this0_variable -> SetOwner(read_method);
symbol.cpp:            this0_variable -> SetLocalVariableIndex(block_symbol ->
symbol.cpp:            this0_variable -> MarkComplete();
symbol.cpp:        for (unsigned i = 0; i < ctor -> NumFormalParameters(); i++)
symbol.cpp:            parm = block_symbol -> InsertVariableSymbol(ctor -> FormalParameter(i) -> Identity());
symbol.cpp:            parm -> SetACC_SYNTHETIC();
symbol.cpp:            parm -> SetType(ctor -> FormalParameter(i) -> Type());
symbol.cpp:            parm -> SetOwner(read_method);
symbol.cpp:            parm -> SetLocalVariableIndex(block_symbol ->
symbol.cpp:            parm -> MarkComplete();
symbol.cpp:            if (control.IsDoubleWordType(parm -> Type()))
symbol.cpp:                block_symbol -> max_variable_index++;
symbol.cpp:            read_method -> AddFormalParameter(parm);
symbol.cpp:                declarator -> FormalParameter(i) -> formal_declarator ->
symbol.cpp:            AstName* simple_name = ast_pool ->
symbol.cpp:                GenName(variable_declarator_name -> identifier_token);
symbol.cpp:            simple_name -> symbol = parm;
symbol.cpp:            args -> AddArgument(simple_name);
symbol.cpp:        read_method -> SetSignature(control,
symbol.cpp:                                    outermost_type -> GetPlaceholderType());
symbol.cpp:            ast_pool -> GenReturnStatement();
symbol.cpp:        return_statement -> return_token = loc;
symbol.cpp:        return_statement -> semicolon_token = loc;
symbol.cpp:        return_statement -> is_reachable = true;
symbol.cpp:        AstMethodBody* constructor_block = ast_pool -> GenMethodBody();
symbol.cpp:        constructor_block -> block_symbol = new BlockSymbol(0);
symbol.cpp:        constructor_block -> block_symbol -> max_variable_index =
symbol.cpp:            block_symbol -> max_variable_index;
symbol.cpp:        constructor_block -> left_brace_token = loc;
symbol.cpp:        constructor_block -> right_brace_token = loc;
symbol.cpp:        constructor_block -> AllocateStatements(1);
symbol.cpp:        constructor_block -> AddStatement(return_statement);
symbol.cpp:        constructor_block -> explicit_constructor_opt = this_call;
symbol.cpp:            ast_pool -> GenConstructorDeclaration();
symbol.cpp:        constructor_declaration -> constructor_declarator = method_declarator;
symbol.cpp:        constructor_declaration -> constructor_body = constructor_block;
symbol.cpp:        constructor_declaration -> constructor_symbol = read_method;
symbol.cpp:        read_method -> declaration = constructor_declaration;
symbol.cpp:        read_method -> accessed_member = ctor;
symbol.cpp:    TypeSymbol* containing_type = member -> owner -> TypeCast();
symbol.cpp:    assert((member -> ACC_PRIVATE() && this == containing_type) ||
symbol.cpp:           (member -> ACC_PROTECTED() &&
symbol.cpp:            (! semantic_environment -> sem -> ProtectedAccessCheck(containing_type) ||
symbol.cpp:             (base_type == super && ! member -> ACC_STATIC()))));
symbol.cpp:        // In 1.5 and later, we use the prefix "-" instead of "access$".
symbol.cpp:        Semantic* sem = semantic_environment -> sem;
symbol.cpp:        Control& control = sem -> control;
symbol.cpp:        StoragePool* ast_pool = sem -> compilation_unit -> ast_pool;
symbol.cpp:        int length = control.access_name_symbol -> NameLength() +
symbol.cpp:        wcscpy(name, control.access_name_symbol -> Name());
symbol.cpp:        TokenIndex loc = declaration -> identifier_token;
symbol.cpp:        Table() -> AddMethodSymbol(read_method);
symbol.cpp:        read_method -> SetType(member -> Type());
symbol.cpp:        read_method -> SetFlags(ACCESS_STATIC | ACCESS_SYNTHETIC);
symbol.cpp:            read_method -> SetACC_STRICTFP();
symbol.cpp:            read_method -> SetACC_FINAL();
symbol.cpp:        read_method -> SetContainingType(this);
symbol.cpp:            new BlockSymbol(member -> ACC_STATIC() ? 0 : 1);
symbol.cpp:        block_symbol -> max_variable_index = 0;
symbol.cpp:        read_method -> SetBlockSymbol(block_symbol);
symbol.cpp:        if (! member -> ACC_STATIC() && base_type == super)
symbol.cpp:            // Special case - for Outer.super.i where i is an instance field,
symbol.cpp:            base = ast_pool -> GenSuperExpression(loc);
symbol.cpp:        else base = ast_pool -> GenName(loc);
symbol.cpp:        AstFieldAccess* field_access = ast_pool -> GenFieldAccess();
symbol.cpp:        field_access -> base = base;
symbol.cpp:        field_access -> identifier_token = loc;
symbol.cpp:        field_access -> symbol = member;
symbol.cpp:            ast_pool -> GenMethodDeclarator();
symbol.cpp:        method_declarator -> identifier_token = loc;
symbol.cpp:        method_declarator -> left_parenthesis_token = loc;
symbol.cpp:        method_declarator -> right_parenthesis_token = loc;
symbol.cpp:        if (member -> ACC_STATIC())
symbol.cpp:            base -> symbol = base_type;
symbol.cpp:            method_declarator -> AllocateFormalParameters(1);
symbol.cpp:                block_symbol -> InsertVariableSymbol(instance_name);
symbol.cpp:            instance -> SetACC_SYNTHETIC();
symbol.cpp:            instance -> SetType(base_type == super ? this : base_type);
symbol.cpp:            instance -> SetOwner(read_method);
symbol.cpp:            instance -> SetLocalVariableIndex(block_symbol ->
symbol.cpp:            instance -> MarkComplete();
symbol.cpp:            read_method -> AddFormalParameter(instance);
symbol.cpp:            base -> symbol = (base_type == super
symbol.cpp:        read_method -> SetSignature(control);
symbol.cpp:            ast_pool -> GenReturnStatement();
symbol.cpp:        return_statement -> return_token = loc;
symbol.cpp:        return_statement -> expression_opt = field_access;
symbol.cpp:        return_statement -> semicolon_token = loc;
symbol.cpp:        return_statement -> is_reachable = true;
symbol.cpp:        AstMethodBody* block = ast_pool -> GenMethodBody();
symbol.cpp:        block -> left_brace_token = loc;
symbol.cpp:        block -> right_brace_token = loc;
symbol.cpp:        block -> block_symbol = new BlockSymbol(0);
symbol.cpp:        block -> is_reachable = true;
symbol.cpp:        block -> AllocateStatements(1);
symbol.cpp:        block -> AddStatement(return_statement);
symbol.cpp:            ast_pool -> GenMethodDeclaration();
symbol.cpp:        method_declaration -> method_symbol = read_method;
symbol.cpp:        method_declaration -> method_declarator = method_declarator;
symbol.cpp:        method_declaration -> method_body_opt = block;
symbol.cpp:        read_method -> declaration = method_declaration;
symbol.cpp:        read_method -> accessed_member = member;
symbol.cpp:    TypeSymbol* containing_type = member -> owner -> TypeCast();
symbol.cpp:    assert((member -> ACC_PRIVATE() && this == containing_type) ||
symbol.cpp:           (member -> ACC_PROTECTED() &&
symbol.cpp:            (! semantic_environment -> sem -> ProtectedAccessCheck(containing_type) ||
symbol.cpp:             (base_type == super && ! member -> ACC_STATIC()))));
symbol.cpp:        // In 1.5 and later, we use the prefix "-" instead of "access$".
symbol.cpp:        Semantic* sem = semantic_environment -> sem;
symbol.cpp:        Control& control = sem -> control;
symbol.cpp:        StoragePool* ast_pool = sem -> compilation_unit -> ast_pool;
symbol.cpp:        int length = control.access_name_symbol -> NameLength() +
symbol.cpp:        wcscpy(name, control.access_name_symbol -> Name());
symbol.cpp:        TokenIndex loc = declaration -> identifier_token;
symbol.cpp:        Table() -> AddMethodSymbol(write_method);
symbol.cpp:        write_method -> SetType(sem -> control.void_type);
symbol.cpp:        write_method -> SetFlags(ACCESS_STATIC | ACCESS_SYNTHETIC);
symbol.cpp:            write_method -> SetACC_STRICTFP();
symbol.cpp:            write_method -> SetACC_FINAL();
symbol.cpp:        write_method -> SetContainingType(this);
symbol.cpp:            new BlockSymbol(member -> ACC_STATIC() ? 1 : 2);
symbol.cpp:        block_symbol -> max_variable_index = 0;
symbol.cpp:        write_method -> SetBlockSymbol(block_symbol);
symbol.cpp:        if (! member -> ACC_STATIC() && base_type == super)
symbol.cpp:            // Special case - for Outer.super.i where i is an instance field,
symbol.cpp:            base = ast_pool -> GenSuperExpression(loc);
symbol.cpp:        else base = ast_pool -> GenName(loc);
symbol.cpp:        AstFieldAccess* left_hand_side = ast_pool -> GenFieldAccess();
symbol.cpp:        left_hand_side -> base = base;
symbol.cpp:        left_hand_side -> identifier_token = loc;
symbol.cpp:        left_hand_side -> symbol = member;
symbol.cpp:            ast_pool -> GenMethodDeclarator();
symbol.cpp:        method_declarator -> identifier_token = loc;
symbol.cpp:        method_declarator -> left_parenthesis_token = loc;
symbol.cpp:        method_declarator -> right_parenthesis_token = loc;
symbol.cpp:        if (member -> ACC_STATIC())
symbol.cpp:            method_declarator -> AllocateFormalParameters(1);
symbol.cpp:            base -> symbol = base_type;
symbol.cpp:            method_declarator -> AllocateFormalParameters(2);
symbol.cpp:                block_symbol -> InsertVariableSymbol(instance_name);
symbol.cpp:            instance -> SetACC_SYNTHETIC();
symbol.cpp:            instance -> SetType(base_type == super ? this : base_type);
symbol.cpp:            instance -> SetOwner(write_method);
symbol.cpp:            instance -> SetLocalVariableIndex(block_symbol ->
symbol.cpp:            instance -> MarkComplete();
symbol.cpp:            write_method -> AddFormalParameter(instance);
symbol.cpp:            base -> symbol = (base_type == super
symbol.cpp:            block_symbol -> InsertVariableSymbol(member -> Identity());
symbol.cpp:        symbol -> SetACC_SYNTHETIC();
symbol.cpp:        symbol -> SetType(member -> Type());
symbol.cpp:        symbol -> SetOwner(write_method);
symbol.cpp:        symbol -> SetLocalVariableIndex(block_symbol -> max_variable_index++);
symbol.cpp:        symbol -> MarkComplete();
symbol.cpp:        if (control.IsDoubleWordType(member -> Type()))
symbol.cpp:            block_symbol -> max_variable_index++;
symbol.cpp:        write_method -> AddFormalParameter(symbol);
symbol.cpp:        write_method -> SetSignature(control);
symbol.cpp:        AstName* simple_name = ast_pool -> GenName(loc);
symbol.cpp:        simple_name -> symbol = symbol;
symbol.cpp:        AstAssignmentExpression* assignment_expression = ast_pool ->
symbol.cpp:        assignment_expression -> left_hand_side = left_hand_side;
symbol.cpp:        assignment_expression -> expression = simple_name;
symbol.cpp:            ast_pool -> GenExpressionStatement();
symbol.cpp:        expression_statement -> expression = assignment_expression;
symbol.cpp:        expression_statement -> semicolon_token_opt = loc;
symbol.cpp:        expression_statement -> is_reachable = true;
symbol.cpp:        expression_statement -> can_complete_normally = true;
symbol.cpp:            ast_pool -> GenReturnStatement();
symbol.cpp:        return_statement -> return_token = loc;
symbol.cpp:        return_statement -> semicolon_token = loc;
symbol.cpp:        return_statement -> is_reachable = true;
symbol.cpp:        AstMethodBody* block = ast_pool -> GenMethodBody();
symbol.cpp:        block -> left_brace_token = loc;
symbol.cpp:        block -> right_brace_token = loc;
symbol.cpp:        block -> block_symbol = new BlockSymbol(0);
symbol.cpp:        block -> is_reachable = true;
symbol.cpp:        block -> AllocateStatements(2);
symbol.cpp:        block -> AddStatement(expression_statement);
symbol.cpp:        block -> AddStatement(return_statement);
symbol.cpp:            ast_pool -> GenMethodDeclaration();
symbol.cpp:        method_declaration -> method_symbol = write_method;
symbol.cpp:        method_declaration -> method_declarator = method_declarator;
symbol.cpp:        method_declaration -> method_body_opt = block;
symbol.cpp:        write_method -> declaration = method_declaration;
symbol.cpp:        write_method -> accessed_member = member;
symbol.cpp:    assert(read_method && read_method -> ACC_SYNTHETIC() &&
symbol.cpp:           read_method -> containing_type == this);
symbol.cpp:        DYNAMIC_CAST<VariableSymbol*> (read_method -> accessed_member);
symbol.cpp:        DYNAMIC_CAST<AstMethodDeclaration*> (read_method -> declaration);
symbol.cpp:    AstMethodBody* block = method_declaration -> method_body_opt;
symbol.cpp:        DYNAMIC_CAST<AstReturnStatement*> (block -> Statement(0));
symbol.cpp:        DYNAMIC_CAST<AstFieldAccess*> (return_statement -> expression_opt);
symbol.cpp:    return GetWriteAccessMethod(variable, field_access -> base -> Type());
symbol.cpp:        Semantic* sem = semantic_environment -> sem;
symbol.cpp:        sem -> state_stack.Push(semantic_environment);
symbol.cpp:        TokenIndex loc = declaration -> identifier_token;
symbol.cpp:        Control& control = sem -> control;
symbol.cpp:        StoragePool* ast_pool = sem -> compilation_unit -> ast_pool;
symbol.cpp:        AstClassBody* class_body = ast_pool -> GenClassBody();
symbol.cpp:        class_body -> left_brace_token = loc;
symbol.cpp:        class_body -> right_brace_token = loc;
symbol.cpp:        AstName* ast_type = ast_pool -> GenName(loc);
symbol.cpp:            ast_pool -> GenClassCreationExpression();
symbol.cpp:        class_creation -> new_token = loc;
symbol.cpp:        class_creation -> class_type = ast_pool -> GenTypeName(ast_type);
symbol.cpp:        class_creation -> arguments = ast_pool -> GenArguments(loc, loc);
symbol.cpp:        class_creation -> class_body_opt = class_body;
symbol.cpp:        sem -> GetAnonymousType(class_creation, control.Object());
symbol.cpp:        sem -> state_stack.Pop();
symbol.cpp:        placeholder_type -> SetACC_SYNTHETIC();
symbol.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
symbol.h:    virtual const wchar_t* Name() const { return name_symbol -> Name(); }
symbol.h:    virtual unsigned NameLength() const { return name_symbol -> NameLength(); }
symbol.h:        return name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> value : (char*) NULL;
symbol.h:        return name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> length : 0;
symbol.h:    virtual const wchar_t* Name() const { return name_symbol -> Name(); }
symbol.h:    virtual unsigned NameLength() const { return name_symbol -> NameLength(); }
symbol.h:        return name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> value : (char*) NULL;
symbol.h:        return name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> length : 0;
symbol.h:        return entries ? entries -> FindEntry(name, len)
symbol.h:        return entries ? entries -> FindCaseInsensitiveEntry(name, length)
symbol.h:        DirectoryEntry* entry = entries -> InsertEntry(this, name, length);
symbol.h:        entries -> InsertCaseInsensitiveEntry(entry);
symbol.h:        return owner -> PathCast() ? (PathSymbol*) owner
symbol.h:            : ((DirectorySymbol*) owner) -> PathSym();
symbol.h:    inline bool IsZip() { return PathSym() -> IsZip(); }
symbol.h:    // This field holds the time of last data modification for a non-zip file
symbol.h:        clone -> kind = kind;
symbol.h:        clone -> directory_symbol = directory_symbol;
symbol.h:        clone -> mtime = mtime;
symbol.h:    virtual const wchar_t* Name() const { return name_symbol -> Name(); }
symbol.h:    virtual unsigned NameLength() const { return name_symbol -> NameLength(); }
symbol.h:        return name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> value : (char*) NULL;
symbol.h:        return name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> length : 0;
symbol.h:        return directory_symbol -> PathSym();
symbol.h:    inline bool IsZip() { return PathSym() -> IsZip(); }
symbol.h:    inline Zip* Zipfile() { return PathSym() -> zipfile; }
symbol.h:        char* file_name = file_symbol -> FileName();
symbol.h:        unsigned length = file_symbol -> FileNameLength();
symbol.h:    virtual const wchar_t* Name() const { return name_symbol -> Name(); }
symbol.h:    virtual unsigned NameLength() const { return name_symbol -> NameLength(); }
symbol.h:        return name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> value : (char*) NULL;
symbol.h:        return name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> length : 0;
symbol.h:            DYNAMIC_CAST<AccessFlags*> (accessed_member) -> ACC_STATIC();
symbol.h:    virtual const wchar_t* Name() const { return name_symbol -> Name(); }
symbol.h:    virtual unsigned NameLength() const { return name_symbol -> NameLength(); }
symbol.h:        return name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> value : (char*) NULL;
symbol.h:        return name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> length : 0;
symbol.h:        return (wchar_t*) (file_location ? file_location -> location : NULL);
symbol.h:        //  ( "this -> ProcessMethodSignature(sem, tok);" )
symbol.h:        return formal_parameters ? formal_parameters -> Length() : 0;
symbol.h:        formal_parameters -> Next() = variable;
symbol.h:        return throws ? throws -> Length() : 0;
symbol.h:        throws -> Next() = exception;
symbol.h:        return throws_signatures ? throws_signatures -> Length() : 0;
symbol.h:        throws_signatures -> Next() = signature;
symbol.h:        return external_name_symbol ? external_name_symbol -> Name()
symbol.h:            : name_symbol -> Name();
symbol.h:        return external_name_symbol ? external_name_symbol -> NameLength()
symbol.h:            : name_symbol -> NameLength();
symbol.h:            ? external_name_symbol -> Utf8_literal -> value
symbol.h:            : name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> value : (char*) NULL;
symbol.h:        return external_name_symbol && external_name_symbol -> Utf8_literal
symbol.h:            ? external_name_symbol -> Utf8_literal -> length
symbol.h:            : name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> length : 0;
symbol.h:    const char* SignatureString() const { return signature -> value; }
symbol.h:    // forms an inter-type cycle in its "extends" or "implements" relationship.
symbol.h:    // forms an intra-type cycle in its "extends" or "implements" relationship;
symbol.h:            ? local_constructor_call_environments -> Length() : 0;
symbol.h:        local_constructor_call_environments -> Next() = environment;
symbol.h:            ? private_access_methods -> Length() : 0;
symbol.h:        private_access_methods -> Next() = method_symbol;
symbol.h:            ? private_access_constructors -> Length() : 0;
symbol.h:        private_access_constructors -> Next() = constructor_symbol;
symbol.h:            ? constructor_parameters -> Length() : 0;
symbol.h:        constructor_parameters -> Next() = variable_symbol;
symbol.h:        return class_literals ? class_literals -> Length() : 0;
symbol.h:        class_literals -> Next() = literal_symbol;
symbol.h:        return nested_types ? nested_types -> Length() : 0;
symbol.h:        nested_types -> Next() = type_symbol;
symbol.h:        return interfaces ? interfaces -> Length() : 0;
symbol.h:        interfaces -> Next() = type_symbol;
symbol.h:        return anonymous_types ? anonymous_types -> Length() : 0;
symbol.h:        anonymous_types -> Next() = type_symbol;
symbol.h:        if (! outermost_type -> placeholder_type)
symbol.h:            outermost_type -> placeholder_type = type_symbol;
symbol.h:    virtual const wchar_t* Name() const { return name_symbol -> Name(); }
symbol.h:    virtual unsigned NameLength() const { return name_symbol -> NameLength(); }
symbol.h:        return name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> value : (char*) NULL;
symbol.h:        return name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> length : 0;
symbol.h:        return external_name_symbol ? external_name_symbol -> Name()
symbol.h:            : name_symbol -> Name();
symbol.h:        return external_name_symbol ? external_name_symbol -> NameLength()
symbol.h:            : name_symbol -> NameLength();
symbol.h:            ? external_name_symbol -> Utf8_literal -> value
symbol.h:            : name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> value : (char*) NULL;
symbol.h:        return external_name_symbol && external_name_symbol -> Utf8_literal
symbol.h:            ? external_name_symbol -> Utf8_literal -> length
symbol.h:            : name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> length : 0;
symbol.h:        Symbol* sym = type -> owner;
symbol.h:        while (! sym -> PackageCast())
symbol.h:            MethodSymbol* method = sym -> MethodCast();
symbol.h:            sym = (method ? method -> containing_type
symbol.h:                   : ((TypeSymbol*) sym) -> owner);
symbol.h:            TypeSymbol* type = owner -> TypeCast();
symbol.h:            MethodSymbol* method = owner -> MethodCast();
symbol.h:                return method -> containing_type;
symbol.h:            TypeSymbol* type = owner -> TypeCast();
symbol.h:            MethodSymbol* method = owner -> MethodCast();
symbol.h:                return method -> containing_type;
symbol.h:    // For JSR 201, control.int_class -> BoxedType() returns control.Integer(),
symbol.h:        for (const TypeSymbol* type = this; type; type = type -> super)
symbol.h:            if (Interface(i) -> IsSubinterface(super_interface))
symbol.h:            if (Interface(i) -> IsSubinterface(inter))
symbol.h:        return super && super -> Implements(inter);
symbol.h:            return (type -> ACC_INTERFACE() && IsSubinterface(type)) ||
symbol.h:                type -> base_type ? type -> base_type : type;
symbol.h:            return (num_dimensions > type -> num_dimensions &&
symbol.h:                    ((base -> ACC_INTERFACE() && Implements(base)) ||
symbol.h:                (num_dimensions == type -> num_dimensions &&
symbol.h:                 base_type -> IsSubtype(base));
symbol.h:        return type -> ACC_INTERFACE() ? Implements(type) : IsSubclass(type);
symbol.h:        return file_location ? file_location -> location : (wchar_t*) NULL;
symbol.h:    // type as this (ie. Object[] -> GetArrayType(...,2) returns Object[][]).
symbol.h:        return base_type -> Array(num_dimensions - 1);
symbol.h:    const char* SignatureString() const { return signature -> value; }
symbol.h:        return outermost_type -> owner -> PackageCast();
symbol.h:    // Returns the fully-qualified '/' separated package name.
symbol.h:        return outermost_type -> owner -> PackageCast() -> PackageName();
symbol.h:             ! sym -> PackageCast(); sym = ((TypeSymbol*) sym) -> owner)
symbol.h:            if (sym -> MethodCast())
symbol.h:            ? nested_type_signatures -> Length() : 0;
symbol.h:        nested_type_signatures -> Next() = signature;
symbol.h:        return array ? array -> Length() : 0;
symbol.h:        array -> Next() = type_symbol;
symbol.h:    virtual const wchar_t* Name() const { return name_symbol -> Name(); }
symbol.h:    virtual unsigned NameLength() const { return name_symbol -> NameLength(); }
symbol.h:        return name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> value : (char*) NULL;
symbol.h:        return name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> length : 0;
symbol.h:        return (wchar_t*) (file_location ? file_location -> location : NULL);
symbol.h:        return external_name_symbol ? external_name_symbol -> Name()
symbol.h:            : name_symbol -> Name();
symbol.h:        return external_name_symbol ? external_name_symbol -> NameLength()
symbol.h:            : name_symbol -> NameLength();
symbol.h:            ? external_name_symbol -> Utf8_literal -> value
symbol.h:            : name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> value : (char*) NULL;
symbol.h:        return external_name_symbol && external_name_symbol -> Utf8_literal
symbol.h:            ? external_name_symbol -> Utf8_literal -> length
symbol.h:            : name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> length : 0;
symbol.h:        , local_variable_index(-1)
symbol.h:        assert(owner -> TypeCast() || owner -> MethodCast());
symbol.h:        MethodSymbol* method_owner = owner -> MethodCast();
symbol.h:        return method_owner ? method_owner -> containing_type
symbol.h:            : owner -> TypeCast();
symbol.h:        MethodSymbol* method_owner = owner -> MethodCast();
symbol.h:        return method_owner ? method_owner -> containing_type
symbol.h:            : owner -> TypeCast();
symbol.h:        signature = type_ -> signature;
symbol.h:        // ( "this -> ProcessVariableSignature(sem, tok);" )
symbol.h:    bool IsLocal() { return owner -> MethodCast() != NULL; }
symbol.h:    virtual const wchar_t* Name() const { return name_symbol -> Name(); }
symbol.h:    virtual unsigned NameLength() const { return name_symbol -> NameLength(); }
symbol.h:        return name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> value : (char*) NULL;
symbol.h:        return name_symbol -> Utf8_literal
symbol.h:            ? name_symbol -> Utf8_literal -> length : 0;
symbol.h:        return anonymous_symbol_pool ? anonymous_symbol_pool -> Length() : 0;
symbol.h:        anonymous_symbol_pool -> Next() = symbol;
symbol.h:        return type_symbol_pool ? type_symbol_pool -> Length() : 0;
symbol.h:        symbol -> pool_index = NumTypeSymbols();
symbol.h:        type_symbol_pool -> Next() = symbol;
symbol.h:        return method_symbol_pool ? method_symbol_pool -> Length() : 0;
symbol.h:        symbol -> pool_index = NumMethodSymbols();
symbol.h:        method_symbol_pool -> Next() = symbol;
symbol.h:        return variable_symbol_pool ? variable_symbol_pool -> Length() : 0;
symbol.h:        symbol -> pool_index = NumVariableSymbols();
symbol.h:        variable_symbol_pool -> Next() = symbol;
symbol.h:        return other_symbol_pool ? other_symbol_pool -> Length() : 0;
symbol.h:        other_symbol_pool -> Next() = symbol;
symbol.h:            anonymous_symbol_pool -> Array();
symbol.h:            method_symbol_pool -> Array();
symbol.h:            variable_symbol_pool -> Array();
symbol.h:            other_symbol_pool -> Array();
symbol.h:        unsigned k = symbol -> Identity() -> index % hash_size;
symbol.h:        symbol -> next = base[k];
symbol.h:    return table ? table -> NumVariableSymbols() : 0;
symbol.h:    return table -> VariableSym(i);
symbol.h:    return table ? table -> NumVariableSymbols() : 0;
symbol.h:    return table -> VariableSym(i);
symbol.h:    return table ? table -> NumMethodSymbols() : 0;
symbol.h:    return table -> MethodSym(i);
symbol.h:    return table ? table -> NumTypeSymbols() : 0;
symbol.h:    return table -> TypeSym(i);
symbol.h:        table -> CompressSpace();
symbol.h:        table -> CompressSpace();
symbol.h:    directory_symbol -> owner = symbol;
symbol.h:    symbol -> root_directory = directory_symbol;
symbol.h:    for (Symbol* symbol = base[name_symbol -> index % hash_size];
symbol.h:         symbol; symbol = symbol -> next)
symbol.h:        if (name_symbol == symbol -> Identity() && symbol -> PathCast())
symbol.h:        Table() -> InsertDirectorySymbol(name_symbol, this,
symbol.h:    for (Symbol* symbol = base[name_symbol -> index % hash_size];
symbol.h:         symbol; symbol = symbol -> next)
symbol.h:        if (name_symbol == symbol -> Identity() && symbol -> DirectoryCast())
symbol.h:    return table ? table -> FindDirectorySymbol(name_symbol)
symbol.h:    return Table() -> InsertFileSymbol(name_symbol);
symbol.h:    for (Symbol* symbol = base[name_symbol -> index % hash_size];
symbol.h:         symbol; symbol = symbol -> next)
symbol.h:        if (name_symbol == symbol -> Identity() && symbol -> FileCast())
symbol.h:    return table ? table -> FindFileSymbol(name_symbol)
symbol.h:    return Table() -> InsertPackageSymbol(name_symbol, this);
symbol.h:    for (Symbol* symbol = base[name_symbol -> index % hash_size];
symbol.h:         symbol; symbol = symbol -> next)
symbol.h:        if (name_symbol == symbol -> Identity() && symbol -> PackageCast())
symbol.h:  return table ? table -> FindPackageSymbol(name_symbol)
symbol.h:    return Table() -> InsertAnonymousTypeSymbol(name_symbol);
symbol.h:    return Table() -> InsertTypeSymbol(name_symbol);
symbol.h:    return Table() -> InsertTypeSymbol(name_symbol);
symbol.h:    return Table() -> InsertTypeSymbol(name_symbol);
symbol.h:    unsigned k = type -> name_symbol -> index % hash_size;
symbol.h:        base[k] = type -> next;
symbol.h:        for (Symbol* symbol = previous -> next;
symbol.h:             symbol != type; previous = symbol, symbol = symbol -> next)
symbol.h:        previous -> next = type -> next;
symbol.h:    unsigned last_index = NumTypeSymbols() - 1;
symbol.h:    if (type -> pool_index != last_index)
symbol.h:        TypeSym(last_index) -> pool_index = type -> pool_index;
symbol.h:        TypeSym(type -> pool_index) = TypeSym(last_index);
symbol.h:    type_symbol_pool -> Reset(last_index); // remove last slot in symbol_pool
symbol.h:        table -> DeleteTypeSymbol(type);
symbol.h:        symbol -> UnlinkFromParents();
symbol.h:        table -> DeleteAnonymousTypes();
symbol.h:    for (Symbol* symbol = base[name_symbol -> index % hash_size];
symbol.h:         symbol; symbol = symbol -> next)
symbol.h:        if (name_symbol == symbol -> Identity() && symbol -> TypeCast())
symbol.h:    return table ? table -> FindTypeSymbol(name_symbol)
symbol.h:    return table ? table -> FindTypeSymbol(name_symbol)
symbol.h:    const NameSymbol* name_symbol = symbol -> Identity();
symbol.h:    for (candidate = base[name_symbol -> index % hash_size];
symbol.h:         candidate; candidate = candidate -> next)
symbol.h:        if (name_symbol == candidate -> Identity() &&
symbol.h:            candidate -> MethodCast())
symbol.h:        symbol -> next = symbol; // mark method as overloaded
symbol.h:        symbol -> next_method = base_method -> next_method;
symbol.h:        base_method -> next_method = symbol;
symbol.h:    return Table() -> InsertMethodSymbol(new MethodSymbol(name_symbol));
symbol.h:    Table() -> InsertMethodSymbol(method_symbol);
symbol.h:    for (Symbol* symbol = base[name_symbol -> index % hash_size];
symbol.h:         symbol; symbol = symbol -> next)
symbol.h:        if (name_symbol == symbol -> Identity() && symbol -> MethodCast())
symbol.h:    return table ? table -> FindMethodSymbol(name_symbol)
symbol.h:    return table ? table -> FindOverloadMethod(base_method, method_declarator)
symbol.h:    return Table() -> InsertVariableSymbol(name_symbol);
symbol.h:    return Table() -> InsertVariableSymbol(name_symbol);
symbol.h:    Table() -> InsertVariableSymbol(variable_symbol);
symbol.h:    Table() -> InsertVariableSymbol(variable_symbol);
symbol.h:    for (Symbol* symbol = base[name_symbol -> index % hash_size];
symbol.h:         symbol; symbol = symbol -> next)
symbol.h:        if (name_symbol == symbol -> Identity() && symbol -> VariableCast())
symbol.h:    return table ? table -> FindVariableSymbol(name_symbol)
symbol.h:    return table ? table -> FindVariableSymbol(name_symbol)
symbol.h:    for (Symbol* symbol = base[name_symbol -> index % hash_size];
symbol.h:         symbol; symbol = symbol -> next)
symbol.h:        if (name_symbol == symbol -> Identity() && symbol -> LabelCast())
symbol.h:    return Table() -> InsertBlockSymbol(hash_size);
Binary file symbol.o matches
system.cpp:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $
system.cpp:// non-ASCII systems (where 'a' != U_a), it is slightly inefficient. Hence it
system.cpp:        case '-': wname[i] = U_MI; break;
system.cpp:    if (! name_symbol -> Utf8_literal)
system.cpp:        name_symbol -> Utf8_literal =
system.cpp:            ConvertUnicodeToUtf8(name_symbol -> Name());
system.cpp:    return ptr - target;
system.cpp:    if (package -> directory.Length() == 0)
system.cpp:        PackageSymbol* owner_package = package -> owner;
system.cpp:            for (unsigned i = 0; i < owner_package -> directory.Length(); i++)
system.cpp:                    owner_package -> directory[i];
system.cpp:                    owner_directory_symbol -> FindDirectorySymbol(package -> Identity());
system.cpp:                if (! owner_directory_symbol -> IsZip())
system.cpp:                            owner_directory_symbol -> DirectoryNameLength() +
system.cpp:                            package -> Utf8NameLength() + 1; // +1 for '/'
system.cpp:                               owner_directory_symbol -> DirectoryName());
system.cpp:                        if (owner_directory_symbol -> DirectoryName()[owner_directory_symbol -> DirectoryNameLength() - 1] != U_SLASH)
system.cpp:                        strcat(directory_name, package -> Utf8Name());
system.cpp:                            subdirectory_symbol = owner_directory_symbol ->
system.cpp:                                InsertDirectorySymbol(package -> Identity(),
system.cpp:                                                      owner_directory_symbol -> IsSourceDirectory());
system.cpp:                        subdirectory_symbol -> ReadDirectory();
system.cpp:                    package -> directory.Next() = subdirectory_symbol;
system.cpp:                    path_symbol -> RootDirectory() -> FindDirectorySymbol(package -> Identity());
system.cpp:                if (! path_symbol -> IsZip())
system.cpp:                        int length = path_symbol -> Utf8NameLength() +
system.cpp:                            package -> Utf8NameLength() + 1; // +1 for '/'
system.cpp:                        strcpy(directory_name, path_symbol -> Utf8Name());
system.cpp:                        char tail = path_symbol -> Utf8Name()[path_symbol -> Utf8NameLength() - 1];
system.cpp:                        strcat(directory_name, package -> Utf8Name());
system.cpp:                            directory_symbol = path_symbol -> RootDirectory() ->
system.cpp:                                InsertDirectorySymbol(package -> Identity(),
system.cpp:                                                      path_symbol -> RootDirectory() -> IsSourceDirectory());
system.cpp:                        directory_symbol -> ReadDirectory();
system.cpp:                    package -> directory.Next() = directory_symbol;
system.cpp:    // VM names to include non-Java identifiers.
system.cpp:                               ? "access$" : "-");
system.cpp:    package_info_name_symbol = FindOrInsertSystemName("package-info");
system.cpp:                               ? "val$" : "-");
system.cpp:    no_type = unnamed_package -> InsertSystemTypeSymbol(question_name_symbol);
system.cpp:    no_type -> SetSignature(dot_name_symbol -> Utf8_literal);
system.cpp:    no_type -> outermost_type = no_type;
system.cpp:    no_type -> SetOwner(unnamed_package);
system.cpp:    no_type -> subtypes = new SymbolSet();
system.cpp:    no_type -> MarkBad();
system.cpp:    null_type = unnamed_package -> InsertSystemTypeSymbol(null_name_symbol);
system.cpp:    null_type -> outermost_type = null_type;
system.cpp:    null_type -> SetOwner(unnamed_package);
system.cpp:    null_type -> SetACC_PUBLIC();
system.cpp:    default_directory -> ReadDirectory();
system.cpp:    if (SystemStat(dot_name_symbol -> Utf8Name(), &status) == 0 &&
system.cpp:        system_table -> InsertDirectorySymbol(status.st_dev, status.st_ino,
system.cpp:    default_directory -> ReadDirectory();
system.cpp:        unnamed_package -> directory.Next() = classpath[0] -> RootDirectory();
system.cpp:            int input_name_length = path - head;
system.cpp:                        unnamed_package -> directory.Next() =
system.cpp:                            classpath[0] -> RootDirectory();
system.cpp:                    unnamed_package -> directory.Next() = dot_directory;
system.cpp:                    if (! zipinfo -> IsValid())
system.cpp:                            wchar_t* tail = &name[input_name_length - 3];
system.cpp:                    unnamed_package -> directory.Next() =
system.cpp:                        zipinfo -> RootDirectory();
system.cpp:                                                         zipinfo -> RootDirectory());
system.cpp:                    path_symbol -> zipfile = zipinfo;
system.cpp:            int input_name_length = path - head;
system.cpp:                            int entry_length = strlen(entry -> d_name);
system.cpp:                            char* ending = &(entry->d_name[entry_length-3]);
system.cpp:                            // skip ., .., non-zip, and non-jar
system.cpp:                            if (! strcmp(entry -> d_name, ".") ||
system.cpp:                                ! strcmp(entry -> d_name, "..") ||
system.cpp:                            if (head[input_name_length - 1] != U_SLASH)
system.cpp:                            strcat(extdir_entry, entry -> d_name);
system.cpp:                            if (! zipinfo -> IsValid())
system.cpp:                            unnamed_package->directory.Next() =
system.cpp:                                zipinfo -> RootDirectory();
system.cpp:                                                                 zipinfo -> RootDirectory());
system.cpp:                            path_symbol -> zipfile = zipinfo;
system.cpp:                    if (directory_name[input_name_length - 1] != U_SLASH)
system.cpp:                            char* ending = &(entry.cFileName[entry_length-3]);
system.cpp:                            if (head[input_name_length - 1] != U_SLASH)
system.cpp:                            if (! zipinfo -> IsValid())
system.cpp:                            unnamed_package -> directory.Next() =
system.cpp:                                zipinfo -> RootDirectory();
system.cpp:                                                                 zipinfo -> RootDirectory());
system.cpp:                            path_symbol -> zipfile = zipinfo;
system.cpp:            int input_name_length = path - head;
system.cpp:                        unnamed_package -> directory.Next() =
system.cpp:                            classpath[0] -> RootDirectory();
system.cpp:                    unnamed_package -> directory.Next() = dot_directory;
system.cpp:                    if (! zipinfo -> IsValid())
system.cpp:                            wchar_t* tail = &name[input_name_length - 3];
system.cpp:                    unnamed_package -> directory.Next() =
system.cpp:                        zipinfo -> RootDirectory();
system.cpp:                                                         zipinfo -> RootDirectory());
system.cpp:                    path_symbol -> zipfile = zipinfo;
system.cpp:            int input_name_length = path - head;
system.cpp:                        unnamed_package -> directory.Next() =
system.cpp:                            classpath[0] -> RootDirectory();
system.cpp:                    unnamed_package -> directory.Next() = dot_directory;
system.cpp:    TypeSymbol* type = unnamed_package -> InsertSystemTypeSymbol(name_symbol);
system.cpp:    type -> SetSignature(Utf8_pool.FindOrInsert(sig, 1));
system.cpp:    type -> outermost_type = type;
system.cpp:    type -> SetOwner(unnamed_package);
system.cpp:    type -> SetACC_PUBLIC();
system.cpp:    type -> MarkPrimitive();
system.cpp:    TypeSymbol* type = package -> FindTypeSymbol(name_symbol);
system.cpp:        type = system_semantic -> ReadType(file_symbol, package,
system.cpp:    else if (type -> SourcePending())
system.cpp:        ProcessHeaders(type -> file_symbol);
system.cpp:    if (! type -> Bad())
system.cpp:        for (method = type -> FindMethodSymbol(name_symbol);
system.cpp:             method; method = method -> next_method)
system.cpp:            if (! strcmp(descriptor, method -> SignatureString()))
system.cpp:        if (! type -> Bad())
system.cpp:            system_semantic ->
system.cpp:                               BAD_TOKEN, type -> ContainingPackageName(),
system.cpp:                               type -> ExternalName());
system.cpp:        method = type -> InsertMethodSymbol(name_symbol);
system.cpp:        method -> SetType(no_type);
system.cpp:        method -> SetContainingType(type);
system.cpp:        method -> SetSignature(FindOrInsertSystemName(descriptor) ->
system.cpp:    if (! type -> Bad())
system.cpp:        field = type -> FindVariableSymbol(name_symbol);
system.cpp:        if (! field -> IsTyped())
system.cpp:            field -> ProcessVariableSignature(system_semantic, BAD_TOKEN);
system.cpp:        field -> MarkInitialized();
system.cpp:        if (! type -> Bad())
system.cpp:            system_semantic ->
system.cpp:                               BAD_TOKEN, type -> ContainingPackageName(),
system.cpp:                               type -> ExternalName());
system.cpp:        field = type -> InsertVariableSymbol(name_symbol);
system.cpp:        field -> SetType(no_type);
system.cpp:        field -> SetOwner(type);
system.cpp:        field -> MarkInitialized();
system.cpp:            FindOrInsertSystemName(descriptor) -> Utf8_literal;
system.cpp:        field -> SetSignatureString(utf8 -> value, utf8 -> length);
system.cpp:    if (file_symbol -> semantic == NULL ||
system.cpp:        (file_symbol -> semantic -> control).option.directory == NULL) {
system.cpp:        directory_symbol = file_symbol -> directory_symbol;
system.cpp:        Control& control = file_symbol -> semantic -> control;
system.cpp:            file_symbol -> package -> PackageNameLength() * 3;
system.cpp:        if (file_symbol -> package != control.unnamed_package)
system.cpp:            if (directory_prefix[directory_prefix_length - 1] != U_SLASH)
system.cpp:            ConvertUnicodeToUtf8(file_symbol -> package -> PackageName(),
system.cpp:    int length = name_symbol -> Utf8NameLength() +
system.cpp:    strcpy(full_filename, name_symbol -> Utf8Name());
system.cpp:    for (unsigned k = 0; k < package -> directory.Length(); k++)
system.cpp:        directory_symbol = package -> directory[k];
system.cpp:        if ((entry = directory_symbol -> FindEntry(full_filename, length)))
system.cpp:        PathSymbol* path_symbol = directory_symbol -> PathSym();
system.cpp:        file_symbol = directory_symbol -> FindFileSymbol(name_symbol);
system.cpp:        if (! ((file_symbol && file_symbol -> IsJava()) ||
system.cpp:               path_symbol -> IsZip()))
system.cpp:            file_symbol = directory_symbol -> InsertFileSymbol(name_symbol);
system.cpp:            file_symbol -> directory_symbol = directory_symbol;
system.cpp:            file_symbol -> SetJava();
system.cpp:            file_symbol -> mtime = entry -> Mtime();
system.cpp:    int class_length = name_symbol -> Utf8NameLength() +
system.cpp:    int java_length = name_symbol -> Utf8NameLength() +
system.cpp:    strcpy(class_name, name_symbol -> Utf8Name());
system.cpp:    strcpy(java_name, name_symbol -> Utf8Name());
system.cpp:    for (unsigned k = 0; k < package -> directory.Length(); k++)
system.cpp:        DirectorySymbol* directory_symbol = package -> directory[k];
system.cpp:            directory_symbol -> FindFileSymbol(name_symbol);
system.cpp:            PathSymbol* path_symbol = directory_symbol -> PathSym();
system.cpp:            if (! path_symbol -> IsZip())
system.cpp:                    directory_symbol -> FindEntry(java_name, java_length),
system.cpp:                                 (! directory_symbol -> IsSourceDirectory()))
system.cpp:                                ? directory_symbol -> FindEntry(class_name,
system.cpp:                        directory_symbol -> InsertFileSymbol(name_symbol);
system.cpp:                    file_symbol -> directory_symbol = directory_symbol;
system.cpp:                         class_entry -> Mtime() < java_entry -> Mtime()))
system.cpp:                        file_symbol -> SetJava();
system.cpp:                        file_symbol -> mtime = java_entry -> Mtime();
system.cpp:                            file_symbol -> SetClass();
system.cpp:                        else file_symbol -> SetClassOnly();
system.cpp:                        file_symbol -> mtime = class_entry -> Mtime();
system.cpp:            if (file_symbol -> IsJava() && ! java_file_symbol)
system.cpp:         class_file_symbol -> mtime < java_file_symbol -> mtime))
system.cpp:    int class_length = name_symbol -> Utf8NameLength() +
system.cpp:    int java_length = name_symbol -> Utf8NameLength() +
system.cpp:    strcpy(class_name, name_symbol -> Utf8Name());
system.cpp:    strcpy(java_name, name_symbol -> Utf8Name());
system.cpp:    for (unsigned k = 0; k < package -> directory.Length(); k++)
system.cpp:        DirectorySymbol* directory_symbol = package -> directory[k];
system.cpp:        file_symbol = directory_symbol -> FindFileSymbol(name_symbol);
system.cpp:        PathSymbol* path_symbol = directory_symbol -> PathSym();
system.cpp:        if (! path_symbol -> IsZip())
system.cpp:                directory_symbol -> FindEntry(java_name, java_length);
system.cpp:                                           ? directory_symbol -> FindEntry(class_name,
system.cpp:                    directory_symbol -> InsertFileSymbol(name_symbol);
system.cpp:                file_symbol -> directory_symbol = directory_symbol;
system.cpp:                     class_entry -> Mtime() < java_entry -> Mtime()))
system.cpp:                    file_symbol -> SetJava();
system.cpp:                    file_symbol -> mtime = java_entry -> Mtime();
system.cpp:                         file_symbol -> SetClass();
system.cpp:                    else file_symbol -> SetClassOnly();
system.cpp:                    file_symbol -> mtime = class_entry -> Mtime();
Binary file system.o matches
tab.cpp:// and any non-printable ASCII characters in unicode expansion mode.
tab.cpp:    for (int i = start--; i <= end; i++)
tab.cpp:            int offset = (i - start) - 1;
tab.cpp:            start -= ((tab_size - 1) - offset % tab_size);
tab.cpp:            start -= 5;
tab.cpp:    return (end - start);
tab.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
Binary file tab.o matches
table.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
table.h:        return conflict ? conflict -> Length() : 0;
table.h:            conflict -> Next() = conflict_symbol;
table.h:            conflict -> Array();
table.h:        for (unsigned k = 0; k < conflict -> Length(); k++)
table.h:        return conflict ? conflict -> Length() : 0;
table.h:            conflict -> Next() = conflict_symbol;
table.h:            conflict -> Array();
table.h:        for (unsigned k = 0; k < conflict -> Length(); k++)
table.h:        return conflict ? conflict -> Length() : 0;
table.h:            conflict -> Next() = conflict_symbol;
table.h:            conflict -> Array();
table.h:        for (unsigned k = 0; k < conflict -> Length(); k++)
table.h:            array[i] -> CompressSpace();
table.h:                array[i] -> type_symbol -> name_symbol -> index % hash_size;
table.h:            array[i] -> next = base[k];
table.h:        unsigned i = type_symbol -> name_symbol -> index % hash_size;
table.h:        p -> next = base[i];
table.h:        for (p = base[name_symbol -> index % hash_size]; p; p = p -> next)
table.h:             if (p -> type_symbol -> name_symbol == name_symbol)
table.h:            array[i] -> CompressSpace();
table.h:            unsigned k = array[i] -> variable_symbol -> name_symbol -> index %
table.h:            array[i] -> next = base[k];
table.h:        unsigned i = variable_symbol -> name_symbol -> index % hash_size;
table.h:        p -> next = base[i];
table.h:        for (p = base[name_symbol -> index % hash_size]; p; p = p -> next)
table.h:            if (p -> variable_symbol -> name_symbol == name_symbol)
table.h:            array[i] -> CompressSpace();
table.h:                array[i] -> method_symbol -> name_symbol;
table.h:                unsigned k = name_symbol -> index % hash_size;
table.h:                array[i] -> next = base[k];
table.h:                array[i] -> next_method = NULL;
table.h:                array[i] -> next_method = base_shadow -> next_method;
table.h:                base_shadow -> next_method = array[i];
table.h:        for (p = base[name_symbol -> index % hash_size]; p; p = p -> next)
table.h:            if (p -> method_symbol -> name_symbol == name_symbol)
table.h:        unsigned i = method_symbol -> name_symbol -> index % hash_size;
table.h:        p -> next_method = NULL;
table.h:        p -> next = base[i];
table.h:        shadow -> next_method = base_shadow -> next_method;
table.h:        base_shadow -> next_method = shadow;
table.h:            FindMethodShadowSymbol(overload_method -> name_symbol);
table.h:        return base_shadow -> next_method;
table.h:        if (! overload_method -> IsTyped())
table.h:            overload_method -> ProcessMethodSignature(sem, tok);
table.h:        for (method_shadow = FindMethodShadowSymbol(overload_method ->
table.h:             method_shadow = method_shadow -> next_method)
table.h:            MethodSymbol* method = method_shadow -> method_symbol;
table.h:            if (! method -> IsTyped())
table.h:                method -> ProcessMethodSignature(sem, tok);
table.h:            if (overload_method -> NumFormalParameters() ==
table.h:                method -> NumFormalParameters())
table.h:                for (i = method -> NumFormalParameters() - 1; i >= 0; i--)
table.h:                    if (method -> FormalParameter(i) -> Type() !=
table.h:                        overload_method -> FormalParameter(i) -> Type())
tuple.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
tuple.h:                   (base_size - old_base_size) * sizeof(T*));
tuple.h:        base[k] = (new T[Blksize()]) - size;
tuple.h:    // I.e., that the array will be indexable in the range (0..n-1).
tuple.h:            // will contain the (n-1)th element.
tuple.h:            int slot = (n == 0 ? -1 : (n - 1) >> log_blksize);
tuple.h:            for (int k = (size >> log_blksize) - 1; k > slot; k--)
tuple.h:                size -= Blksize();
tuple.h:        // See the comments above. We purposefully pre-adjusted the pointers
tuple.h:        // base[i >> log_blocksize][i & ~(-1 << log_blocksize)].
tuple.h:    inline void Push(const T& elt) { this -> Next() = elt; }
tuple.h:        // Not "return (*this)[--top]" because that may violate an invariant
tuple.h:        top--;
tuple.h:        return (*this)[top - 1];
tuple.h:        return (*this)[top - 1];
tuple.h:                base_increment = 1U << (log_blksize - 4);
tuple.h:                base_increment = 1U << (log_blksize - 8);
tuple.h:            (const_cast<ConvertibleArray<T>*> (this)) -> Compact();
tuple.h:            ((ConvertibleArray<T>*) this) -> Compact();
tuple.h:        // problems with 0-length arrays.
tuple.h:        // the last non-empty slot!
tuple.h:        unsigned n = (Tuple<T>::top - 1) >> Tuple<T>::log_blksize;
tuple.h:               (Tuple<T>::top - processed_size) * sizeof(T));
tuple.h:        while (--n >= 0)
tuple.h:            JikesAPI::getInstance() -> write(file_name, buffer.top);
tuple.h:        // the last non-empty slot!
tuple.h:        unsigned n = (buffer.top - 1) >> buffer.log_blksize;
tuple.h:            file -> write(buffer.base[i] + size, buffer.Blksize());
tuple.h:        file -> write(buffer.base[n] + size, buffer.top - size);
unparse.cpp:// Special top-level form
unparse.cpp:    char* in_file_name = lex_stream -> FileName();
unparse.cpp:        os << lex_stream -> NameString(label_opt) << ": ";
unparse.cpp:        Statement(i) -> Unparse(os, lex_stream);
unparse.cpp:        base_opt -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(identifier_token);
unparse.cpp:    os << lex_stream -> NameString(primitive_kind_token);
unparse.cpp:    type -> Unparse(os, lex_stream);
unparse.cpp:    brackets -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(question_token);
unparse.cpp:        os << ' ' << lex_stream -> NameString(extends_token_opt) << ' ';
unparse.cpp:        bounds_opt -> Unparse(os, lex_stream);
unparse.cpp:        os << ' ' << lex_stream -> NameString(super_token_opt) << ' ';
unparse.cpp:        bounds_opt -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(left_angle_token);
unparse.cpp:        TypeArgument(0) -> Unparse(os, lex_stream);
unparse.cpp:        TypeArgument(i) -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(right_angle_token);
unparse.cpp:        base_opt -> Unparse(os, lex_stream);
unparse.cpp:    name -> Unparse(os, lex_stream);
unparse.cpp:        type_arguments_opt -> Unparse(os, lex_stream);
unparse.cpp:        os << lex_stream -> NameString(identifier_token_opt) << " = ";
unparse.cpp:    member_value -> Unparse(os, lex_stream);
unparse.cpp:    name -> Unparse(os, lex_stream);
unparse.cpp:        MemberValuePair(0) -> Unparse(os, lex_stream);
unparse.cpp:        MemberValuePair(i) -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(modifier_token);
unparse.cpp:        Modifier(i) -> Unparse(os, lex_stream);
unparse.cpp:        if (Modifier(i) -> ModifierKeywordCast())
unparse.cpp:    if (lex_stream -> IsDeprecated(LeftToken()))
unparse.cpp:        modifiers_opt -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(package_token) << ' ';
unparse.cpp:    name -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(import_token) << ' ';
unparse.cpp:        os << lex_stream -> NameString(static_token_opt) << ' ';
unparse.cpp:    name -> Unparse(os, lex_stream);
unparse.cpp:        os << '.' << lex_stream -> NameString(star_token_opt);
unparse.cpp:    os << "// " << lex_stream -> FileName() << endl;
unparse.cpp:        package_declaration_opt -> Unparse(os, lex_stream);
unparse.cpp:        ImportDeclaration(i) -> Unparse(os, lex_stream);
unparse.cpp:        TypeDeclaration(i) -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(semicolon_token) << endl;
unparse.cpp:        ClassBodyDeclaration(i) -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(identifier_token);
unparse.cpp:        Bound(0) -> Unparse(os, lex_stream);
unparse.cpp:        Bound(i) -> Unparse(os, lex_stream);
unparse.cpp:    TypeParameter(0) -> Unparse(os, lex_stream);
unparse.cpp:        TypeParameter(i) -> Unparse(os, lex_stream);
unparse.cpp:    if (lex_stream -> IsDeprecated(LeftToken()))
unparse.cpp:        modifiers_opt -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(class_token) << ' '
unparse.cpp:       << lex_stream -> NameString(class_body -> identifier_token) << ' ';
unparse.cpp:        type_parameters_opt -> Unparse(os, lex_stream);
unparse.cpp:        super_opt -> Unparse(os, lex_stream);
unparse.cpp:        Interface(0) -> Unparse(os, lex_stream);
unparse.cpp:            Interface(i) -> Unparse(os, lex_stream);
unparse.cpp:    class_body -> Unparse(os, lex_stream);
unparse.cpp:        VariableInitializer(0) -> Unparse(os, lex_stream);
unparse.cpp:        VariableInitializer(i) -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(identifier_token);
unparse.cpp:        brackets_opt -> Unparse(os, lex_stream);
unparse.cpp:    variable_declarator_name -> Unparse(os, lex_stream);
unparse.cpp:        variable_initializer_opt -> Unparse(os, lex_stream);
unparse.cpp:    if (lex_stream -> IsDeprecated(LeftToken()))
unparse.cpp:        modifiers_opt -> Unparse(os, lex_stream);
unparse.cpp:    type -> Unparse(os, lex_stream);
unparse.cpp:    VariableDeclarator(0) -> Unparse(os, lex_stream);
unparse.cpp:        VariableDeclarator(i) -> Unparse(os, lex_stream);
unparse.cpp:        modifiers_opt -> Unparse(os, lex_stream);
unparse.cpp:    type -> Unparse(os, lex_stream);
unparse.cpp:    formal_declarator -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(identifier_token) << '(';
unparse.cpp:        FormalParameter(0) -> Unparse(os, lex_stream);
unparse.cpp:        FormalParameter(i) -> Unparse(os, lex_stream);
unparse.cpp:        brackets_opt -> Unparse(os, lex_stream);
unparse.cpp:        explicit_constructor_opt -> Unparse(os, lex_stream);
unparse.cpp:    if (lex_stream -> IsDeprecated(LeftToken()))
unparse.cpp:        modifiers_opt -> Unparse(os, lex_stream);
unparse.cpp:        type_parameters_opt -> Unparse(os, lex_stream);
unparse.cpp:    type -> Unparse(os, lex_stream);
unparse.cpp:    method_declarator -> Unparse(os, lex_stream);
unparse.cpp:        Throw(0) -> Unparse(os, lex_stream);
unparse.cpp:            Throw(i) -> Unparse(os, lex_stream);
unparse.cpp:        default_value_opt -> Unparse(os, lex_stream);
unparse.cpp:        method_body_opt -> Unparse(os, lex_stream);
unparse.cpp:        modifiers_opt -> Unparse(os, lex_stream);
unparse.cpp:    block -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(left_parenthesis_token);
unparse.cpp:        Argument(0) -> Unparse(os, lex_stream);
unparse.cpp:        Argument(i) -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(right_parenthesis_token);
unparse.cpp:        type_arguments_opt -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(this_token);
unparse.cpp:    arguments -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(semicolon_token) << endl;
unparse.cpp:        if (base_opt && ! base_opt -> generated)
unparse.cpp:            base_opt -> Unparse(os, lex_stream);
unparse.cpp:            type_arguments_opt -> Unparse(os, lex_stream);
unparse.cpp:        os << lex_stream -> NameString(super_token);
unparse.cpp:        arguments -> Unparse(os, lex_stream);
unparse.cpp:        os << lex_stream -> NameString(semicolon_token) << endl;
unparse.cpp:    if (lex_stream -> IsDeprecated(LeftToken()))
unparse.cpp:        modifiers_opt -> Unparse(os, lex_stream);
unparse.cpp:        type_parameters_opt -> Unparse(os, lex_stream);
unparse.cpp:    constructor_declarator -> Unparse(os, lex_stream);
unparse.cpp:        Throw(0) -> Unparse(os, lex_stream);
unparse.cpp:            Throw(i) -> Unparse(os, lex_stream);
unparse.cpp:    constructor_body -> Unparse(os, lex_stream);
unparse.cpp:    if (lex_stream -> IsDeprecated(LeftToken()))
unparse.cpp:        modifiers_opt -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(enum_token) << ' '
unparse.cpp:       << lex_stream -> NameString(class_body -> identifier_token) << ' ';
unparse.cpp:        Interface(0) -> Unparse(os, lex_stream);
unparse.cpp:            Interface(i) -> Unparse(os, lex_stream);
unparse.cpp:        EnumConstant(i) -> Unparse(os, lex_stream);
unparse.cpp:    class_body -> Unparse(os, lex_stream, true);
unparse.cpp:    if (lex_stream -> IsDeprecated(LeftToken()))
unparse.cpp:        modifiers_opt -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(identifier_token);
unparse.cpp:        arguments_opt -> Unparse(os, lex_stream);
unparse.cpp:        class_body_opt -> Unparse(os, lex_stream);
unparse.cpp:    if (lex_stream -> IsDeprecated(LeftToken()))
unparse.cpp:        modifiers_opt -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(interface_token) << ' '
unparse.cpp:       << lex_stream -> NameString(class_body -> identifier_token) << ' ';
unparse.cpp:        type_parameters_opt -> Unparse(os, lex_stream);
unparse.cpp:        Interface(0) -> Unparse(os, lex_stream);
unparse.cpp:            Interface(i) -> Unparse(os, lex_stream);
unparse.cpp:    class_body -> Unparse(os, lex_stream);
unparse.cpp:    if (lex_stream -> IsDeprecated(LeftToken()))
unparse.cpp:        modifiers_opt -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(interface_token - 1)
unparse.cpp:       << lex_stream -> NameString(interface_token) << ' '
unparse.cpp:       << lex_stream -> NameString(class_body -> identifier_token) << ' ';
unparse.cpp:    class_body -> Unparse(os, lex_stream);
unparse.cpp:        modifiers_opt -> Unparse(os, lex_stream);
unparse.cpp:    type -> Unparse(os, lex_stream);
unparse.cpp:    VariableDeclarator(0) -> Unparse(os, lex_stream);
unparse.cpp:        VariableDeclarator(i) -> Unparse(os, lex_stream);
unparse.cpp:    declaration -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(if_token) << '(';
unparse.cpp:    expression -> Unparse(os, lex_stream);
unparse.cpp:    true_statement -> Unparse(os, lex_stream);
unparse.cpp:        false_statement_opt -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(semicolon_token) << endl;
unparse.cpp:    expression -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(case_token) << ' ';
unparse.cpp:        expression_opt -> Unparse(os, lex_stream);
unparse.cpp:        SwitchLabel(i) -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(switch_token) << '(';
unparse.cpp:    expression -> Unparse(os, lex_stream);
unparse.cpp:    switch_block -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(while_token) << " (";
unparse.cpp:    expression -> Unparse(os, lex_stream);
unparse.cpp:    statement -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(do_token) << endl;
unparse.cpp:    statement -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(while_token) << " (";
unparse.cpp:    expression -> Unparse(os, lex_stream);
unparse.cpp:    os << ')' << lex_stream -> NameString(semicolon_token) << endl;
unparse.cpp:    os << lex_stream -> NameString(for_token) << " (";
unparse.cpp:        ForInitStatement(0) -> Unparse(os, lex_stream);
unparse.cpp:        ForInitStatement(i) -> Unparse(os, lex_stream);
unparse.cpp:        end_expression_opt -> Unparse(os, lex_stream);
unparse.cpp:        ForUpdateStatement(0) -> Unparse(os, lex_stream);
unparse.cpp:        ForUpdateStatement(i) -> Unparse(os, lex_stream);
unparse.cpp:    statement -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(for_token) << " (";
unparse.cpp:    formal_parameter -> Unparse(os, lex_stream);
unparse.cpp:    expression -> Unparse(os, lex_stream);
unparse.cpp:    statement -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(break_token);
unparse.cpp:        os << ' ' << lex_stream -> NameString(identifier_token_opt);
unparse.cpp:    os << lex_stream -> NameString(continue_token);
unparse.cpp:        os << ' ' << lex_stream -> NameString(identifier_token_opt);
unparse.cpp:        os << lex_stream -> NameString(return_token);
unparse.cpp:            expression_opt -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(throw_token) << ' ';
unparse.cpp:    expression -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(synchronized_token) << " (";
unparse.cpp:    expression -> Unparse(os, lex_stream);
unparse.cpp:    block -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(assert_token) << ' ';
unparse.cpp:    condition -> Unparse(os, lex_stream);
unparse.cpp:        message_opt -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(catch_token) << " (";
unparse.cpp:    formal_parameter -> Unparse(os, lex_stream);
unparse.cpp:    block -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(finally_token) << endl;
unparse.cpp:    block -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(try_token) << endl;
unparse.cpp:    block -> Unparse(os, lex_stream);
unparse.cpp:        CatchClause(i) -> Unparse(os, lex_stream);
unparse.cpp:        finally_clause_opt -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(integer_literal_token);
unparse.cpp:    os << lex_stream -> NameString(long_literal_token);
unparse.cpp:    os << lex_stream -> NameString(float_literal_token);
unparse.cpp:    os << lex_stream -> NameString(double_literal_token);
unparse.cpp:    os << lex_stream -> NameString(true_literal_token);
unparse.cpp:    os << lex_stream -> NameString(false_literal_token);
unparse.cpp:    os << lex_stream -> NameString(string_literal_token);
unparse.cpp:    os << lex_stream -> NameString(character_literal_token);
unparse.cpp:    os << lex_stream -> NameString(null_token);
unparse.cpp:    type -> Unparse(os, lex_stream);
unparse.cpp:    os << '.' << lex_stream -> NameString(class_token);
unparse.cpp:        base_opt -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(this_token);
unparse.cpp:        base_opt -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(super_token);
unparse.cpp:    os << lex_stream -> NameString(left_parenthesis_token);
unparse.cpp:    expression -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(right_parenthesis_token);
unparse.cpp:    if (base_opt && ! base_opt -> generated)
unparse.cpp:        base_opt -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(new_token) << ' ';
unparse.cpp:        type_arguments_opt -> Unparse(os, lex_stream);
unparse.cpp:    class_type -> Unparse(os, lex_stream);
unparse.cpp:    arguments -> Unparse(os, lex_stream);
unparse.cpp:        class_body_opt -> Unparse(os, lex_stream);
unparse.cpp:    expression -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(new_token) << ' ';
unparse.cpp:    array_type -> Unparse(os, lex_stream);
unparse.cpp:        DimExpr(i) -> Unparse(os, lex_stream);
unparse.cpp:        brackets_opt -> Unparse(os, lex_stream);
unparse.cpp:        array_initializer_opt -> Unparse(os, lex_stream);
unparse.cpp:    base -> Unparse(os, lex_stream);
unparse.cpp:    os << '.' << lex_stream -> NameString(identifier_token);
unparse.cpp:    if (base_opt && ! base_opt -> generated)
unparse.cpp:        base_opt -> Unparse(os, lex_stream);
unparse.cpp:        type_arguments_opt -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(identifier_token);
unparse.cpp:    arguments -> Unparse(os, lex_stream);
unparse.cpp:    base -> Unparse(os, lex_stream);
unparse.cpp:    expression -> Unparse(os, lex_stream);
unparse.cpp:    expression -> Unparse(os, lex_stream);
unparse.cpp:    os << lex_stream -> NameString(post_operator_token);
unparse.cpp:    os << lex_stream -> NameString(pre_operator_token);
unparse.cpp:    expression -> Unparse(os, lex_stream);
unparse.cpp:        type -> Unparse(os, lex_stream);
unparse.cpp:    expression -> Unparse(os, lex_stream);
unparse.cpp:    left_expression -> Unparse(os, lex_stream);
unparse.cpp:    os << ' ' << lex_stream -> NameString(binary_operator_token) << ' ';
unparse.cpp:    right_expression -> Unparse(os, lex_stream);
unparse.cpp:    expression -> Unparse(os, lex_stream);
unparse.cpp:    os << ' ' << lex_stream -> NameString(instanceof_token) << ' ';
unparse.cpp:    type -> Unparse(os, lex_stream);
unparse.cpp:    test_expression -> Unparse(os, lex_stream);
unparse.cpp:    true_expression -> Unparse(os, lex_stream);
unparse.cpp:    false_expression -> Unparse(os, lex_stream);
unparse.cpp:    left_hand_side -> Unparse(os, lex_stream);
unparse.cpp:    os << ' ' << lex_stream -> NameString(assignment_operator_token) << ' ';
unparse.cpp:    expression -> Unparse(os, lex_stream);
Binary file unparse.o matches
unzip.cpp:// NOTE: Jikes incorporates compression code from the Info-ZIP
unzip.cpp:// files unzip.h and unzip.cpp, which are based on Info-ZIP's inflate.c and
unzip.cpp:// M. Adler, G. Roelofs, J-l. Failly, J. Bush, C. Ghisler, A. Verheijen,
unzip.cpp:// ----  ---------  --------------  ------------------------------------
unzip.cpp://  a    ~~ Feb 92  M. Adler        used full (large, one-step) lookup table
unzip.cpp:/*unsigned s              number of simple-valued codes (0..s-1) */
unzip.cpp:/* unsigned short *d                  list of base values for non-simple codes */
unzip.cpp:/*ush *e                  list of extra bits for non-simple codes */
unzip.cpp:  int lx[BMAX+1];               /* memory for l[-1..BMAX-1] */
unzip.cpp:  } while (--i);
unzip.cpp:  if (c[0] == n)                /* null input--all zero length codes */
unzip.cpp:  for (i = BMAX; i; i--)
unzip.cpp:    if ((y -= c[j]) < 0)
unzip.cpp:  if ((y -= c[i]) < 0)
unzip.cpp:  while (--i) {                 /* note that i == g from above */
unzip.cpp:  h = -1;                       /* no tables yet--level -1 */
unzip.cpp:  w = l[-1] = 0;                /* no bits decoded yet */
unzip.cpp:    while (a--)
unzip.cpp:        z = (z = g - w) > (unsigned)*m ? *m : z;        /* upper limit */
unzip.cpp:        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
unzip.cpp:        {                       /* too few codes for k-w bit table */
unzip.cpp:          f -= a + 1;           /* deduct codes from patterns left */
unzip.cpp:            f -= *xp;           /* else deduct codes from patterns */
unzip.cpp:          j = el - w;           /* make EOB code end at table */
unzip.cpp:        z = 1 << j;             /* table entries for j-bit table */
unzip.cpp:        *(t = &(q->v.t)) = (struct huft *)0;
unzip.cpp:          r.b = (unsigned char)l[h-1];    /* bits to dump before this table */
unzip.cpp:          j = (i & ((1 << w) - 1)) >> (w - l[h-1]);
unzip.cpp:          u[h-1][j] = r;        /* connect to last table */
unzip.cpp:      r.b = (unsigned char)(k - w);
unzip.cpp:        r.e = 99;               /* out of values--invalid code */
unzip.cpp:        r.e = (unsigned char)(*p < 256 ? 16 : 15);  /* 256 is end-of-block code */
unzip.cpp:        r.e = (unsigned char)e[*p - s];   /* non-simple--look up in lists */
unzip.cpp:        r.v.n = d[*p++ - s];
unzip.cpp:      /* fill code-like entries with r */
unzip.cpp:      f = 1 << (k - w);
unzip.cpp:      /* backwards increment the k-bit code i */
unzip.cpp:      for (j = 1 << (k - 1); i & j; j >>= 1)
unzip.cpp:      while ((i & ((1 << w) - 1)) != x[h])
unzip.cpp:        w -= l[--h];            /* don't need to update q */
unzip.cpp:  /* Go through linked list, freeing from the malloced (t[-1]) address. */
unzip.cpp:    q = (--p)->v.t;
unzip.cpp:    if ((e = (t = tl + ((unsigned)b & ml))->e) > 16)
unzip.cpp:        DUMPBITS(t->b)
unzip.cpp:        e -= 16;
unzip.cpp:      } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);
unzip.cpp:    DUMPBITS(t->b)
unzip.cpp:      slide_buffer[w++] = (unsigned char)t->v.n;
unzip.cpp:      n = t->v.n + ((unsigned)b & mask_bits[e]);
unzip.cpp:      if ((e = (t = td + ((unsigned)b & md))->e) > 16)
unzip.cpp:          DUMPBITS(t->b)
unzip.cpp:          e -= 16;
unzip.cpp:        } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);
unzip.cpp:      DUMPBITS(t->b)
unzip.cpp:      d = w - t->v.n - ((unsigned)b & mask_bits[e]);
unzip.cpp:          n -= (e = (e = wsize - ((d &= wsize-1) > w ? d : w)) > n ? n : e);
unzip.cpp:        if (w - d >= e)         /* (this test assumes unsigned comparison) */
unzip.cpp:          } while (--e);
unzip.cpp:  while (n--)
unzip.cpp:  /* decompress until an end-of-block code */
unzip.cpp:  /* read in bit-length-code lengths */
unzip.cpp:  /* build decoding table for trees--single level, 7 bit lookup */
unzip.cpp:    j = (td = tl + ((unsigned)b & m))->b;
unzip.cpp:    j = td->v.n;
unzip.cpp:      while (j--)
unzip.cpp:      while (j--)
unzip.cpp:      while (j--)
unzip.cpp:      MESSAGE((unsigned char *)"(incomplete l-tree)  ", 21L, 1);
unzip.cpp:    MESSAGE((unsigned char *)"(incomplete d-tree)  ", 21L, 1);
unzip.cpp:      MESSAGE((unsigned char *)"(incomplete d-tree)  ", 21L, 1);
unzip.cpp:  /* decompress until an end-of-block code */
unzip.h:// NOTE: Jikes incorporates compression code from the Info-ZIP
unzip.h:// files unzip.h and unzip.cpp, which are based on Info-ZIP's inflate.c and
unzip.h:// M. Adler, G. Roelofs, J-l. Failly, J. Bush, C. Ghisler, A. Verheijen,
unzip.h:// ----  ---------  --------------  ------------------------------------
unzip.h://  a    ~~ Feb 92  M. Adler        used full (large, one-step) lookup table
unzip.h:// inflate.c -- put in the public domain by Mark Adler
unzip.h:// the end of each deflated block is a special end-of-block (EOB) literal/
unzip.h:// length then get the distance and emit the referred-to bytes from the
unzip.h:// which method to use on a chunk-by-chunk basis.  A chunk might typically
unzip.h:// can code it much better than the pre-determined fixed codes can.
unzip.h:// The Huffman codes themselves are decoded using a multi-level table
unzip.h:// 5. There is no way of sending zero distance codes--a dummy must be
unzip.h://    end-of-block.  Note however that the static length tree defines
unzip.h://11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
unzip.h://12. Note: length code 284 can represent 227-258, but length code 285
unzip.h://    258 is special since 258 - 3 (the min match length) is 255.
unzip.h:#define PKZIP_BUG_WORKAROUND    /* PKZIP 1.93a problem--live with it */
unzip.h:#  define WSIZE 0x8000  /* window size--must be a power of two, and at least */
unzip.h:#ifndef MESSAGE   /* only used twice, for fixed strings--NOT general-purpose */
unzip.h:/* Warning: the fwrite above might not work on 16-bit compilers, since
unzip.h:   0x8000 might be interpreted as -32768 by the library function. */
unzip.h:/*---------------------------------------------------------------------------*/
unzip.h:// enough bits to make up the end-of-block code (value 256).  Then no
unzip.h:#define DUMPBITS(n) {b>>=(n);k-=(n);}
unzip.h:// Huffman code lookup table entry--this entry is four bytes for machines
unzip.h:// that have 16-bit pointers (e.g. PC's in the small or medium model).
unzip.h:// the next table, which codes e - 16 bits, and lastly e == 99 indicates
unzip.h:// and'ing with 0x7fff (32K-1). */
unzip.h:    // Huffman code decoding is performed using a multi-level table lookup.
Binary file unzip.o matches
zip.cpp:    Zip *zip = file_symbol -> Zipfile();
zip.cpp:    assert(zip -> IsValid());
zip.cpp:    zipfile = zip -> zipfile;
zip.cpp:    int rc = fseek(zipfile, file_symbol -> offset, SEEK_SET);
zip.cpp:    file_buffer = &zip -> zipbuffer[file_symbol -> offset];
zip.cpp:    this -> buffer = new char[file_symbol -> uncompressed_size];
zip.cpp:    if (! uncompress_file[compression_method < 9 ? compression_method : 9](zipfile, this -> buffer, file_symbol -> uncompressed_size))
zip.cpp:        delete [] this -> buffer;
zip.cpp:        this -> buffer = NULL;
zip.cpp:        this -> buffer = new char[file_symbol -> uncompressed_size];
zip.cpp:                                                                               this -> buffer,
zip.cpp:                                                                               file_symbol -> uncompressed_size))
zip.cpp:            delete [] this -> buffer;
zip.cpp:            this -> buffer = NULL;
zip.cpp:            this -> file_buffer = NULL;
zip.cpp:        NameSymbol *name_symbol = control.FindOrInsertName(directory_name, end - start);
zip.cpp:        DirectorySymbol *subdirectory_symbol = directory_symbol -> FindDirectorySymbol(name_symbol);
zip.cpp:            subdirectory_symbol = directory_symbol -> InsertDirectorySymbol(name_symbol, false);
zip.cpp:    // in processing a qualified-name that represents a package,
zip.cpp:    // -1 to remove last '/'
zip.cpp:    if (name[file_name_length - 1] == U_SLASH)
zip.cpp:                                   file_name_length - 1);
zip.cpp:                          FileSymbol::IsJavaSuffix(&name[file_name_length - FileSymbol::java_suffix_length])),
zip.cpp:                           FileSymbol::IsClassSuffix(&name[file_name_length - FileSymbol::class_suffix_length]));
zip.cpp:            int name_length = file_name_length - (java_file ? FileSymbol::java_suffix_length : FileSymbol::class_suffix_length);
zip.cpp:            for (i = name_length - 1; i >= 0 && name[i] != U_SLASH; i--)
zip.cpp:                                                      name_length - (i + 1));
zip.cpp:            // same name or vice-versa... In that case keep
zip.cpp:            FileSymbol *file_symbol = directory_symbol ->
zip.cpp:                file_symbol = directory_symbol -> InsertFileSymbol(name_symbol);
zip.cpp:                file_symbol -> directory_symbol = directory_symbol;
zip.cpp:                     file_symbol -> SetJava();
zip.cpp:                else file_symbol -> SetClassOnly();
zip.cpp:                file_symbol -> uncompressed_size = uncompressed_size;
zip.cpp:                file_symbol -> offset = relative_offset_of_local_header;
zip.cpp:                file_symbol -> date_time = date_time;
zip.cpp:            else if (file_symbol -> date_time < date_time)
zip.cpp:                     file_symbol -> SetJava();
zip.cpp:                else file_symbol -> SetClass();
zip.cpp:                file_symbol -> uncompressed_size = uncompressed_size;
zip.cpp:                file_symbol -> offset = relative_offset_of_local_header;
zip.cpp:                file_symbol -> date_time = date_time;
zip.cpp:        int rc = fseek(zipfile, -END_SIZE, SEEK_END);
zip.cpp:            buffer_ptr = &zipbuffer[GetFileSize(zipfile, NULL) - END_SIZE];
zip.cpp:    // deal with this crap will appreciate it. -=Chris
zip.cpp:    // -------------------------------------------------
zip.cpp:            for (; magic == 0 && num_loops >= 0 ; num_loops--) {
zip.cpp:                if ((ftell(zipfile) - block_size) < 0)
zip.cpp:                    res = fseek(zipfile, -block_size, SEEK_CUR);
zip.cpp:                res = fseek(zipfile, -block_size, SEEK_CUR); // undo fread
zip.cpp:                for (index_ptr = tmpbuffer + block_size - 1;
zip.cpp:                     index_ptr--)
zip.cpp:                        int span = (tmpbuffer + block_size) - index_ptr;
zip.cpp:                            fseek(zipfile, block_size-span, SEEK_CUR);
zip.cpp:            buffer_ptr = &zipbuffer[GetFileSize(zipfile, NULL) - END_SIZE];
zip.cpp:            for ( ; buffer_ptr >= zipbuffer; buffer_ptr--)
zip.cpp:                       buffer_ptr -= 4;
zip.cpp:        buffer_ptr -= END_SIZE + central_directory_size;
zip.h:// $Id: Print,v 1.1.1.1 2005/07/17 23:21:03 shini Exp $ -*- c++ -*-
Binary file zip.o matches
